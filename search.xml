<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>springboot（4）</title>
      <link href="/deng123-dev.github.io/2020/07/04/springboot%EF%BC%884%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/07/04/springboot%EF%BC%884%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是JSP"><a href="#什么是JSP" class="headerlink" title="什么是JSP"></a>什么是JSP</h1><p>视图层技术</p><p>JSP全称Java Server Pages，是一种动态网页开发技术，JAVA+html的复合体。它使用JSP标签在HTML网页中插入Java代码。标签通常以&lt;%开头以%&gt;结束。</p><p>JSP是一种Java servlet，主要用于实现Java web应用程序的用户界面部分。网页开发者们通过结合HTML代码、XHTML代码、XML元素以及嵌入JSP操作和命令来编写JSP。</p><p>JSP通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页。</p><a id="more"></a><h1 id="springboot整合Thymeleaf"><a href="#springboot整合Thymeleaf" class="headerlink" title="springboot整合Thymeleaf"></a>springboot整合Thymeleaf</h1><h2 id="Thymeleaf介绍"><a href="#Thymeleaf介绍" class="headerlink" title="Thymeleaf介绍"></a>Thymeleaf介绍</h2><p>简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP，通常后端程序员要根据前端程序员做出的页面进行具体业务的实现，因为JSP和html不能直接复用，如果用JSP作为视图技术，那么对于html页面的内容难复用，但是Thymeleaf能够对html数据渲染。</p><p>Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。<strong>这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。</strong></p><p>注意：</p><ul><li><p>Thymeleaf适合做单体应用</p></li><li><p>Thymeleaf不适合做基于服务的，分布式，前后端分离，那就无法体现其特点</p></li></ul><h2 id="Thymeleaf基本使用"><a href="#Thymeleaf基本使用" class="headerlink" title="Thymeleaf基本使用"></a>Thymeleaf基本使用</h2><ol><li>修改pom文件</li></ol><p><img src="/deng123-dev.github.io/images/pasted-129.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">· 添加thymeleaf启动器依赖</span><br></pre></td></tr></table></figure><ol start="2"><li>创建页面跳转的controller类 </li></ol><p><strong>注意：因为templates比static安全性更高。所以不能通过url直接访问templates中的文件,所以要做一个页面跳转类实现页面跳转</strong></p><p><img src="/deng123-dev.github.io/images/pasted-130.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">· 添加Controller注解</span><br><span class="line">· 创建PageController类，添加Getmapping方法</span><br><span class="line">· 实现页面跳转，返回index</span><br></pre></td></tr></table></figure><ol start="3"><li>创建视图</li></ol><p><img src="/deng123-dev.github.io/images/pasted-131.png" alt="upload successful"></p><ol start="4"><li>测试结果</li></ol><p><img src="/deng123-dev.github.io/images/pasted-132.png" alt="upload successful"></p><h2 id="Thymeleaf迭代遍历"><a href="#Thymeleaf迭代遍历" class="headerlink" title="Thymeleaf迭代遍历"></a>Thymeleaf迭代遍历</h2><p>th:each:用于循环迭代集合</p><ol><li>创建一个user实体类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-133.png" alt="upload successful"></p><ol start="2"><li>配置pagecontroller类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-134.png" alt="upload successful"></p><ol start="3"><li>创建视图层</li></ol><p><img src="/deng123-dev.github.io/images/pasted-138.png" alt="upload successful"></p><p><strong><em>关键在于这里的th:each 迭代了list中的内容来创建表格</em></strong></p><ol start="4"><li>测试结果</li></ol><p><img src="/deng123-dev.github.io/images/pasted-135.png" alt="upload successful"></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot（3）</title>
      <link href="/deng123-dev.github.io/2020/05/31/springboot%EF%BC%883%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/05/31/springboot%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="springboot访问静态资源"><a href="#springboot访问静态资源" class="headerlink" title="springboot访问静态资源"></a>springboot访问静态资源</h1><p><img src="/deng123-dev.github.io/images/pasted-115.png" alt="upload successful"></p><a id="more"></a><ul><li><p>springboot默认在static下存放静态页面，存放静态资源的目录名称必须是static</p></li><li><p>springboot默认在templates下存放动态页面，springboot中不推荐使用JSP作为视图层技术，默认使用Thymeleaf来做动态页面</p></li></ul><h2 id="创建并访问一个静态资源"><a href="#创建并访问一个静态资源" class="headerlink" title="创建并访问一个静态资源"></a>创建并访问一个静态资源</h2><ol><li>创建一个静态文件</li></ol><p><img src="/deng123-dev.github.io/images/pasted-116.png" alt="upload successful"></p><ol start="2"><li>测试结果</li></ol><p><img src="/deng123-dev.github.io/images/pasted-117.png" alt="upload successful"></p><h2 id="静态资源存放其他位置"><a href="#静态资源存放其他位置" class="headerlink" title="静态资源存放其他位置"></a>静态资源存放其他位置</h2><h3 id="springboot-访问静态资源的位置"><a href="#springboot-访问静态资源的位置" class="headerlink" title="springboot 访问静态资源的位置"></a>springboot 访问静态资源的位置</h3><p>classpath:/META-INF/resources/</p><p>classpath:/resources/</p><p>classpath:/static/</p><p>classpath:/public/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">其中的classpath均是指main目录下的resources目录</span><br><span class="line">不过除开默认访问位置，也可以自定义访问位置</span><br></pre></td></tr></table></figure><h3 id="自定义静态文件访问位置"><a href="#自定义静态文件访问位置" class="headerlink" title="自定义静态文件访问位置"></a>自定义静态文件访问位置</h3><p>步骤：</p><ul><li><p>访问application.properties</p></li><li><p>“spring.resources.static-locations=”后面加上所访问文件的位置，如果需要指定多个位置，则用“，”隔开</p></li></ul><p><img src="/deng123-dev.github.io/images/pasted-118.png" alt="upload successful"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请注意：</span><br><span class="line">如果自定义了静态资源的默认访问位置，原有的默认访问位置就会失效</span><br></pre></td></tr></table></figure><h1 id="springboot-文件上传"><a href="#springboot-文件上传" class="headerlink" title="springboot 文件上传"></a>springboot 文件上传</h1><h2 id="创建一个文件上传页面"><a href="#创建一个文件上传页面" class="headerlink" title="创建一个文件上传页面"></a>创建一个文件上传页面</h2><p><img src="/deng123-dev.github.io/images/pasted-119.png" alt="upload successful"></p><p>步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">· main目录中的static目录中创建一个html文件</span><br><span class="line">· 用html标记语言攥写网页</span><br></pre></td></tr></table></figure><p>html标记语言</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form  action&#x3D;&quot;&#x2F;fileUploadController&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot;&#x2F;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;OK&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>测试结果</p><p><img src="/deng123-dev.github.io/images/pasted-120.png" alt="upload successful"></p><h2 id="文件上传（编写controller类）"><a href="#文件上传（编写controller类）" class="headerlink" title="文件上传（编写controller类）"></a>文件上传（编写controller类）</h2><h3 id="上传文件的具体方法"><a href="#上传文件的具体方法" class="headerlink" title="上传文件的具体方法"></a>上传文件的具体方法</h3><p><img src="/deng123-dev.github.io/images/pasted-121.png" alt="upload successful"></p><ol><li>controller代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.project1.springboot.demo.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 文件上传</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RestController</span><br><span class="line">public class FileUploadController &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 文件上传</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @PostMapping(&quot;&#x2F;fileUploadController&quot;)</span><br><span class="line">    public String FileUpload(MultipartFile file)throws Exception &#123;</span><br><span class="line">        System.out.println(file.getOriginalFilename());</span><br><span class="line">        file.transferTo(new File(&quot;E:&#x2F;&quot;+file.getOriginalFilename()));</span><br><span class="line">        return &quot;OK&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>测试结果</p><ul><li>上传文件</li></ul><p><img src="/deng123-dev.github.io/images/pasted-122.png" alt="upload successful"></p><ul><li>上传成功</li></ul><p><img src="/deng123-dev.github.io/images/pasted-123.png" alt="upload successful"></p><p><img src="/deng123-dev.github.io/images/pasted-124.png" alt="upload successful"></p><p><img src="/deng123-dev.github.io/images/pasted-125.png" alt="upload successful"></p></li></ol><h3 id="修改上传文件大小"><a href="#修改上传文件大小" class="headerlink" title="修改上传文件大小"></a>修改上传文件大小</h3><ul><li><p>配置单个上个上传文件的大小的限制</p><p>spring.servlet.multipart.max-file-size=2MB</p></li><li><p>配置在一次请求中上传文件的总容量的大小</p><p>spring.servlet.multipart.max-request-size=20MB</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot（2）</title>
      <link href="/deng123-dev.github.io/2020/05/14/springboot%EF%BC%882%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/05/14/springboot%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="创建一个HelloWorld项目"><a href="#创建一个HelloWorld项目" class="headerlink" title="创建一个HelloWorld项目"></a>创建一个HelloWorld项目</h1><p>实例代码：<br><img src="/deng123-dev.github.io/images/pasted-89.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">· 添加@RestController注解</span><br><span class="line">· 创建HelloWorld方法</span><br><span class="line">· 返回字符串</span><br></pre></td></tr></table></figure><a id="more"></a><p>测试结果：</p><p><img src="/deng123-dev.github.io/images/pasted-92.png" alt="upload successful"></p><h1 id="springboot在controller中常用注解"><a href="#springboot在controller中常用注解" class="headerlink" title="springboot在controller中常用注解"></a>springboot在controller中常用注解</h1><table><thead><tr><th>注解名称</th><th>注解解释</th></tr></thead><tbody><tr><td>@RestController</td><td>@RestController注解相当于@ResponseBody ＋ @Controller合在起的作用。RestController使用的效果是将方法返回的对象直接在浏览器上展示成json格式。</td></tr><tr><td>@GetMapping</td><td>相当于@ GetMapping (method=RequestMethod.GET)的缩写</td></tr><tr><td>@PostMapping</td><td>相当于@ PostMapping (method=RequestMethod.POST)的缩写</td></tr><tr><td>@PutMapping</td><td>相当于@ PutMapping (method=RequestMethod.PUT)的缩写</td></tr><tr><td>@DeleteMapping</td><td>相当于@ DeleteMapping (method=RequestMethod.DELETE)的缩写</td></tr></tbody></table><h1 id="springboot整合web层技术"><a href="#springboot整合web层技术" class="headerlink" title="springboot整合web层技术"></a>springboot整合web层技术</h1><h2 id="springboot整合Servlet"><a href="#springboot整合Servlet" class="headerlink" title="springboot整合Servlet"></a>springboot整合Servlet</h2><h3 id="什么是servlet"><a href="#什么是servlet" class="headerlink" title="什么是servlet"></a>什么是servlet</h3><p>　简单来说就是处理请求和发送响应的过程是由一种叫做Servlet的程序来完成的，而且   Servlet是为了解决动态页面产生的</p><p><img src="/deng123-dev.github.io/images/pasted-106.png" alt="upload successful"></p><p> springboot整合Servlet技术一共由两种方法，分别是：</p><ol><li><p>通过注解扫描完成Servlet组件的注册</p></li><li><p>通过方法完成Servlet组件的注册</p></li></ol><h3 id="通过注解扫描完成Servlet组件的注册"><a href="#通过注解扫描完成Servlet组件的注册" class="headerlink" title="通过注解扫描完成Servlet组件的注册"></a>通过注解扫描完成Servlet组件的注册</h3><ol><li>对servlet类的创建（如何进行整合，注意划蓝圈的地方）</li></ol><p><img src="/deng123-dev.github.io/images/pasted-91.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">· 创建servlet包</span><br><span class="line">· 创建一个servlet类继承HttpServlet类</span><br><span class="line">· 重写doGet方法（拥有HttpServletRequest和HttpServletResponse两个参数）</span><br><span class="line">· 添加WebServlet注解（给name属性和urlPatterns属性赋值）</span><br></pre></td></tr></table></figure><ol start="2"><li>对启动类的修改 （如何进行整合，注意划蓝圈的地方）</li></ol><p><img src="/deng123-dev.github.io/images/pasted-93.png" alt="upload successful"></p><p>步骤：</p><p>   <code>添加@ServletComponentScan注解（因为它会自动扫描注解）</code></p><ol start="3"><li>测试结果   </li></ol><p><img src="/deng123-dev.github.io/images/pasted-94.png" alt="upload successful"></p><h3 id="通过方法完成Servlet组件的注册"><a href="#通过方法完成Servlet组件的注册" class="headerlink" title="通过方法完成Servlet组件的注册"></a>通过方法完成Servlet组件的注册</h3><ol><li>创建servlet类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-95.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">· 创建servlet包</span><br><span class="line">· 创建一个servlet类继承HttpServlet类</span><br><span class="line">· 重写doGet方法（拥有HttpServletRequest和HttpServletResponse两个参数）</span><br><span class="line">（其实步骤和注解扫描整合Servlet类一致，唯一不同就是不用添加注解）</span><br></pre></td></tr></table></figure><ol start="2"><li>创建servlet配置类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-103.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">· 创建config包</span><br><span class="line">· 添加@Configuration和@Bean注解</span><br><span class="line">· 实例化ServletRegistrationBean通过ServletRegistrationBean创造新对象bean</span><br><span class="line">· 配置bean的url</span><br><span class="line">· 返回bean</span><br></pre></td></tr></table></figure><ol start="3"><li>测试结果</li></ol><p><img src="/deng123-dev.github.io/images/pasted-98.png" alt="upload successful"></p><h2 id="Springboot整合Filter"><a href="#Springboot整合Filter" class="headerlink" title="Springboot整合Filter"></a>Springboot整合Filter</h2><h3 id="什么是Filter"><a href="#什么是Filter" class="headerlink" title="什么是Filter"></a>什么是Filter</h3><p>Fliter过滤器实际上就是对web资源进行拦截，做一些处理后再交给下一个过滤器或servlet处理通常都是用来拦截request进行处理的，也可以对返回的response进行拦截处理<br><img src="/deng123-dev.github.io/images/pasted-107.png" alt="upload successful"></p><p>和整合servlet一样，整合Filter也有两种方法：</p><ol><li><p>通过注解扫描完成Filter组件的注册</p></li><li><p>通过方法完成Filter组件的注册</p></li></ol><h3 id="通过注解扫描完成Filter组件的注册"><a href="#通过注解扫描完成Filter组件的注册" class="headerlink" title="通过注解扫描完成Filter组件的注册"></a>通过注解扫描完成Filter组件的注册</h3><ol><li>创建Filter类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-99.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">· 添加@WebFilter注解</span><br><span class="line">· 创建Filter包</span><br><span class="line">· 创建一个implements了Filter类的类</span><br><span class="line">· 添加doFilter，init和destroy等方法</span><br></pre></td></tr></table></figure><ol start="2"><li>修改启动类</li></ol><p>步骤：<br><code>和WebServlet一样，都是添加@ServletComponentScan注解</code></p><ol start="3"><li>测试结果</li></ol><p><img src="/deng123-dev.github.io/images/pasted-102.png" alt="upload successful"></p><h3 id="通过方法完成Filter组件的注册"><a href="#通过方法完成Filter组件的注册" class="headerlink" title="通过方法完成Filter组件的注册"></a>通过方法完成Filter组件的注册</h3><ol><li>创建Filter类</li></ol><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">· 创建Filter包</span><br><span class="line">· 创建一个implements了Filter类的类</span><br><span class="line">· 添加doFilter，init和destroy等方法</span><br><span class="line">(其实和通过注解扫描完成Fliter的注册步骤一样，唯一的不同是不用添加注解)</span><br></pre></td></tr></table></figure><ol start="2"><li>创建Filter配置类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-108.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">除开FilterRegistrationBean替代ServletRegistrationBean，</span><br><span class="line">其余和用方法配置servlet类的步骤一致，不做过多说明</span><br></pre></td></tr></table></figure><ol start="3"><li>测试结果</li></ol><p><img src="/deng123-dev.github.io/images/pasted-105.png" alt="upload successful"></p><h2 id="Springboot整合Listener的方式"><a href="#Springboot整合Listener的方式" class="headerlink" title="Springboot整合Listener的方式"></a>Springboot整合Listener的方式</h2><h3 id="什么是Listener"><a href="#什么是Listener" class="headerlink" title="什么是Listener"></a>什么是Listener</h3><p>Listener（监听器）就是一个实现特定接口的普通java程序，这个程序专门用于监听另一个java对象的方法调用或属性改变，当被监听对象发生上述事件后，监听器某个方法将立即被执行。</p><h3 id="通过注解扫描完成Listener组件注册"><a href="#通过注解扫描完成Listener组件注册" class="headerlink" title="通过注解扫描完成Listener组件注册"></a>通过注解扫描完成Listener组件注册</h3><ol><li>创建Listener类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-109.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">·添加@WebListener注解</span><br><span class="line">·创建一个继承 ServletContextListener类的类</span><br></pre></td></tr></table></figure><ol start="2"><li>修改启动类</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">和WebServlet和WebFilter类一样，都是添加@ServletComponentScan注解</span><br></pre></td></tr></table></figure><h3 id="通过方法完成Listener组件注册"><a href="#通过方法完成Listener组件注册" class="headerlink" title="通过方法完成Listener组件注册"></a>通过方法完成Listener组件注册</h3><ol><li>创建Listener类</li></ol><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">和第一种用注解扫描创建的listener一致，(其实和通过注解扫描完成Listener的注册步骤一样，唯一的不同是不用添加注解) 不做过多描述</span><br></pre></td></tr></table></figure><ol start="2"><li>创建Listener配置类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-112.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">除开ListenerRegistrationBean替代ListenerRegistrationBean和不用配置bean.url</span><br><span class="line">其余和用方法配置servlet类的步骤一致，不做过多说明</span><br></pre></td></tr></table></figure><ol start="3"><li>测试结果 </li></ol><p><img src="/deng123-dev.github.io/images/pasted-114.png" alt="upload successful"></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot（1）</title>
      <link href="/deng123-dev.github.io/2020/05/01/springboot%EF%BC%881%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/05/01/springboot%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="spring-boot入门"><a href="#spring-boot入门" class="headerlink" title="spring boot入门"></a>spring boot入门</h1><h2 id="springboot的特点"><a href="#springboot的特点" class="headerlink" title="springboot的特点"></a>springboot的特点</h2><ul><li><p>springboot来简化spring应用开发</p></li><li><p>整个spring技术栈的大整合</p></li><li><p>J2EE的一站式解决方案</p><p>（我觉得简单来说就是对用户封装了很多细节，不需要用户考虑其是怎样实现的）</p><a id="more"></a></li></ul><p> 优点</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 快速创建独立运行的Spring项目以及主流框架集成</span><br><span class="line">2. 使用嵌入式的Servlet容器，应用无需打成WAR包</span><br><span class="line">3. starters自动依赖与版本控制</span><br><span class="line">4. 大量的自动配置，简化开发，也可以修改默认值</span><br><span class="line">5. 无需配置XML，无代码生成，开箱即用</span><br><span class="line">6. 准生产环境的运行时应用监控</span><br><span class="line">7. 与云计算的天然集成</span><br></pre></td></tr></table></figure><p> 缺点</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 入门容易，精通难</span><br><span class="line">2. 需要了解spring的具体框架，才能知道其具体实现原理（了解其底层API）</span><br></pre></td></tr></table></figure><h2 id="如何创建一个springboot项目"><a href="#如何创建一个springboot项目" class="headerlink" title="如何创建一个springboot项目"></a>如何创建一个springboot项目</h2><ol><li><p>通过官网创建项目</p></li><li><p>通过IDEA脚手架创建项目</p></li><li><p>通过IDEA中的Maven创建项目</p></li></ol><p>（想要了解如何创建的小伙伴自行百度或者google，就不细说了）</p><h1 id="微服务（架构风格）"><a href="#微服务（架构风格）" class="headerlink" title="微服务（架构风格）"></a>微服务（架构风格）</h1><h2 id="单体应用"><a href="#单体应用" class="headerlink" title="单体应用"></a>单体应用</h2><p> 单体应用：将所有应用程序打包在一个独立的单元，可以是JAR包，WAR包,EAR或者其他归档形式</p><p><img src="/deng123-dev.github.io/images/pasted-74.png" alt="upload successful"><br>   虽然具有<strong>易于测试，易于部署</strong>等优点，但是随着项目的加大，会存在<strong>牵一发而动全身，受开发人员技术栈</strong>不同等原因的限制</p><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p> 微服务：微服务架构是一种架构思想，将每一个功能元素都最终都是一个可独立替换和可独立升级的软件单元，微服务架构强调的重点是业务系统需要彻底的<strong>组件化和服务化</strong>，原有的<strong>单个业务系统会拆分为多个可以独立开发，设计，运行和运维的小应用</strong>，这些小应用之间通过服务完成交互和集成<br><img src="/deng123-dev.github.io/images/pasted-75.png" alt="upload successful"></p><p>微服务优点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">单个服务更易于开发、维护</span><br><span class="line">单个服务启动比较快</span><br><span class="line">局部修改容易部署</span><br><span class="line">技术栈不受限</span><br><span class="line">按需伸缩</span><br></pre></td></tr></table></figure><p>微服务缺点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运维要求高</span><br><span class="line">分布式固有的复杂性</span><br><span class="line">重复劳动</span><br></pre></td></tr></table></figure><p><strong><em>Spring Boot 是 Java 领域微服务架构最优落地技术</em></strong></p><ul><li><p>spring boot： 快速构建一个微服务应用</p></li><li><p>spring cloud：实现每个独立单元的互调，实现微服务的治理</p></li><li><p>spring cloud data flow：进行流式数据的批处理</p></li></ul><h1 id="spring-boot项目结构："><a href="#spring-boot项目结构：" class="headerlink" title="spring boot项目结构："></a>spring boot项目结构：</h1><h2 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;2.3.1.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br></pre></td></tr></table></figure><ul><li><p>springboot的父级依赖，只有继承它才是真正的springboot项目</p></li><li><p>spring-boot-starter-parent,用来提供相应的Maven依赖</p></li></ul><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>启动器依赖</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br><span class="line">&lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure><p><strong>spring-boot-maven-plugin插件时将springboot的应用程序打包成jar包的插件</strong></p><h2 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h2><p>基于main方法来启动springboot项目；</p><p>启动类在启动时会做注解扫描位置，扫描为同包或者子包下的注解，所以启动类的位置应放在包的根下</p><ul><li><p>启动类和启动器的区别</p><ul><li><p>启动类表示项目的启动入口</p></li><li><p>启动器表示jar包的坐标</p></li></ul></li></ul><h3 id="创建启动类"><a href="#创建启动类" class="headerlink" title="创建启动类"></a>创建启动类</h3><p>启动类代码：<br><img src="/deng123-dev.github.io/images/pasted-81.png" alt="upload successful"></p><p>测试结果<br><img src="/deng123-dev.github.io/images/pasted-83.png" alt="upload successful"></p><p>注意：</p><ul><li>加上@SpringBootApplication注解</li><li>运用SpringApplication中的run方法</li></ul><h2 id="启动器"><a href="#启动器" class="headerlink" title="启动器"></a>启动器</h2><p>springboot将所有的场景做成一个个的启动器，只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。</p><p> spring-boot-starter提供多达44个启动器</p><ul><li><p>spring-boot-starter</p><p>这是springboot的核心启动器，包括自动配置，日志，YAML</p></li><li><p>spring-boot-actuator</p><p>帮助监控和管理应用</p></li><li><p>spring-boot-starter-web</p><p>支持全栈式的web开发</p></li></ul><h2 id="配置文件格式"><a href="#配置文件格式" class="headerlink" title="配置文件格式"></a>配置文件格式</h2><p>springboot提供一个名称为application的全局配置文件，支持properties和YAML格式</p><h3 id="properties格式"><a href="#properties格式" class="headerlink" title="properties格式"></a>properties格式</h3><p><img src="/deng123-dev.github.io/images/pasted-84.png" alt="upload successful"></p><ul><li>使用键值对进行书写  key=value</li></ul><p><img src="/deng123-dev.github.io/images/pasted-88.png" alt="upload successful"></p><h3 id="YAML格式"><a href="#YAML格式" class="headerlink" title="YAML格式"></a>YAML格式</h3><ul><li>大小写敏感</li><li>使用缩进代表层次关系</li><li>使用的部分只能出现一次</li></ul><p>错误写法：</p><p><img src="/deng123-dev.github.io/images/pasted-87.png" alt="upload successful"></p><p>正确写法：</p><p><img src="/deng123-dev.github.io/images/pasted-86.png" alt="upload successful"></p><h2 id="配置文件存放位置及加载顺序"><a href="#配置文件存放位置及加载顺序" class="headerlink" title="配置文件存放位置及加载顺序"></a>配置文件存放位置及加载顺序</h2><h3 id="配置文件存放位置"><a href="#配置文件存放位置" class="headerlink" title="配置文件存放位置"></a>配置文件存放位置</h3><ul><li><p>当前项目的根目录下</p></li><li><p>当前项目根目录下的一个config子目录中</p></li><li><p>项目的resource即classpath根目录下</p></li><li><p>项目的resource即classpath根目录下的config子目录下</p></li></ul><h3 id="配置文件不同格式的加载顺序"><a href="#配置文件不同格式的加载顺序" class="headerlink" title="配置文件不同格式的加载顺序"></a>配置文件不同格式的加载顺序</h3><ul><li><p>优先读取application.properties。</p></li><li><p>如果同一个配置属性，默认读取第一个，默认使用第一个读取到的，后面读取的不会覆盖第一个</p></li></ul><h3 id="配置文件不同位置的加载顺序"><a href="#配置文件不同位置的加载顺序" class="headerlink" title="配置文件不同位置的加载顺序"></a>配置文件不同位置的加载顺序</h3><p> 优先级（从高到低）</p><pre><code>根目录中的config子录-&gt;当前项目根目录-&gt;resource的config子目录-&gt;resource根目录</code></pre><h2 id="配置文件中的占位符"><a href="#配置文件中的占位符" class="headerlink" title="配置文件中的占位符"></a>配置文件中的占位符</h2><ol><li><p>语法：<br>${}</p></li><li><p>作用</p><ul><li><p>${}中可以获取框架提供方法的值</p></li><li><p>可以获取配置文件中的键的值赋给另一个键作为值</p></li></ul></li></ol><h2 id="bootstrap配置文件"><a href="#bootstrap配置文件" class="headerlink" title="bootstrap配置文件"></a>bootstrap配置文件</h2><h3 id="bootstrap配置文件介绍"><a href="#bootstrap配置文件介绍" class="headerlink" title="bootstrap配置文件介绍"></a>bootstrap配置文件介绍</h3><p> springboot中的两种上下文对象，分为bootstrap和application，bootstrap是应用程序的父上下文，也就是说bootstrap加载优先于application，bootstrap主要从额外的资源加载配置信息，<strong>它是任何spring应用程序外部属性的来源</strong>，bootstrap里面的属性会优先加载，它们默认也不能被本地相同配置覆盖</p><h3 id="bootstrap配置文件特征"><a href="#bootstrap配置文件特征" class="headerlink" title="bootstrap配置文件特征"></a>bootstrap配置文件特征</h3><ul><li><p>bootstrap由父ApplicationContext加载，比application优先加载</p></li><li><p>bootstrap的属性不能被覆盖</p></li></ul><h3 id="bootstrap和-application的应用场景"><a href="#bootstrap和-application的应用场景" class="headerlink" title="bootstrap和 application的应用场景"></a>bootstrap和 application的应用场景</h3><ol><li><p>application主要用于springboot项目的自动化配置</p></li><li><p>bootstrap主要应用于：</p><ul><li><p>使用spring cloud config 配置中心时，需要bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息</p></li><li><p>一些固定不能被覆盖的属性</p></li><li><p>加密/解密的场景</p></li></ul></li></ol><h2 id="springboot核心注解"><a href="#springboot核心注解" class="headerlink" title="springboot核心注解"></a>springboot核心注解</h2><ol><li><p>@SpringBootApplication</p><p>springboot的启动类</p></li><li><p>@SpringBootConfiguration</p><p>此注解是@Configuration注解的派生注解，和@Configuration注解的功能一致</p></li><li><p>@Configuration</p><p>通过对bean对象的操作替代spring中的xml文件</p></li><li><p>@EnableAutoConfiguration</p><p>springboot自动配置，尝试根据你添加的jar包依赖自动配置你的spring应用</p></li><li><p>@AutoConfigurationPackage</p><p>自动注入主类下所在包下所有的加了注解的类</p></li><li><p>@Import</p><ul><li><p>直接导入普通类</p></li><li><p>导入实现了ImportSelector接口的类</p></li><li><p>导入实现了ImportBeanDefinitionRegister接口的类</p></li></ul></li><li><p>@ComponentScan</p><p>组件扫描，可自动发现和装配一些bean</p></li><li><p>@ConfigurationProperties</p><p>扫描配置属性</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web基础（2）</title>
      <link href="/deng123-dev.github.io/2020/04/04/web%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/04/04/web%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-超文本传输协议"><a href="#HTTP-超文本传输协议" class="headerlink" title="HTTP(超文本传输协议)"></a>HTTP(超文本传输协议)</h1><p> HTTP是基于<strong>C/S架构</strong>的<strong>应用层</strong>协议，请求通常是由 浏览器这样的客户端发起的，有web 服务器进行处理<br> 客户端和服务器通过交换各自的信息进行交互。<br> <a id="more"></a></p><ul><li>默认端口为<strong>80</strong></li><li>由像浏览器这样的客户端发出的消息叫做request </li><li>被服务器响应的消息叫做responses</li><li>无状态性：每次请求都是相互独立的</li></ul><h2 id="HTTP-request"><a href="#HTTP-request" class="headerlink" title="HTTP:request"></a>HTTP:request</h2><p>对于browser请求页面的流程：</p><ul><li>与服务器建立TCP连接；</li><li>发送HTTP请求；</li><li>收取HTTP响应，然后把网页在浏览器中显示出来。</li></ul><h3 id="请求格式"><a href="#请求格式" class="headerlink" title="请求格式"></a>请求格式</h3><p><img src="/deng123-dev.github.io/images/pasted-68.png" alt="upload successful"></p><h4 id="请求行和请求头部"><a href="#请求行和请求头部" class="headerlink" title="请求行和请求头部"></a>请求行和请求头部</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: www.sina.com.cn</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 xxx</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,en-US;q&#x3D;0.8</span><br></pre></td></tr></table></figure><ul><li>请求行解释</li></ul><table><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>GET</td><td>表示使用获取路径为/的资源</td></tr><tr><td>HTTP/1.1</td><td>表示使用的是HTTP  1.1的协议</td></tr></tbody></table><ul><li>请求头解释</li></ul><table><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>HOST</td><td>表示请求的主机名,表示浏览器正在请求的域名</td></tr><tr><td>User-Agent</td><td>表示客户端本身，例如浏览器的表示</td></tr><tr><td>Accept</td><td>表示浏览器能接收的数据类型，如text/<em>，images/</em></td></tr><tr><td>Accept-Language</td><td>表示浏览器偏好的语言</td></tr><tr><td>Accept-Encoding</td><td>表示浏览器可以支持的压缩类型，例如gzip, deflate, br</td></tr></tbody></table><h4 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h4><p>因为<strong>get通过URL传送数据</strong>，而<strong>post通过请求数据体传送数据</strong>，所以一般情况下get方法中不体现请求数据（<strong>当然也可以将请求数据放在get中的请求数据体中使其体现</strong>）</p><h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><p>请求参数的两种方式：</p><ol><li>URL（GET请求）：</li></ol><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浏览器？参数名&#x3D;参数值&amp;参数二&#x3D;参数值</span><br></pre></td></tr></table></figure><ol start="2"><li>request body（POST请求）</li></ol><p>通过request body传递参数</p><ol start="3"><li><p>参数格式：</p><ul><li><p>多个参数用&amp;隔开</p></li><li><p>参数以键值对的方式出现</p></li></ul></li></ol><h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载</p><p> 好处：</p><ul><li>缓解服务器端压力</li><li>提升性能(获取资源的耗时更短了)</li></ul><p>（关于缓存的内容确实少的可怜，其中一个重要原因在于我对缓存的了解太少，望各位大佬指教）</p><h3 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h3><table><thead><tr><th>动词名称</th><th>解释</th></tr></thead><tbody><tr><td>GET</td><td>从服务器取出资源（单个或多个）。</td></tr><tr><td>POST</td><td>在服务器新建资源。</td></tr><tr><td>PUT</td><td>在服务器更新资源（客户端提供改变后的完整资源）。</td></tr><tr><td>PATCH</td><td>在服务器更新(属性)资源（客户端提供改变的属性，比如说某个字段+1）。</td></tr><tr><td>DELETE</td><td>从服务器删除资源。</td></tr></tbody></table><p>还有两个不常用的HTTP动词：</p><table><thead><tr><th>动词名称</th><th>解释</th></tr></thead><tbody><tr><td>HEAD</td><td>获取资源的元数据。</td></tr><tr><td>OPTIONS</td><td>获取信息，关于资源的哪些属性是客户端可以改变的。</td></tr></tbody></table><h3 id="Get和Post的区别"><a href="#Get和Post的区别" class="headerlink" title="Get和Post的区别"></a>Get和Post的区别</h3><ul><li>Get：从服务器上面获取数据</li><li>post: 向服务器传输数据</li></ul><table><thead><tr><th>分类</th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>后退按钮/刷新</td><td>无害</td><td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td></tr><tr><td>书签</td><td>可收藏为书签</td><td>不可收藏为书签</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能缓存</td></tr><tr><td>传参数方式</td><td>用URL传参数</td><td>用body传参数</td></tr><tr><td>历史</td><td>参数保留在浏览器历史中。</td><td>参数不会保存在浏览器历史中。</td></tr><tr><td>对数据长度的限制</td><td>是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td><td>无限制。</td></tr><tr><td>对数据类型的限制</td><td>只允许 ASCII 字符。</td><td>没有限制。也允许二进制数据。</td></tr><tr><td>安全性</td><td>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td><td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr><tr><td>可见性</td><td>数据在 URL 中对所有人都是可见的。</td><td>数据不会显示在 URL 中。</td></tr></tbody></table><h3 id="发送post请求"><a href="#发送post请求" class="headerlink" title="发送post请求"></a>发送post请求</h3><p>三种发送post请求的方法：</p><ul><li><p>浏览器默认使用get请求</p></li><li><p>线上的默认工具发送 post请求</p></li><li><p>HTML from中可以指定get或post请求</p></li></ul><p><em>form中的post请求</em>：</p><pre><code>&lt;form action=&quot;https://www.baidu.com&quot; method=&quot;post&quot;&gt;          &lt;p&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;/p&gt;          &lt;p&gt;密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;/&gt;&lt;/p&gt;          &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;      &lt;/form&gt;    </code></pre><p> <em>展示的效果</em>：</p> <form action="https://www.baidu.com" method="post">            <p>用户名：<input type="text" name="name"/></p>            <p>密码：<input type="password" name="pwd"/></p>            <input type="submit" value="登录">        </form><h2 id="HTTP-response"><a href="#HTTP-response" class="headerlink" title="HTTP:response"></a>HTTP:response</h2><h3 id="reponse格式"><a href="#reponse格式" class="headerlink" title="reponse格式"></a>reponse格式</h3><p>HTTP响应也由三个部分组成，分别是：<strong>状态行、消息报头、响应正文</strong>。</p><ul><li><p>格式：</p><p> ＜status-line＞</p><p> ＜headers＞</p><p> ＜blank line＞</p><p> [＜response-body＞]</p></li><li><p>response和request的区别：</p></li></ul><p><strong><em>response用状态字段代替了request请求信息</em></strong></p><h3 id="reponse状态代码"><a href="#reponse状态代码" class="headerlink" title="reponse状态代码"></a>reponse状态代码</h3><ul><li>首数字的状态响应码以及对应情况 </li></ul><table><thead><tr><th>相应类别</th><th>代表情况</th></tr></thead><tbody><tr><td>1xx</td><td>指示信息–表示请求已接收，继续处理</td></tr><tr><td>2xx</td><td>成功–表示请求已被成功接收、理解、接受</td></tr><tr><td>3xx</td><td>重定向–要完成请求必须进行更进一步的操作</td></tr><tr><td>4xx</td><td>客户端错误–请求有语法错误或请求无法实现</td></tr><tr><td>5xx</td><td>服务器端错误–服务器未能实现合法的请求</td></tr></tbody></table><ul><li>常见状态码以及对应情况</li></ul><table><thead><tr><th>常见的状态代码</th><th>表示的情况</th></tr></thead><tbody><tr><td>200 OK：</td><td>客户端请求成功。</td></tr><tr><td>301 Moved Permanently</td><td>被请求的资源已永久移动到新位置</td></tr><tr><td>302 Found</td><td>要求客户端执行临时重定向</td></tr><tr><td>400 Bad Request：</td><td>客户端请求有语法错误，不能被服务器所理解。</td></tr><tr><td>403 Forbidden：</td><td>服务器收到请求，但是拒绝提供服务。</td></tr><tr><td>404 Not Found：</td><td>请求资源不存在，举个例子：输入了错误的URL。</td></tr><tr><td>500 Internal Server Error：</td><td>服务器发生不可预期的错误。</td></tr><tr><td>503 Server Unavailable：</td><td>服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。</td></tr></tbody></table><h1 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h1><h2 id="web服务器概览"><a href="#web服务器概览" class="headerlink" title="web服务器概览"></a>web服务器概览</h2><p><img src="/deng123-dev.github.io/images/pasted-69.png" alt="upload successful"></p><ul><li><p>web服务器：</p><ul><li>web服务器软件是一个服务端软件 </li><li>可以把静态网页部署到web服务器</li><li>web服务器主要运行静态页面 </li></ul></li><li><p>应用服务器：</p><ul><li>应用服务器可以运行动态页面</li></ul></li><li><p>web服务器和应用服务器通常一起使用</p></li><li><p>Web服务器主要 是处理向浏览器发送HTML以供浏览，而应用程序服务器提供访问商业逻辑的途径以供客户端应用程序使用。</p></li></ul><h2 id="常见的web服务器"><a href="#常见的web服务器" class="headerlink" title="常见的web服务器"></a>常见的web服务器</h2><ol><li><p>Apache服务器<br><img src="/deng123-dev.github.io/images/pasted-70.png" alt="upload successful"><br>Apache仍然是世界上用得最多的Web服务器，优势主要在于源代码开放，可以运行在几乎所有的Unix, Windows. Linux系统平台上</p></li><li><p>Nginx服务器</p></li></ol><p><img src="/deng123-dev.github.io/images/pasted-71.png" alt="upload successful"><br>只能运行在Linux/Unix，其特点是占有内存少，并发能力强</p><ol start="3"><li>ISS服务器</li></ol><p><img src="/deng123-dev.github.io/images/pasted-72.png" alt="upload successful"><br>Microsoft的W eb服务器产品为Internet Information Server C IIS ) .  IIS是允许在公共Intranet或Internet上发布信息的Web服务器。IIS只能运行在Microsoft Windows平台</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web基础（1）</title>
      <link href="/deng123-dev.github.io/2020/03/21/web%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/03/21/web%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="网络概览"><a href="#网络概览" class="headerlink" title="网络概览"></a>网络概览</h1><p>终端：用户与计算机进行交互的设备</p><p>网络：是由若干节点和连接这些节点的链路构成，表示诸多对象及其相互联系。</p><h2 id="按拓扑结构分类："><a href="#按拓扑结构分类：" class="headerlink" title="按拓扑结构分类："></a>按拓扑结构分类：</h2><ol><li>总线型</li></ol><p><img src="/deng123-dev.github.io/images/pasted-53.png" alt="upload successful"></p><a id="more"></a><ol start="2"><li>环型</li></ol><p><img src="/deng123-dev.github.io/images/pasted-54.png" alt="upload successful"><br>3. 星型</p><p><img src="/deng123-dev.github.io/images/pasted-55.png" alt="upload successful"><br>4. 树型</p><p><img src="/deng123-dev.github.io/images/pasted-56.png" alt="upload successful"><br>5. 网型</p><p><img src="/deng123-dev.github.io/images/pasted-57.png" alt="upload successful"></p><h2 id="按覆盖范围分"><a href="#按覆盖范围分" class="headerlink" title="按覆盖范围分"></a>按覆盖范围分</h2><ul><li>局域网 LAN</li><li>城域网 MAN</li><li>广域网 WAN<h2 id="网络主要功能"><a href="#网络主要功能" class="headerlink" title="网络主要功能"></a>网络主要功能</h2></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 资源共享</span><br><span class="line">2. 快速传输信息</span><br><span class="line">3. 提高系统可靠性</span><br><span class="line">4. 易于进行分布式处理</span><br><span class="line">5. 综合信息服务</span><br></pre></td></tr></table></figure><h1 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h1><h2 id="OSI（开放式系统互联模型）层次"><a href="#OSI（开放式系统互联模型）层次" class="headerlink" title="OSI（开放式系统互联模型）层次"></a>OSI（开放式系统互联模型）层次</h2><p><img src="/deng123-dev.github.io/images/pasted-58.png" alt="upload successful"></p><p><img src="/deng123-dev.github.io/images/pasted-59.png" alt="upload successful"></p><h2 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h2><p> TCP/IP协议族是一个四层协议系统：<br><img src="/deng123-dev.github.io/images/pasted-60.png" alt="upload successful"></p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><ol><li><p>实现网卡驱动，以处理数据在以太网等物理媒介的传输</p></li><li><p>为上层协议提供一个统一的接口</p></li><li><p>协议应用：</p><ul><li>以太网协议：<br>规定一组电信号就是一个数据包，一个数据包为<strong>一帧</strong>。数据包是从一个网卡发到另一个网卡，<strong>网卡地址</strong>，也就是帧首部所包含的<strong>MAC地址</strong>，具有全球唯一性。<strong>对电信号进行分组并形成具有特定意义的数据帧，然后以广播的形式通过物理介质发送给接收方。</strong></li></ul></li></ol><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ol><li><p>网络层的任务之一使选择这些中间节点，以确定两台主机间的通讯路径</p></li><li><p>其次网络层对上层协议隐藏了网络拓扑联结的细节，在使得传输层看来通讯双方是直接连接的</p></li><li><p>协议应用：</p><ul><li>IP协议：判断两台主机是否处于同一个网络，IP地址目前有两个版本，分别是IPV4，IPV6,IPV4是一个32位地址，常采用4个十进制数字表示。IP协议将这个32位的地址分为两部分，前面部分表示网络地址，后面部分表示该主机在局域网中的地址。由于各类地址的分发不尽相同，以c类地址为例，其中前24位就是网络地址，后8位就是主机地址。因此，<strong>如果两个IP地址在同一子网内，则网络地址一定相同。</strong>为了判断IP地址中的网络地址，IP协议还引入了子网掩码，IP地址和子网掩码通过<strong>按位与</strong>运算后就可以得到网络地址。</li><li>ARP(地址转换协议):根据IP地址获取物理地址的一个TCP/IP协议。</li><li>RARP(逆地址转换协议):允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址。</li><li>路由协议：ARP的MAC寻址还是局限在同一个子网中，因此网络层引入了路由协议，首先通过IP来判断主机是否在同一子网，如果在同一子网，通过ARP协议查询对应的MAC地址，然后以广播形式向子网内的主机发送数据包；如果不在同一子网，以太网会将数据包转发给本子网的网关进行路由。网关是互联网网上子网与子网之间的桥梁，网关进行多次转发，最终将数据包转发到目标IP所在的子网中，然后通过ARP获取目标及MAC,最终发送。</li></ul></li><li><p>IPV4数据包结构：<br><img src="/deng123-dev.github.io/images/pasted-61.png" alt="upload successful"></p></li><li><p>总结:<br>总而言之，网络层的主要工作是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.定义网络地址</span><br><span class="line">2.区分网络</span><br><span class="line">3.子网内MAC寻址</span><br><span class="line">4.对于不同子网数据包进行路由</span><br></pre></td></tr></table></figure><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>协议为网络端点主机上提供可靠、可靠、有效的报文传送服务。其功能紧密以来于网络层的虚拟电路或数据报服务，传输层定义了主机应用程序之间的连通性。传输层的服务要经历<strong><em>连接建立，数据传输,传输连接释放</em></strong>3个阶段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口</span><br></pre></td></tr></table></figure><h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>面向连接的，可靠传输的，有流量控制的，拥塞控制，面向字节流传输等很多优点，在端和端之间通信</p><h5 id="三次握手（面向连接）"><a href="#三次握手（面向连接）" class="headerlink" title="三次握手（面向连接）"></a>三次握手（面向连接）</h5><p>在通信之前，会通过三次握手机制来判断连接是否可用，UDP则不需要，直接传</p></li></ol><p><img src="/deng123-dev.github.io/images/pasted-62.png" alt="upload successful"></p><ul><li>第一次握手：<br>客户端想与服务器连接了，所以状态变为主动打开，同时发送一个连接请求给服务器端SYN=1，并且会携带x个字节过去。发送完请求连接报文后，客户端的状态变为了SYN_SENT，可以说这个状态是等待发送确认(为了发送第三次握手时的确认包)</li></ul><p>(<em>其实就是客户端和服务器谈恋爱，主动给服务器发一个消息，然后等待服务器的回应</em>)</p><ul><li>第二次握手：<br>服务器端收到连接请求报文后，从LSTTEN变为被动打开状态，然后给客户端返回两层报文。一是确认报文，而可以到达告诉客户端，我也打开连接了。发完后，变为SYN_RCVD状态（等待确认状态，等待接收客户端发过来的确认包）</li></ul><p>(<em>服务器这边收到了客户机想谈恋爱的消息，从被动状态变成主动，开始也给客户机发一个暗示客户机服务器想谈恋爱的消息</em>)</p><ul><li>第三次握手：<br>客户得到服务器端的确认知道服务器端也已经准备好了连接后，还会发一个确认报文到服务器端，告诉它，我收到你发送的报文了，接下来我们两个进行连接。客户端发送完确认报文后，进入ESTABLISHED，服务器接到了，也变成了 ESTABLISHED，连接完成。</li></ul><p>(<em>客户机收到了服务器发的消息，明白了服务器的意思，再给服务器发送一个表白的消息，正式的和服务器在一起，客户机和服务器的连接就建立了</em>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以划一波重点：</span><br><span class="line">三次握手的作用：确认双方对对方的收发能力是否正常</span><br></pre></td></tr></table></figure><h5 id="四次握手，关闭连接"><a href="#四次握手，关闭连接" class="headerlink" title="四次握手，关闭连接"></a>四次握手，关闭连接</h5><p><img src="/deng123-dev.github.io/images/pasted-63.png" alt="upload successful"><br>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭<br>(<em>相当一对情侣分手</em>)</p><ul><li><p>客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。<br>(<em>客户端要和服务端分手，就发了一个分手消息给服务端</em>)</p></li><li><p>服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。<br>(<em>服务器收到了这个消息，有点伤心而且不敢相信，发消息给客户端，这时客户端确认服务器收到了要分手的消息</em>)</p></li><li><p>服务器B关闭与客户端A的连接，发送一个FIN给客户端A。</p></li></ul><p>(<em>服务器确认了客户端执意与自己分手，直接与客户端分手并且中断了他们的连接</em>)</p><ul><li>客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。<br>(<em>客户端这时收到服务器发的分手消息，为她送上最后的祝福，同时也让服务器知道客户机收到了她的消息</em>)</li></ul><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><p>UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法<br>其有以下特点：</p><ul><li><p>面向无连接</p></li><li><p>有单播，多播和广播的功能</p></li><li><p>UDP 是面向报文的</p></li><li><p>不可靠性</p></li></ul><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="DNS-域名解析系统"><a href="#DNS-域名解析系统" class="headerlink" title="DNS(域名解析系统)"></a>DNS(域名解析系统)</h4><p>在internet上域名与IP地址一一对应，域名便于人们记忆，但机器之间只认IP地址，他们之间的转换称为<strong><em>域名解析</em></strong>,DNS就是专门用来解析域名解析的服务器</p><h4 id="DHCP-动态主机配置协议"><a href="#DHCP-动态主机配置协议" class="headerlink" title="DHCP(动态主机配置协议)"></a>DHCP(动态主机配置协议)</h4><p>DHCP（动态主机配置协议）是一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。能够动态分配IP地址</p><h4 id="FTP-文件传输协议"><a href="#FTP-文件传输协议" class="headerlink" title="FTP(文件传输协议)"></a>FTP(文件传输协议)</h4><p>用于Internet上的文件控制的双向传输，同时，它也是一个应用程序，TCP协议</p><p>FTP允许用户以文件操作的方式（如文件的增、删、改、查、传送等）与另一主机相互通信。然而， 用户并不真正登录到自己想要存取的计算机上面而成为完全用户， 可用FTP程序访问远程资源， 实现用户往返传输文件、目录管理以及访问电子邮件等等， 即使双方计算机可能配有不同的操作系统和文件存储方式</p><p><strong>ftp默认端口21</strong></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：线性表，栈和队列</title>
      <link href="/deng123-dev.github.io/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%8C%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/deng123-dev.github.io/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%8C%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>数据结构是相互之间存在一种或多种特定关系的数据元素的集合 <a id="more"></a><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3></li></ul><p> <strong>从逻辑关系上描述数据，与数据的存储无关</strong></p><ul><li>集合结构</li></ul><p>元素属于同一集合，非线性结构</p><ul><li>线性结构</li></ul><p>除元素属于同一集合，元素之间存在一对一的关系</p><ul><li>树结构</li></ul><p>元素之间存在一对多的关系，非线性结构</p><ul><li>图结构或网状结构</li></ul><p>元素之间存在多对多的关系，非线性结构</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><ul><li>顺序存储结构</li></ul><p>存储器的相对位置来表示数据元素的逻辑关系</p><ul><li>链式存储结构</li></ul><p>数据元素的存放地址是否连续没有要求</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><ul><li><p>有穷性 </p></li><li><p>确定性</p></li><li><p>可行性</p></li><li><p>输入</p></li><li><p>输出</p><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3></li><li><p>时间复杂度</p></li></ul><p>算法计算量的大小</p><ul><li>算法空间复杂度</li></ul><p>算法所需存储空间大小</p><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><ul><li>由n个数据特性相同构成的有限序列称为线性表 </li><li>特点：除第一个和最后一个数据元素，其他元素都有一个直接前驱和一个直接后继</li></ul><h2 id="线性表的顺序存储表示"><a href="#线性表的顺序存储表示" class="headerlink" title="线性表的顺序存储表示"></a>线性表的顺序存储表示</h2><ol><li><p>由一组地址连续的存储单元存储线性表的数据元素</p></li><li><p>数组长度和线性表的长度区别：数组长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的，线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。</p></li><li><p>ASL（平均查找长度）：ASL=∑PiCi (i=1,2,3,…,n),</p></li><li><p>顺序表操作</p><ul><li><p>查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> int findElem (Sqlist L,int e)&#123;    int i;    for (i&#x3D;0,i&lt;L.length,++i)   &#x2F;&#x2F;遍历L长度中的每个位置        </span><br><span class="line"> if(e &#x3D;&#x3D; L.data[i])          &#x2F;&#x2F;获取每个位置对应的值和e值进行判断，这里的等于可以是大于、小于</span><br><span class="line"> return i;                    &#x2F;&#x2F;如果找到与e值相等的值，则返回该值对应的位置</span><br><span class="line">return -1;                        &#x2F;&#x2F;如果找不到，则返回-1&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> int insertElem(Sqlist &amp;L,int p,int e) &#x2F;&#x2F;L是顺序表的长度，要发生变化，所以用引用型&#123;    int i    if (p&lt;0 || p&gt;L.length || L.length&#x3D;&#x3D;maxsize) &#x2F;&#x2F;如果插入e的位置p小于0，或者是大于L的长度，或者是L的长度已经等于了顺序表最大存储空间  </span><br><span class="line"> return 0;</span><br><span class="line"> for (i&#x3D;L.length-1; i&gt;&#x3D;p;--i)    &#x2F;&#x2F;从L中的最后一个元素开始遍历L中位置大于p的每个位置  </span><br><span class="line"> L.data[i+1]&#x3D;L.data[i];    &#x2F;&#x2F;依次将第i个位置的值赋值给i+1    </span><br><span class="line"> L.data[p]&#x3D;e;                  &#x2F;&#x2F;将p位置插入e</span><br><span class="line"></span><br><span class="line">++(L.length);                 &#x2F;&#x2F;L的长度加1  </span><br><span class="line">return 1;                     &#x2F;&#x2F;插入成功，返回1&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int deleteElem (Sqlist &amp;L,int p,int &amp;e)    &#x2F;&#x2F;需要改变的变量用引用型&#123;    int i;    if(p&lt;0 || p&gt;L.length-1)    &#x2F;&#x2F;对位置p进行判断，如果位置不对，则返回0，表示删除失败      </span><br><span class="line">return 0;    </span><br><span class="line">e&#x3D;L.data[p];               &#x2F;&#x2F;将要删除的值赋值给e  </span><br><span class="line">for(i&#x3D;p;i&lt;L.length-1;++i)  &#x2F;&#x2F;从位置p开始，将其后边的元素逐个向前覆盖       </span><br><span class="line">L.data[i]&#x3D;L.data[i+1];</span><br><span class="line">--(L.length)               &#x2F;&#x2F;将表的长度减1</span><br><span class="line">return 1;                  &#x2F;&#x2F;删除成功，返回1&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="线性表的链式存储表示"><a href="#线性表的链式存储表示" class="headerlink" title="线性表的链式存储表示"></a>线性表的链式存储表示</h2><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><ol><li><p>链式线性表定义：由一组任意地址的存储单元存储线性表的数据元素</p></li><li><p>链表的存储密度=单链表数据项所占空间/节点所占空间</p></li><li><p>链表增加头结点作用：</p><ul><li>便于首元节点的处理</li><li>便于空表和非空表的统一处理</li></ul><p><img src="/deng123-dev.github.io/images/pasted-40.png" alt="upload successful"></p></li><li><p>单链表操作</p><ul><li><p>插入<br>将s插在p后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;next&#x3D;p-&gt;next;p-&gt;next&#x3D;s;</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next&#x3D;p-&gt;next-&gt;next;</span><br></pre></td></tr></table></figure><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表的结点有两个指针域，一个指向直接前驱，一个指向直接后继</p></li><li><p>查找</p></li></ul><p>在双链表中查找值为x的结点，如果找到，则返回该结点的指针，否则返回NULL值。</p><figure class="highlight plain"><figcaption><span>findNode(DLNode *C,int x)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;    DLNode *p &#x3D; C -&gt; next;   </span><br><span class="line">while(p !&#x3D; NULL)</span><br><span class="line">&#123;  if(p -&gt; data &#x3D;&#x3D; x)</span><br><span class="line">          break;     </span><br><span class="line">p &#x3D; p -&gt; next;    &#125;  </span><br><span class="line">return p;&#125;</span><br></pre></td></tr></table></figure><ul><li>插入</li></ul><p>在双链表中p所指的结点之后插入一个结点s,核心思想就是将p的指向赋值给s,即让s指向p所指,s的前结点就是p,p的后结点就是s,具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s -&gt; next &#x3D; p -&gt; next;</span><br><span class="line">s -&gt; prior &#x3D; p;</span><br><span class="line">p -&gt; next &#x3D; s;</span><br><span class="line">s -&gt; next -&gt; prior &#x3D; s;</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><p>要删除双链表中p结点的后继结点，核心思想就是先将p的后继结点给到q,然后让p指向q的后继结点，q的后继结点的前结点就是p，然后把q释放掉，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  q &#x3D; p -&gt; next;</span><br><span class="line">p -&gt; &#x3D; q -&gt; next;</span><br><span class="line">q -&gt; next -&gt; prior &#x3D; p;</span><br><span class="line">free(q);</span><br></pre></td></tr></table></figure><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1></li></ol><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul><li><p><strong>栈是限定仅在表尾进行插入和删除操作的线性表</strong>，我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈，栈又称后进后出的线性表，简称LIFO结构。</p></li><li><p>栈首先是一个线性表，也就是说，栈元素具有线性关系，即前驱后继关系，只不过它是一种特殊的线性表而已。</p></li><li><p>栈的特殊之处在于<strong>限制了这个线性表的插入和删除位置，它始终只在栈顶进行。</strong>这也就使得：栈底是固定的，最先进栈的只能在栈底。</p></li><li><p>栈的插入操作，叫做进栈；栈的删除操作叫做出栈。</p><h3 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h3></li></ul><p><img src="/deng123-dev.github.io/images/pasted-41.png" alt="upload successful"></p><ol><li><p>顺序栈的基本操作</p><ul><li>初始化栈<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int stack[maxsize];int top &#x3D; -1;</span><br></pre></td></tr></table></figure></li><li>元素x进栈<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack[++top] &#x3D; x</span><br></pre></td></tr></table></figure></li><li>元素x出栈<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; stack[top--]</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h3><p><strong>把栈顶放在单链表的头部</strong>，用链表来存储栈的的数据结构称为链栈。<br><img src="/deng123-dev.github.io/images/pasted-42.png" alt="upload successful"></p><ul><li>链栈的插入操作：<br><img src="/deng123-dev.github.io/images/pasted-43.png" alt="upload successful"></li><li>链栈的删除操作</li></ul><p><img src="/deng123-dev.github.io/images/pasted-44.png" alt="upload successful"></p><ol><li>链栈的基本操作：</li></ol><ul><li>元素（指针p所指）进栈操作<br>/<em>类似于头插法建立链表</em>/</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void PushStack(LinkStack top, DataType data)</span><br><span class="line">&#123;</span><br><span class="line">    LStackNode*  p;</span><br><span class="line">    p &#x3D; (LStackNode*)(malloc(sizeof(LStackNode))); </span><br><span class="line">    if (p &#x3D;&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;内存分配失败！\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;data &#x3D; data;</span><br><span class="line">        p-&gt;next &#x3D; top-&gt;next;</span><br><span class="line">        top-&gt;next &#x3D; p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>出栈操作（出栈元素保存在x中）<br>/<em>类似于单链表的删除操作</em>/</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void PopStack(LinkStack top,DataType* data)</span><br><span class="line">&#123;</span><br><span class="line">    LStackNode* p;</span><br><span class="line">    p &#x3D; top-&gt;next;</span><br><span class="line">    if (p&#x3D;&#x3D;NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;栈为空！\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        top-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">        *data &#x3D; p-&gt;data;</span><br><span class="line">        free(p);   &#x2F;&#x2F;释放p指向的结点</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：排序</title>
      <link href="/deng123-dev.github.io/2020/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%8E%92%E5%BA%8F/"/>
      <url>/deng123-dev.github.io/2020/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概叙"><a href="#概叙" class="headerlink" title="概叙"></a>概叙</h2><p><img src="/deng123-dev.github.io/images/pasted-49.png" alt=" "></p><a id="more"></a><p> 相关知识点：</p><ul><li><p>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</p></li><li><p>不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</p></li><li><p>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</p></li><li><p>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数</p></li></ul><p>2.它们之间的性能比较：<br><img src="/deng123-dev.github.io/images/pasted-10.png" alt="upload successful"><br>当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：<code>快速排序``堆排序</code> <code>归并排序</code></p><p>排序有<code>内部排序</code>和<code>外部排序</code>,内部排序是数据记录在<code>内存</code>中进行排序，而外部排序是排序的数据很大，一次不能容纳全部的排序记录，而排序过程中需要访问<code>外存</code></p><p><code>八大排序就是内部排序。</code></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="简单插入排序"><a href="#简单插入排序" class="headerlink" title="简单插入排序"></a>简单插入排序</h3><h4 id="算法描述："><a href="#算法描述：" class="headerlink" title="算法描述："></a>算法描述：</h4><ul><li>从第一个元素开始划分出一个有序的序列</li><li>依次取出下一个元素,在已经排序的元素序列中从后向前扫描</li><li>如果已排序元素大于新元素，该元素移到下一个我位置</li><li>重复步骤3，直到找到新元素所在位置</li><li>重复2，5步骤<br><img src="/deng123-dev.github.io/images/pasted-33.png" alt="upload successful"><!-- more --><h4 id="c语言实现："><a href="#c语言实现：" class="headerlink" title="c语言实现："></a>c语言实现：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> #直接插入排序</span><br><span class="line"> </span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">void InsertionSort(int* arr,int len)</span><br><span class="line">&#123;</span><br><span class="line">int i ,j;</span><br><span class="line">for (i &#x3D; 1;i &lt;&#x3D; len;i++)</span><br><span class="line">&#123;</span><br><span class="line">j &#x3D; i;</span><br><span class="line">while (j--)</span><br><span class="line">&#123;</span><br><span class="line">if (arr[j - 1] &gt; arr[j])</span><br><span class="line">&#123;</span><br><span class="line">int temp &#x3D; arr[j - 1];</span><br><span class="line">arr[j - 1] &#x3D; arr[j];</span><br><span class="line">arr[j] &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">break;&#x2F;&#x2F;小于退出while循环提高效率</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int arr[] &#x3D; &#123;8,3,9,5,6,7,1,4,0,2&#125;;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">int len &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);</span><br><span class="line">InsertionSort(arr,len);</span><br><span class="line">for (i &#x3D; 0;i &lt; (sizeof(arr) &#x2F; sizeof(arr[0]));i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><h4 id="算法描述：-1"><a href="#算法描述：-1" class="headerlink" title="算法描述："></a>算法描述：</h4>又称<strong>缩小增量排序</strong></li><li>选择一个增量序列</li><li>每趟排序，根据对应的增量t，进行两两数据比较，将小的放在前，大的放在后</li><li>重复第二步，直到增量已用尽</li></ul><p><img src="/deng123-dev.github.io/images/pasted-35.png" alt="upload successful"><br>简单选择排序的基本思想：<code>比较+交换</code></p><h4 id="c语言实现：-1"><a href="#c语言实现：-1" class="headerlink" title="c语言实现："></a>c语言实现：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">void swap(int* L, int* R)</span><br><span class="line">&#123;</span><br><span class="line">int temp &#x3D; *L;</span><br><span class="line">*L &#x3D; *R;</span><br><span class="line">*R &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">void ShellSort(int* arr, int len)</span><br><span class="line">&#123;</span><br><span class="line">for (int gap &#x3D; (len &#x2F; 2); gap &gt; 0;gap &#x2F;&#x3D; 2)&#x2F;&#x2F;设置gap起始间距为长度的一半</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;以gap为间距组从一个组，每次对这个组进行直接插入排序</span><br><span class="line">for (int i &#x3D; gap; i &lt; len;i++)</span><br><span class="line">&#x2F;&#x2F;以gap位置为起始，找到每一个元素以gap间隔为组向前进行直接插入排序</span><br><span class="line">&#123;</span><br><span class="line">int j &#x3D; i;</span><br><span class="line">while ((arr[j]&lt; arr[j - gap]) &amp;&amp; j - gap &gt;&#x3D; 0)</span><br><span class="line">&#123;</span><br><span class="line">swap(&amp;arr[j],&amp;arr[j -gap]);</span><br><span class="line">j -&#x3D; gap;&#x2F;&#x2F;找到之前所有的成员比较并排序</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int arr[] &#x3D; &#123; 8,3,9,5,6,7,1,4,0,2 &#125;;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">int len &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);</span><br><span class="line">ShellSort(arr, len);</span><br><span class="line">for (i &#x3D; 0;i &lt; len;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="算法描述：-2"><a href="#算法描述：-2" class="headerlink" title="算法描述："></a>算法描述：</h4><ul><li>第一轮从头到尾对n个元素进行两两比较，进行调换位置</li><li>需要对余下的n-1个数据进行从头到尾两两比较直到数据有序为止</li></ul><p><img src="/deng123-dev.github.io/images/pasted-36.png" alt="upload successful"></p><h4 id="c语言实现：-2"><a href="#c语言实现：-2" class="headerlink" title="c语言实现："></a>c语言实现：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">void bubbleSort(int* arr,int len)</span><br><span class="line">&#123;</span><br><span class="line">int i, j;</span><br><span class="line">for (i &#x3D; 0;i &lt; len - 1;i++)</span><br><span class="line">&#123;</span><br><span class="line">for (j &#x3D; 0;j &lt; len - 1 - i;j++)</span><br><span class="line">&#123;</span><br><span class="line">if (arr[j] &gt; arr[j + 1])</span><br><span class="line">&#123;</span><br><span class="line">int temp &#x3D; arr[j];</span><br><span class="line">arr[j] &#x3D; arr[j + 1];</span><br><span class="line">arr[j + 1] &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int arr[] &#x3D; &#123;6,3,8,7,5,4,1,2,0&#125;;</span><br><span class="line">int len &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);</span><br><span class="line">bubbleSort(arr,len);</span><br><span class="line">for (i &#x3D; 0;i &lt; (sizeof(arr) &#x2F; sizeof(arr[0]));i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="算法描述：-3"><a href="#算法描述：-3" class="headerlink" title="算法描述："></a>算法描述：</h4><p><strong>实例排序：</strong></p><p><strong><em>一趟排序结果：{49 38 65 97 76 13 27 49’}</em></strong></p><p><strong><em>二趟排序结果：{27 38 13} 49 {76 97 65 49’}</em></strong></p><p><strong><em>三趟排序结果：{13} 27 {38} 49 {76 97 65 49’}</em></strong></p><p><strong><em>四趟排序结果：13 27 38 49 {49’ 65} 76 {97}</em></strong></p><ul><li>定义low和high指向头尾两个关键数据</li></ul><ul><li>将low所指数据与其后面数据进行比较，如果比其小就把它放在该数据的前面</li></ul><ul><li>将high所指数据与其后面数据进行比较，如果比其大就把它放在该数据的后面</li></ul><ul><li>当low和high指针所指数据重叠时，将数据分为两组，重新设置头尾数据为low和high，重复上述操作，直至数据有序</li></ul><p><img src="/deng123-dev.github.io/images/pasted-37.png" alt="upload successful"></p><h4 id="c语言实现：-3"><a href="#c语言实现：-3" class="headerlink" title="c语言实现："></a>c语言实现：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;assert.h&gt;</span><br><span class="line"> </span><br><span class="line">void QuickSort(int* arr,int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">int i &#x3D; left; </span><br><span class="line">int j &#x3D; right;</span><br><span class="line">int temp &#x3D; arr[i];</span><br><span class="line"> </span><br><span class="line">if (i &gt;&#x3D; j)</span><br><span class="line">return;</span><br><span class="line"> </span><br><span class="line">while (i !&#x3D; j)</span><br><span class="line">&#123;</span><br><span class="line">while (arr[j] &gt;&#x3D; temp &amp;&amp; i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">if (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] &#x3D; arr[j];</span><br><span class="line">&#125;</span><br><span class="line">while (arr[i] &lt;&#x3D; temp &amp;&amp; i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">if ( i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">arr[j] &#x3D; arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[i] &#x3D; temp;</span><br><span class="line">QuickSort(arr,left,i - 1);</span><br><span class="line">QuickSort(arr, i + 1, right);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int arr[] &#x3D; &#123;8,3,9,5,6,7,1,4,0,2&#125;;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">int len &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);</span><br><span class="line">QuickSort(arr,0,len - 1);</span><br><span class="line">for (i &#x3D; 0;i &lt; len ;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><h4 id="算法描述：-4"><a href="#算法描述：-4" class="headerlink" title="算法描述："></a>算法描述：</h4><ul><li>在第一个位置开始从数组找到最小的数据</li></ul><ul><li>往下一个位置开始找到数组中最小的数据 </li></ul><ul><li>重复第二步，直到数组有序为止</li></ul><p><img src="/deng123-dev.github.io/images/pasted-38.png" alt="upload successful"></p><h4 id="c语言实现：-4"><a href="#c语言实现：-4" class="headerlink" title="c语言实现："></a>c语言实现：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">void SelectionSort(int* arr, int len)</span><br><span class="line">&#123;</span><br><span class="line">int min;&#x2F;&#x2F;保存当前最小数字下标</span><br><span class="line">for (int i &#x3D; 0;i &lt; len - 1;i++)</span><br><span class="line">&#123;</span><br><span class="line">min &#x3D; i;</span><br><span class="line">for (int j &#x3D; i + 1;j &lt; len; j++)</span><br><span class="line">&#123;</span><br><span class="line">if (arr[min] &gt; arr[j])</span><br><span class="line">&#123;</span><br><span class="line">min &#x3D; j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int temp &#x3D; arr[min];</span><br><span class="line">arr[min] &#x3D; arr[i];</span><br><span class="line">arr[i] &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int arr[] &#x3D; &#123;8,3,9,5,6,7,1,4,0,2&#125;;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">int len &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);</span><br><span class="line">SelectionSort(arr,len);</span><br><span class="line">for (i &#x3D; 0;i &lt; len ;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="算法描述：-5"><a href="#算法描述：-5" class="headerlink" title="算法描述："></a>算法描述：</h4><p>堆就是用数组实现的二叉树，所以没有父指针或字指针</p><p>堆分为两种：<strong>最大堆</strong> 和<strong>最小堆</strong></p><p>两者区别：</p><p>节点的值比每一个子节点的值都要大</p><p>节点的值比每一个子节点的值都要小</p><p>鉴于最大堆和最小堆是对称关系，理解其中一种即可。所以接下来我们为你们说明一下最大堆的排序</p><p>最大堆进行升序排序的思想：<br>1.<br>初始化堆：将数列a[1..n]构成最大堆</p><p>2.<br>交换数据：将a[1]和a[n] 交换，使a[n]是a[1…n]中的最大值；然后将a[1…n-1]重新调整为最大堆。 接着，将a[1]和a[n-1]交换，使a[n-1]是a[1…n-1]中的最大值；然后将a[1…n-2]重新调整为最大值。 依次类推，直到整个数列都是有序的。</p><h4 id="c语言实现：-5"><a href="#c语言实现：-5" class="headerlink" title="c语言实现："></a>c语言实现：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;assert.h&gt;</span><br><span class="line">void AdjustHead(int *arr, int parent, int len)</span><br><span class="line">&#123;&#x2F;&#x2F;大堆</span><br><span class="line">assert(arr);</span><br><span class="line">int child &#x3D; parent * 2 + 1;</span><br><span class="line">while (child &lt; len)</span><br><span class="line">&#123;</span><br><span class="line">if (arr[child] &lt; arr[child + 1] &amp;&amp; child + 1 &lt; len)</span><br><span class="line">&#123;</span><br><span class="line">child +&#x3D; 1;&#x2F;&#x2F;左子树小于右子树交且合法时交换</span><br><span class="line">&#125;</span><br><span class="line">if (arr[child] &gt; arr[parent])</span><br><span class="line">&#123;&#x2F;&#x2F;将大值交给父亲节点</span><br><span class="line">int temp &#x3D; arr[child];</span><br><span class="line">arr[child] &#x3D; arr[parent];</span><br><span class="line">arr[parent] &#x3D; temp;</span><br><span class="line">&#x2F;&#x2F;复位，再次判断，防止左右孩子都大于双亲</span><br><span class="line">parent &#x3D; child;</span><br><span class="line">child &#x3D; parent * 2 + 1;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">return;&#x2F;&#x2F;不满足退出</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void HeapSort(int* arr, int len)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;建堆</span><br><span class="line">int root &#x3D; (len - 2) &gt;&gt; 1;&#x2F;&#x2F;找到最后一个非叶子节点</span><br><span class="line">for (root;root &gt;&#x3D; 0;--root)</span><br><span class="line">&#123;</span><br><span class="line">AdjustHead(arr, root, len);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;排序</span><br><span class="line">int end &#x3D; len - 1;</span><br><span class="line">while (end)</span><br><span class="line">&#123;</span><br><span class="line">int temp &#x3D; arr[0];</span><br><span class="line">arr[0] &#x3D; arr[end];</span><br><span class="line">arr[end] &#x3D; temp;</span><br><span class="line">&#x2F;&#x2F;循环排序每一个元素</span><br><span class="line">AdjustHead(arr,0,end);</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int arr[] &#x3D; &#123;8,3,9,5,6,7,1,4,0,2&#125;;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">int len &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);</span><br><span class="line">HeapSort(arr,len);</span><br><span class="line">for (i &#x3D; 0;i &lt; len ;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="算法描述：-6"><a href="#算法描述：-6" class="headerlink" title="算法描述："></a>算法描述：</h4><ul><li>将长度为n的输入序列分为长度为n/2的子序列</li><li>对两个子序列分别采用归并排序</li><li>将两个排序号的子序列合并成一个最终的排序序列</li></ul><p><img src="/deng123-dev.github.io/images/pasted-39.png" alt="upload successful"></p><h4 id="c语言实现：-6"><a href="#c语言实现：-6" class="headerlink" title="c语言实现："></a>c语言实现：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;assert.h&gt;</span><br><span class="line">&#x2F;&#x2F;合并</span><br><span class="line">void Merge(int* arr, int low, int mid, int high)</span><br><span class="line">&#123;</span><br><span class="line">int i &#x3D; low;&#x2F;&#x2F;第一组下标</span><br><span class="line">int j &#x3D; mid + 1;&#x2F;&#x2F;第二组下标</span><br><span class="line">int k &#x3D; 0;</span><br><span class="line">int arr2[100] &#x3D; &#123;0&#125;;&#x2F;&#x2F;临时排序存放序列</span><br><span class="line">&#x2F;&#x2F;循环判断arr[i]和arr[j]的值，谁小谁放在arr2中</span><br><span class="line">while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; high)</span><br><span class="line">&#123;</span><br><span class="line">if (arr[i] &lt;&#x3D; arr[j])</span><br><span class="line">&#123;</span><br><span class="line">arr2[k] &#x3D; arr[i];</span><br><span class="line">i++;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">arr2[k] &#x3D; arr[j];</span><br><span class="line">j++;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;当至少一组放完后，剩下的全部按顺序放入arr2（已经有序的数组）</span><br><span class="line">&#x2F;&#x2F;最后一组元素可能不过正常数量</span><br><span class="line">    while (i &lt;&#x3D; mid)</span><br><span class="line">&#123;</span><br><span class="line">arr2[k] &#x3D; arr[i];</span><br><span class="line">i++;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">while (j &lt;&#x3D; high)</span><br><span class="line">&#123;</span><br><span class="line">arr2[k] &#x3D; arr[j];</span><br><span class="line">j++;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;将arr2中的序列复制到arr中</span><br><span class="line">for (k &#x3D; 0, i &#x3D; low;i &lt;&#x3D; high;i++, k++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] &#x3D; arr2[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void MergeSort(int *arr, int len)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;间隔增加（gap就是一组几个元素）</span><br><span class="line">for( int gap &#x3D; 1;gap &lt; len;gap &#x3D; (gap * 2) )</span><br><span class="line">&#123;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;从间隔gap开始排序</span><br><span class="line">for (i &#x3D; 0;i + 2*gap - 1 &lt; len;i &#x3D; i + 2*gap)</span><br><span class="line">&#123;</span><br><span class="line">Merge(arr, i , i + gap - 1 , i + 2*gap - 1 );</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;当gap大于len的一半时，排序for无法排序的两个子组</span><br><span class="line">if (i + gap - 1 &lt; len) </span><br><span class="line">&#123;</span><br><span class="line">Merge(arr, i, i + gap - 1, len - 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int arr[] &#x3D; &#123;8,3,9,5,6,7,1,4,0,2&#125;;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">int len &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);</span><br><span class="line">MergeSort(arr,len );</span><br><span class="line">for (i &#x3D; 0;i &lt; len;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
