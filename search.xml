<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode知识总结（2）</title>
      <link href="/deng123-dev.github.io/2020/07/26/leetcode%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%882%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/07/26/leetcode%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="删除最外层的括号"><a href="#删除最外层的括号" class="headerlink" title="删除最外层的括号"></a>删除最外层的括号</h1><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-178.png" alt="upload successful"></p><a id="more"></a><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class solution&#123;</span><br><span class="line">  public String removeOuterParentheses(String S) &#123;</span><br><span class="line">  StringBuilder s&#x3D;new StringBuilder ();</span><br><span class="line">  int level&#x3D;0;</span><br><span class="line">  for(char c:S.toCharArray())&#123;</span><br><span class="line">  if(c&#x3D;&#x3D;&#39;)&#39;)  --level;</span><br><span class="line">  if(level&gt;0) s.append(c);</span><br><span class="line">  if(c&#x3D;&#x3D;&#39;(&#39;)  ++level;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识"><a href="#解题思路和知识" class="headerlink" title="解题思路和知识"></a>解题思路和知识</h2><hr><ul><li><p>解题思路</p><p>代码的主要思想是先建立一个可变字符序列，设置一个层次变量表示这是内嵌第几层（level=0表示是最外层的括号）的括号，字符串中的每个字符都要经历判断，如果是外层的括号（即是题目指的原语的最外层括号），则不输入进入字符序列</p></li><li><p>知识总结</p><p>StringBuilder和StringBuffer是String类的同伴类。它们表示一个可变的字符序列。   StringBuffer是线程安全的，StringBuilder不是线程安全的。</p></li></ul><h1 id="删除字符串的所有相邻重复项"><a href="#删除字符串的所有相邻重复项" class="headerlink" title="删除字符串的所有相邻重复项"></a>删除字符串的所有相邻重复项</h1><hr><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-179.png" alt="upload successful"></p><h2 id="编写代码-1"><a href="#编写代码-1" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String removeDuplicates(String S) &#123;</span><br><span class="line">    Stack&lt;Character&gt; s&#x3D;new Stack&lt;Character&gt;();   </span><br><span class="line">    for(char c:S.toCharArray())&#123;</span><br><span class="line"></span><br><span class="line">        if(s.isEmpty()||c!&#x3D;s.peek()) </span><br><span class="line">         s.push(c);               </span><br><span class="line">        else s.pop();              </span><br><span class="line">                             </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   StringBuilder a&#x3D;new StringBuilder();</span><br><span class="line">   for(char c:s)&#123;</span><br><span class="line">    a.append(c);</span><br><span class="line">   &#125;</span><br><span class="line">   return a.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识-1"><a href="#解题思路和知识-1" class="headerlink" title="解题思路和知识"></a>解题思路和知识</h2><hr><ul><li><p>解题思路</p><p> 这题很简单，建立一个栈，将数据存进去，如果存入数据与栈顶元素相同，则将栈顶元素出栈，反之则将数据进栈，最后输出即可</p></li></ul><h1 id="用栈操作构建数组"><a href="#用栈操作构建数组" class="headerlink" title="用栈操作构建数组"></a>用栈操作构建数组</h1><hr><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-180.png" alt="upload successful"></p><h2 id="编写代码-2"><a href="#编写代码-2" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; buildArray(int[] target, int n) &#123;</span><br><span class="line">     List&lt;String&gt; list &#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">     for(int i&#x3D;1,j&#x3D;0;i&lt;&#x3D;n &amp;&amp; j&lt; target.length;i++) &#123;      </span><br><span class="line">     if(i&lt;target[j])&#123;</span><br><span class="line">      list.add(&quot;Push&quot;);</span><br><span class="line">      list.add(&quot;Pop&quot;); </span><br><span class="line">     &#125;</span><br><span class="line">    else if(i&#x3D;&#x3D;target[j])&#123;</span><br><span class="line">        list.add(&quot;Push&quot;);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;                                          </span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识-2"><a href="#解题思路和知识-2" class="headerlink" title="解题思路和知识"></a>解题思路和知识</h2><hr><ul><li>解题思路 </li></ul><p>我没有使用栈对这道题进行求解，遍历目标数组，如果目标数组的数值大于i时，向list<br>对象中添加“push”和“pop”，当i等于目标数组数值时，向list对象中添加“push”（i表示的是每次循环list读取的数字）</p><ul><li><p>相关知识</p><ul><li><p>创建线性表操作</p><p>List<String> list =new ArrayList&lt;&gt;();</p></li><li><p>往线性表中添加元素</p><p>list.add()</p></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 知识总结（1）</title>
      <link href="/deng123-dev.github.io/2020/07/06/leetcode-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%881%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/07/06/leetcode-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h1><p><strong><em>tags: 栈</em></strong></p><hr><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-151.png" alt="upload successful"></p><a id="more"></a><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><hr><ul><li><p>JAVA: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">     Stack&lt;Character&gt;stack&#x3D;new Stack&lt;Character&gt;();</span><br><span class="line">    for(char c:s.toCharArray())&#123;</span><br><span class="line">    if(c&#x3D;&#x3D;&#39;(&#39;) stack.push(&#39;)&#39;);</span><br><span class="line">    else if (c&#x3D;&#x3D;&#39;[&#39;) stack.push(&#39;]&#39;);</span><br><span class="line">    else if (c&#x3D;&#x3D;&#39;&#123;&#39;) stack.push(&#39;&#125;&#39;);</span><br><span class="line">    else if (stack.isEmpty()|| c!&#x3D;stack.pop()) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路和知识总结"><a href="#解题思路和知识总结" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><ul><li>解题思路</li></ul><p><img src="/deng123-dev.github.io/images/pasted-147.png" alt="upload successful"></p><p>  主要利用栈先进后出的特点，当出现一个括号的前半部时，将其后半部分存储到栈中，<br>  通过条件判断,前半部分括号输出对应的后半部分括号</p><p>   <code>stack.isEmpty()</code> <strong>用于判断当例如”()]]”类似的情况</strong></p><p>   <code>c!=stack.pop())</code>用于判断栈中存储的前半部分括号对应后半部分括号是否和字符串的后半部分括号相同，并且还要将栈顶元素移出栈</p><ul><li><p>知识总结</p><ul><li><p><code>for(char c:s.toCharArray())</code>把char类型的s元素赋值给c，再执行循环</p></li><li><p><code>toCharArray()</code>toCharArray() 方法将字符串转换为字符数组。</p></li></ul></li></ul><h1 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h1><p><strong><em>tags: 栈</em></strong></p><hr><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-149.png" alt="upload successful"></p><h2 id="编写代码-1"><a href="#编写代码-1" class="headerlink" title="编写代码"></a>编写代码</h2><hr><p>JAVA代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Minstack&#123;</span><br><span class="line">private Stack&lt;Integer&gt; datastack;</span><br><span class="line">private Stack&lt;Integer&gt; minstack;</span><br><span class="line"></span><br><span class="line">public Minstack()&#123;</span><br><span class="line">datastack&#x3D;new Stack&lt;&gt;();</span><br><span class="line">minstack&#x3D;new Stack&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void push(int x)&#123;</span><br><span class="line">datastack.push(x);</span><br><span class="line">if(minstack.isEmpty()||x&lt;&#x3D;minstack().peek())</span><br><span class="line">minstack.push(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void pop()&#123;</span><br><span class="line">int x&#x3D;datastack.peek();</span><br><span class="line">if(x&#x3D;&#x3D;minstack.peek())</span><br><span class="line">minstack.pop();</span><br><span class="line">datastack.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public getmin()&#123;</span><br><span class="line"></span><br><span class="line">return minstack.peek();</span><br><span class="line">&#125;</span><br><span class="line">public gettop()&#123;</span><br><span class="line"></span><br><span class="line">return datastack.peek();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结-1"><a href="#解题思路和知识总结-1" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><ul><li><p>解题思路 </p><ul><li><p>出栈操作： 如果数据栈当中的值等于最小栈栈顶值时（即判断当前数据栈出栈元素是否时最小值时），就把最小栈的栈顶元素出栈，然后再把数据栈的栈顶元素出栈。</p></li><li><p>入栈操作：先把元素放入数据栈，再将元素和最小栈的栈顶元素作比较，如果元素小于或等于栈顶元素，则入栈。</p></li><li><p>取最小元素：直接取最小站栈顶元素即可</p></li></ul></li></ul><p><img src="/deng123-dev.github.io/images/pasted-150.png" alt="upload successful"></p><p>在我的角度看来是一个<strong>空间换时间</strong>的算法，因为如果用stack里面的查找最小值的方法需要将栈从头到尾进行比较，这样增大了计算量，而最小栈的思想是在原有的数据栈之外建立一个新的最小栈，它的栈顶存放数据栈的最小的元素，当有元素出栈或者入栈的时候只需要和最小栈的栈顶元素作比较；</p><ul><li><p>知识总结（栈的基本操作）</p><ul><li><p>创建栈：private Stack<Integer> datastack;</p></li><li><p>入栈操作：push</p></li><li><p>出栈操作：pop</p></li><li><p>判断栈空：isEmpty</p></li><li><p>取栈顶：peek</p></li></ul></li></ul><h1 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h1><p><strong><em>tags:栈</em></strong></p><hr><h2 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-152.png" alt="upload successful"></p><h2 id="编写代码-2"><a href="#编写代码-2" class="headerlink" title="编写代码"></a>编写代码</h2><hr><p>JAVA代码</p><p>第一种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class MyStack</span><br><span class="line">&#123;</span><br><span class="line">private Queue &lt;Integer&gt; a;</span><br><span class="line">private Queue &lt;Integer&gt; b;</span><br><span class="line">private int top;</span><br><span class="line">public MyStack()&#123;</span><br><span class="line">a&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">b&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public  void push()&#123;</span><br><span class="line">a.offer(x);</span><br><span class="line">top&#x3D;x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int pop()&#123;</span><br><span class="line">while(a.size()&gt;1)</span><br><span class="line">b.offer(a.poll());</span><br><span class="line">int t&#x3D;a.peek();</span><br><span class="line">a.poll();</span><br><span class="line">Queue tmp&#x3D;a;</span><br><span class="line">a&#x3D;b;</span><br><span class="line">b&#x3D;tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void gettop()&#123;</span><br><span class="line">return top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void empty()&#123;</span><br><span class="line">return a.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结-2"><a href="#解题思路和知识总结-2" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-153.png" alt="upload successful"></p><ul><li><p>解题思路</p><p> 创建两个队列，一个数据队列，一个临时队列，数据入栈时直接让它进入数据栈，出队时模拟出栈的功能，具体做法是：创建一个循环，使数据队列的元素出队进入到临时队列，直到只剩下最后一个元素（也即是对应的栈顶元素），让其出队，最后将队列a的数据和队列b的数据交换。</p></li><li><p>知识总结</p><ul><li><p>创建队列： Queue<String> q = new LinkedList<String>() </p></li><li><p>添加元素：offer</p></li><li><p>返回第1个元素并将它删除：poll</p></li><li><p>返回第一个元素：peek</p></li></ul></li></ul><h1 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h1><p><strong><em>tags:栈</em></strong></p><hr><h2 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-154.png" alt="upload successful"></p><h2 id="编写代码-3"><a href="#编写代码-3" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class MyQueue &#123;</span><br><span class="line">    private Stack&lt;Integer&gt; a;&#x2F;&#x2F;数据栈</span><br><span class="line">    private Stack&lt;Integer&gt; b;&#x2F;&#x2F;临时栈</span><br><span class="line">    &#x2F;** Initialize your data structure here. *&#x2F;</span><br><span class="line">    public MyQueue() &#123;</span><br><span class="line">    a&#x3D;new Stack&lt;&gt;();</span><br><span class="line">    b&#x3D;new Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** 初始化你的数据结构 *&#x2F;</span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">    while(!a.isEmpty())</span><br><span class="line">    b.push(a.pop());</span><br><span class="line">    a.push(x);</span><br><span class="line">    while(!b.isEmpty())</span><br><span class="line">    a.push(b.pop());</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**从队头删除元素并返回该元素*&#x2F;</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">    return  a.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** 返回头元素 *&#x2F;</span><br><span class="line">    public int peek() &#123;</span><br><span class="line">     return a.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** 判断队列是否为空 *&#x2F;</span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">    return a.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总计"><a href="#解题思路和知识总计" class="headerlink" title="解题思路和知识总计"></a>解题思路和知识总计</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-155.png" alt="upload successful"></p><p>初始化两个栈，一个栈作为数据栈，一个作为临时栈，设计算法，先将数据栈的元素放入临时栈，再将元素压入临时栈，再把临时栈的数据压入数据栈，这样的压栈的操作就能使的原来先进后出的元素先进先出了</p><h1 id="下一个更大元素"><a href="#下一个更大元素" class="headerlink" title="下一个更大元素"></a>下一个更大元素</h1><p><strong><em>tag:栈</em></strong></p><hr><h2 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-161.png" alt="upload successful"></p><h2 id="编写代码-4"><a href="#编写代码-4" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">public int[] nextGreaterElement(int[] nums1,int[] nums2)&#123;</span><br><span class="line">Stack&lt;Integer&gt; stack &#x3D;new Stack&lt;Integer&gt;();</span><br><span class="line">HashMap&lt;Integer&gt; hash&#x3D;new HashMap&lt;Integer&gt;();</span><br><span class="line">int []&#x3D;new int[nums1.length];</span><br><span class="line">for(num:nums2)&#123;</span><br><span class="line">if(!stack.isEmpty()&amp;&amp;num&gt;stack.peek())</span><br><span class="line">hash.put(stack.pop(),num);</span><br><span class="line">stack.push(num);</span><br><span class="line">&#125;</span><br><span class="line">for(int i&#x3D;0;i&lt;nums1.length;i++)</span><br><span class="line">result[i]&#x3D;hash.getOrDeault(nums1[i],-1);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总计-1"><a href="#解题思路和知识总计-1" class="headerlink" title="解题思路和知识总计"></a>解题思路和知识总计</h2><hr><ul><li><p>解题思路</p><ol><li>先遍历大数组nums2，首先将第一个元素入栈；</li><li>继续遍历，当当前元素小于栈顶元素时，继续将它入栈；当当前元素大于栈  顶元素时，栈顶元素出栈，此时应将该出栈的元素与当前元素形成key-value键值对，存入HashMap中；</li><li>当遍历完nums2后，得到nums2中元素所对应的下一个更大元素的hash表；</li><li>遍历nums1的元素在hashMap中去查找‘下一个更大元素’，当找不到时则为-1。</li></ol></li><li><p>知识总结</p><ul><li><p>创建hash表</p><p>HashMap<Integer> hash=new HashMap<Integer>();</p></li><li><p>hash的put方法</p><p> hash（key，value）</p></li><li><p>hash获取默认值的方法</p><p>hash.getOrDeault(key,默认值)</p></li></ul></li></ul><h1 id="棒球比赛"><a href="#棒球比赛" class="headerlink" title="棒球比赛"></a>棒球比赛</h1><p><strong><em>tags:栈</em></strong></p><hr><h2 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-164.png" alt="upload successful"></p><h2 id="编写代码-5"><a href="#编写代码-5" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int calPoints(String[] ops) &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack&#x3D;new Stack();</span><br><span class="line">    int sum&#x3D;0;</span><br><span class="line">    for(String c:ops)&#123;</span><br><span class="line">      if(c.equals(&quot;D&quot;)&amp;&amp;!stack.isEmpty()) &#123;</span><br><span class="line">      stack.push(stack.peek()*2);              </span><br><span class="line">     sum+&#x3D;stack.peek();                          </span><br><span class="line">      &#125;  </span><br><span class="line">     else if(c.equals(&quot;C&quot;)&amp;&amp;!stack.isEmpty())&#123;</span><br><span class="line">      sum-&#x3D;stack.peek();</span><br><span class="line">      stack.pop();</span><br><span class="line">      &#125;    </span><br><span class="line">     else if(c.equals(&quot;+&quot;)&amp;&amp;!stack.isEmpty())&#123;</span><br><span class="line">        int top&#x3D;stack.pop();</span><br><span class="line">        int newtop&#x3D;top+stack.peek();</span><br><span class="line">        stack.push(top);</span><br><span class="line">        stack.push(newtop);</span><br><span class="line">        sum+&#x3D;stack.peek();</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">          stack.push(Integer.valueOf(c));  </span><br><span class="line">          sum+&#x3D;Integer.valueOf(c);         </span><br><span class="line">       &#125;                                      </span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总计-2"><a href="#解题思路和知识总计-2" class="headerlink" title="解题思路和知识总计"></a>解题思路和知识总计</h2><hr><ul><li>解题思路</li></ul><p>将每一轮得分存入栈中，因为里面每一轮的操作都是永久性的，可能会对前一轮和后一轮产生影响。所以栈这种数据结构最适合，将每一轮的得分压入栈中，当需要对其他数据进行操作时取出来</p><ul><li><p>知识总结</p><ul><li><p>变量.equals(值)</p><p> 用于单纯的值相等，“==”对对象而言是看是否指向同一个引用</p></li><li><p>Integer valueOf(int i)：返回一个表示指定的 int 值的 Integer 实例。</p></li><li><p>Integer valueOf(String s):返回保存指定的 String 的值的 Integer 对象。</p></li><li><p>Integer valueOf(String s, int radix): 返回一个 Integer 对象，该对象中保存了用第二个参数提供的基数进行解析时从指定的 String 中提取的值。</p></li></ul></li></ul><h1 id="比较含退格符的字符串"><a href="#比较含退格符的字符串" class="headerlink" title="比较含退格符的字符串"></a>比较含退格符的字符串</h1><p><strong><em>tags:栈</em></strong></p><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-177.png" alt="upload successful"></p><h2 id="编写代码-6"><a href="#编写代码-6" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean backspaceCompare(String S, String T) &#123;</span><br><span class="line">        return build(S).equals(build(T));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String build(String S) &#123;</span><br><span class="line">        Stack&lt;Character&gt; ans &#x3D; new Stack();</span><br><span class="line">        for (char c: S.toCharArray()) &#123;</span><br><span class="line">            if (c !&#x3D; &#39;#&#39;)</span><br><span class="line">                ans.push(c);</span><br><span class="line">            else if (!ans.empty())</span><br><span class="line">                ans.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return String.valueOf(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结-3"><a href="#解题思路和知识总结-3" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><ul><li><p>解题思路</p><p> 创建一个build方法，它可以使字符输入到栈，当遇到退格符时则将栈顶元素输出， 最后比较两个栈是否相等即可</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>springboot（4）</title>
      <link href="/deng123-dev.github.io/2020/06/04/springboot%EF%BC%884%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/06/04/springboot%EF%BC%884%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是JSP"><a href="#什么是JSP" class="headerlink" title="什么是JSP"></a>什么是JSP</h1><p>视图层技术</p><p>JSP全称Java Server Pages，是一种动态网页开发技术，JAVA+html的复合体。它使用JSP标签在HTML网页中插入Java代码。标签通常以&lt;%开头以%&gt;结束。</p><p>JSP是一种Java servlet，主要用于实现Java web应用程序的用户界面部分。网页开发者们通过结合HTML代码、XHTML代码、XML元素以及嵌入JSP操作和命令来编写JSP。</p><p>JSP通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页。</p><a id="more"></a><hr><h1 id="springboot整合Thymeleaf"><a href="#springboot整合Thymeleaf" class="headerlink" title="springboot整合Thymeleaf"></a>springboot整合Thymeleaf</h1><hr><h2 id="Thymeleaf介绍"><a href="#Thymeleaf介绍" class="headerlink" title="Thymeleaf介绍"></a>Thymeleaf介绍</h2><p>简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP，通常后端程序员要根据前端程序员做出的页面进行具体业务的实现，因为JSP和html不能直接复用，如果用JSP作为视图技术，那么对于html页面的内容难复用，但是Thymeleaf能够对html数据渲染。</p><p>Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。<strong>这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。</strong></p><p>注意：</p><ul><li><p>Thymeleaf适合做单体应用</p></li><li><p>Thymeleaf不适合做基于服务的，分布式，前后端分离，那就无法体现其特点</p></li></ul><hr><h2 id="Thymeleaf基本使用"><a href="#Thymeleaf基本使用" class="headerlink" title="Thymeleaf基本使用"></a>Thymeleaf基本使用</h2><ol><li>修改pom文件</li></ol><p><img src="/deng123-dev.github.io/images/pasted-129.png" alt="upload successful"></p><ol start="2"><li>创建页面跳转的controller类 </li></ol><p><strong>注意：因为templates比static安全性更高。所以不能通过url直接访问templates中的文件,所以要做一个页面跳转类实现页面跳转</strong></p><p><img src="/deng123-dev.github.io/images/pasted-130.png" alt="upload successful"></p><ol start="3"><li>创建视图</li></ol><p><img src="/deng123-dev.github.io/images/pasted-131.png" alt="upload successful"></p><ol start="4"><li>测试结果</li></ol><p><img src="/deng123-dev.github.io/images/pasted-132.png" alt="upload successful"></p><hr><h2 id="Thymeleaf迭代遍历-th-each"><a href="#Thymeleaf迭代遍历-th-each" class="headerlink" title="Thymeleaf迭代遍历:th:each"></a>Thymeleaf迭代遍历:th:each</h2><p>th:each:用于循环迭代集合</p><ol><li>创建一个user实体类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-133.png" alt="upload successful"></p><ol start="2"><li>配置pagecontroller类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-134.png" alt="upload successful"></p><ol start="3"><li>创建视图层</li></ol><p><img src="/deng123-dev.github.io/images/pasted-138.png" alt="upload successful"></p><p><strong><em>关键在于这里的th:each 迭代了list中的内容来创建表格</em></strong></p><ol start="4"><li>测试结果</li></ol><p><img src="/deng123-dev.github.io/images/pasted-135.png" alt="upload successful"></p><hr><h2 id="th-each状态变量"><a href="#th-each状态变量" class="headerlink" title="th:each状态变量"></a>th:each状态变量</h2><table><thead><tr><th>状态变量</th><th>对应解释</th></tr></thead><tbody><tr><td>index</td><td>当前迭代器的索引，从0开始</td></tr><tr><td>count</td><td>当前迭代对象的计数，从1开始</td></tr><tr><td>size</td><td>迭代对象长度</td></tr><tr><td>odd/even</td><td>布尔值，当前循环是否为偶数/奇数 从0开始</td></tr><tr><td>first</td><td>布尔值，判断当前循环是否是第一条</td></tr><tr><td>last</td><td>布尔值，判断当前循环是否是最后一条</td></tr></tbody></table><ol><li>创建视图层</li></ol><p><img src="/deng123-dev.github.io/images/pasted-139.png" alt="upload successful"></p><p><strong>注意一下状态变量的语法结构（在图中已用红圈划出来）</strong></p><ol start="2"><li>测试结果</li></ol><p><img src="/deng123-dev.github.io/images/pasted-140.png" alt="upload successful"></p><hr><h2 id="th-each迭代Map"><a href="#th-each迭代Map" class="headerlink" title="th:each迭代Map"></a>th:each迭代Map</h2><ol><li>配置PageController类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-141.png" alt="upload successful"></p><ol start="2"><li>创建视图层</li></ol><p><img src="/deng123-dev.github.io/images/pasted-142.png" alt="upload successful"></p><ol start="3"><li>测试结果</li></ol><p><img src="/deng123-dev.github.io/images/pasted-143.png" alt="upload successful"></p><p><strong><em>这里的是以键值对（key-value）出现</em></strong></p><p><strong><em>不过上述是无法访问到user当中的属性，如果需要访问属性，则需要修改视图层的代码</em></strong></p><ol><li>创建视图层</li></ol><p><img src="/deng123-dev.github.io/images/pasted-145.png" alt="upload successful"></p><p><strong><em>请注意map有两个属性，key和value，key取的是上方测试结果中等号左侧部分，value取的是右侧部分，也只有value才能引出user当中的属性</em></strong></p><ol start="2"><li>测试结果</li></ol><p><img src="/deng123-dev.github.io/images/pasted-146.png" alt="upload successful"></p><hr><h2 id="Thymeleaf的URL表达式"><a href="#Thymeleaf的URL表达式" class="headerlink" title="Thymeleaf的URL表达式"></a>Thymeleaf的URL表达式</h2><ol><li>语法格式</li></ol><p>Thymeleaf中URL表达式的语法格式为@{}</p><ol start="2"><li><p>URL类型</p><ul><li><p>绝对路径<br><code>&lt;a th:href=&quot;@{网站的URL}&quot;&gt;网站名称&lt;a/&gt;</code></p></li><li><p>相对路径</p><ul><li>相对于当前项目的根</li></ul><p><code>&lt;a th:href=&quot;@{/项目的根}&quot;&gt;根名称&lt;a/&gt;</code></p><ul><li>相对于服务器路径的根 </li></ul><p><code>&lt;a th:href=&quot;@{~/项目名称/项目下访问的资源}&quot;&gt;相对于服务器的根路径&lt;a/&gt;</code></p></li></ul></li></ol><h2 id="在URL中传递参数"><a href="#在URL中传递参数" class="headerlink" title="在URL中传递参数"></a>在URL中传递参数</h2><ol><li><p>在普通格式的URL中传递参数</p><ul><li>第一种传参方法</li></ul><p><code>&lt;a th:href=&quot;@{/show?id=1&amp;name=admin}&quot;&gt;名称&lt;a/&gt;</code></p><ul><li>第二种传参方法</li></ul><p><code>&lt;a th:href=&quot;@{/show(id=1&amp;name=admin)}&quot;&gt;名称&lt;a/&gt;</code></p><ul><li>第三种传参方式</li></ul><p><code>&lt;a th:href=&quot;@{&#39;/show?id=&#39;${id}+&#39;&amp;name=&#39;+${name})&quot;&gt;名称&lt;a/&gt;</code></p><p><strong><em>这种方式需要在PageController中添加属性,然后将值传给它</em></strong></p><ul><li>第四种传参方式</li></ul><p><code>&lt;a th:href=&quot;@{/show(id=${id}&amp;name=${name}})&quot;&gt;名称&lt;a/&gt;</code></p><p> <strong><em>这种方式需要在PageController中添加属性</em></strong></p></li><li><p>restful 格式的URL中传递参数</p><ul><li><p>第一种传参方式</p><p><code>&lt;a th:href=&quot;@{/show/{id}(id=1)}&quot;&gt;名称&lt;a/&gt;</code> </p></li><li><p>第二种传参方式</p><p><code>&lt;a th:href=&quot;@{/show/{id}/{name}(id=1，name=admin)}&quot;&gt;名称&lt;a/&gt;</code> </p></li><li><p>第三种传参方式</p><p><code>&lt;a th:href=&quot;@{/show/{id}(id=1，name=admin)}&quot;&gt;名称&lt;a/&gt;</code> </p></li><li><p>第四种传参方式</p><p><code>&lt;a th:href=&quot;@{/show/{id}(id=${id}，name=${name})}&quot;&gt;名称&lt;a/&gt;</code> </p><p>  <strong><em>这种方式需要在PageController中添加属性,然后将值传给它</em></strong></p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot（3）</title>
      <link href="/deng123-dev.github.io/2020/05/31/springboot%EF%BC%883%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/05/31/springboot%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="springboot访问静态资源"><a href="#springboot访问静态资源" class="headerlink" title="springboot访问静态资源"></a>springboot访问静态资源</h1><p><img src="/deng123-dev.github.io/images/pasted-115.png" alt="upload successful"></p><a id="more"></a><ul><li><p>springboot默认在static下存放静态页面，存放静态资源的目录名称必须是static</p></li><li><p>springboot默认在templates下存放动态页面，springboot中不推荐使用JSP作为视图层技术，默认使用Thymeleaf来做动态页面</p></li></ul><hr><h2 id="创建并访问一个静态资源"><a href="#创建并访问一个静态资源" class="headerlink" title="创建并访问一个静态资源"></a>创建并访问一个静态资源</h2><ol><li>创建一个静态文件</li></ol><p><img src="/deng123-dev.github.io/images/pasted-116.png" alt="upload successful"></p><ol start="2"><li>测试结果</li></ol><p><img src="/deng123-dev.github.io/images/pasted-117.png" alt="upload successful"></p><hr><h2 id="静态资源存放其他位置"><a href="#静态资源存放其他位置" class="headerlink" title="静态资源存放其他位置"></a>静态资源存放其他位置</h2><hr><h3 id="springboot-访问静态资源的位置"><a href="#springboot-访问静态资源的位置" class="headerlink" title="springboot 访问静态资源的位置"></a>springboot 访问静态资源的位置</h3><p>classpath:/META-INF/resources/</p><p>classpath:/resources/</p><p>classpath:/static/</p><p>classpath:/public/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">其中的classpath均是指main目录下的resources目录</span><br><span class="line">不过除开默认访问位置，也可以自定义访问位置</span><br></pre></td></tr></table></figure><hr><h3 id="自定义静态文件访问位置"><a href="#自定义静态文件访问位置" class="headerlink" title="自定义静态文件访问位置"></a>自定义静态文件访问位置</h3><p>步骤：</p><ul><li><p>访问application.properties</p></li><li><p>“spring.resources.static-locations=”后面加上所访问文件的位置，如果需要指定多个位置，则用“，”隔开</p></li></ul><p><img src="/deng123-dev.github.io/images/pasted-118.png" alt="upload successful"></p><p><strong><em>请注意：<br>如果自定义了静态资源的默认访问位置，原有的默认访问位置就会失效</em></strong></p><hr><h1 id="springboot-文件上传"><a href="#springboot-文件上传" class="headerlink" title="springboot 文件上传"></a>springboot 文件上传</h1><hr><h2 id="创建一个文件上传页面"><a href="#创建一个文件上传页面" class="headerlink" title="创建一个文件上传页面"></a>创建一个文件上传页面</h2><p><img src="/deng123-dev.github.io/images/pasted-119.png" alt="upload successful"></p><p>步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">· main目录中的static目录中创建一个html文件</span><br><span class="line">· 用html标记语言攥写网页</span><br></pre></td></tr></table></figure><p>html标记语言</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form  action&#x3D;&quot;&#x2F;fileUploadController&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot;&#x2F;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;OK&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>测试结果</p><p><img src="/deng123-dev.github.io/images/pasted-120.png" alt="upload successful"></p><h2 id="文件上传（编写controller类）"><a href="#文件上传（编写controller类）" class="headerlink" title="文件上传（编写controller类）"></a>文件上传（编写controller类）</h2><h3 id="上传文件的具体方法"><a href="#上传文件的具体方法" class="headerlink" title="上传文件的具体方法"></a>上传文件的具体方法</h3><p><img src="/deng123-dev.github.io/images/pasted-121.png" alt="upload successful"></p><ol><li>controller代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.project1.springboot.demo.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 文件上传</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RestController</span><br><span class="line">public class FileUploadController &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 文件上传</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @PostMapping(&quot;&#x2F;fileUploadController&quot;)</span><br><span class="line">    public String FileUpload(MultipartFile file)throws Exception &#123;</span><br><span class="line">        System.out.println(file.getOriginalFilename());</span><br><span class="line">        file.transferTo(new File(&quot;E:&#x2F;&quot;+file.getOriginalFilename()));</span><br><span class="line">        return &quot;OK&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>测试结果</p><ul><li>上传文件</li></ul><p><img src="/deng123-dev.github.io/images/pasted-122.png" alt="upload successful"></p><ul><li>上传成功</li></ul><p><img src="/deng123-dev.github.io/images/pasted-123.png" alt="upload successful"></p><p><img src="/deng123-dev.github.io/images/pasted-124.png" alt="upload successful"></p><ul><li>请注意！！我这里是直接上传到E盘上面的<br><img src="/deng123-dev.github.io/images/pasted-125.png" alt="upload successful"></li></ul></li></ol><hr><h3 id="修改上传文件大小"><a href="#修改上传文件大小" class="headerlink" title="修改上传文件大小"></a>修改上传文件大小</h3><ul><li><p>配置单个上个上传文件的大小的限制</p><p>spring.servlet.multipart.max-file-size=2MB</p></li><li><p>配置在一次请求中上传文件的总容量的大小</p><p>spring.servlet.multipart.max-request-size=20MB</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot（2）</title>
      <link href="/deng123-dev.github.io/2020/05/14/springboot%EF%BC%882%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/05/14/springboot%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="创建一个HelloWorld项目"><a href="#创建一个HelloWorld项目" class="headerlink" title="创建一个HelloWorld项目"></a>创建一个HelloWorld项目</h1><p>实例代码：<br><img src="/deng123-dev.github.io/images/pasted-89.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">· 添加@RestController注解</span><br><span class="line">· 创建HelloWorld方法</span><br><span class="line">· 返回字符串</span><br></pre></td></tr></table></figure><a id="more"></a><p>测试结果：</p><p><img src="/deng123-dev.github.io/images/pasted-92.png" alt="upload successful"></p><hr><h1 id="springboot在controller中常用注解"><a href="#springboot在controller中常用注解" class="headerlink" title="springboot在controller中常用注解"></a>springboot在controller中常用注解</h1><table><thead><tr><th>注解名称</th><th>注解解释</th></tr></thead><tbody><tr><td>@RestController</td><td>@RestController注解相当于@ResponseBody ＋ @Controller合在起的作用。RestController使用的效果是将方法返回的对象直接在浏览器上展示成json格式。</td></tr><tr><td>@GetMapping</td><td>相当于@ GetMapping (method=RequestMethod.GET)的缩写</td></tr><tr><td>@PostMapping</td><td>相当于@ PostMapping (method=RequestMethod.POST)的缩写</td></tr><tr><td>@PutMapping</td><td>相当于@ PutMapping (method=RequestMethod.PUT)的缩写</td></tr><tr><td>@DeleteMapping</td><td>相当于@ DeleteMapping (method=RequestMethod.DELETE)的缩写</td></tr></tbody></table><hr><h1 id="springboot整合web层技术"><a href="#springboot整合web层技术" class="headerlink" title="springboot整合web层技术"></a>springboot整合web层技术</h1><hr><h2 id="springboot整合Servlet"><a href="#springboot整合Servlet" class="headerlink" title="springboot整合Servlet"></a>springboot整合Servlet</h2><hr><h3 id="什么是servlet"><a href="#什么是servlet" class="headerlink" title="什么是servlet"></a>什么是servlet</h3><p>　简单来说就是处理请求和发送响应的过程是由一种叫做Servlet的程序来完成的，而且   Servlet是为了解决动态页面产生的</p><p><img src="/deng123-dev.github.io/images/pasted-106.png" alt="upload successful"></p><p> springboot整合Servlet技术一共由两种方法，分别是：</p><ol><li><p>通过注解扫描完成Servlet组件的注册</p></li><li><p>通过方法完成Servlet组件的注册</p></li></ol><hr><h3 id="通过注解扫描完成Servlet组件的注册"><a href="#通过注解扫描完成Servlet组件的注册" class="headerlink" title="通过注解扫描完成Servlet组件的注册"></a>通过注解扫描完成Servlet组件的注册</h3><ol><li>对servlet类的创建（如何进行整合，注意划蓝圈的地方）</li></ol><p><img src="/deng123-dev.github.io/images/pasted-91.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">· 创建servlet包</span><br><span class="line">· 创建一个servlet类继承HttpServlet类</span><br><span class="line">· 重写doGet方法（拥有HttpServletRequest和HttpServletResponse两个参数）</span><br><span class="line">· 添加WebServlet注解（给name属性和urlPatterns属性赋值）</span><br></pre></td></tr></table></figure><ol start="2"><li>对启动类的修改 （如何进行整合，注意划蓝圈的地方）</li></ol><p><img src="/deng123-dev.github.io/images/pasted-93.png" alt="upload successful"></p><p>步骤：</p><p>   <code>添加@ServletComponentScan注解（因为它会自动扫描注解）</code></p><ol start="3"><li>测试结果   </li></ol><p><img src="/deng123-dev.github.io/images/pasted-94.png" alt="upload successful"></p><hr><h3 id="通过方法完成Servlet组件的注册"><a href="#通过方法完成Servlet组件的注册" class="headerlink" title="通过方法完成Servlet组件的注册"></a>通过方法完成Servlet组件的注册</h3><ol><li>创建servlet类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-95.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">· 创建servlet包</span><br><span class="line">· 创建一个servlet类继承HttpServlet类</span><br><span class="line">· 重写doGet方法（拥有HttpServletRequest和HttpServletResponse两个参数）</span><br><span class="line">（其实步骤和注解扫描整合Servlet类一致，唯一不同就是不用添加注解）</span><br></pre></td></tr></table></figure><ol start="2"><li>创建servlet配置类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-103.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">· 创建config包</span><br><span class="line">· 添加@Configuration和@Bean注解</span><br><span class="line">· 实例化ServletRegistrationBean通过ServletRegistrationBean创造新对象bean</span><br><span class="line">· 配置bean的url</span><br><span class="line">· 返回bean</span><br></pre></td></tr></table></figure><ol start="3"><li>测试结果</li></ol><p><img src="/deng123-dev.github.io/images/pasted-98.png" alt="upload successful"></p><hr><h2 id="Springboot整合Filter"><a href="#Springboot整合Filter" class="headerlink" title="Springboot整合Filter"></a>Springboot整合Filter</h2><hr><h3 id="什么是Filter"><a href="#什么是Filter" class="headerlink" title="什么是Filter"></a>什么是Filter</h3><p>Fliter过滤器实际上就是对web资源进行拦截，做一些处理后再交给下一个过滤器或servlet处理通常都是用来拦截request进行处理的，也可以对返回的response进行拦截处理<br><img src="/deng123-dev.github.io/images/pasted-107.png" alt="upload successful"></p><p>和整合servlet一样，整合Filter也有两种方法：</p><ol><li><p>通过注解扫描完成Filter组件的注册</p></li><li><p>通过方法完成Filter组件的注册</p></li></ol><hr><h3 id="通过注解扫描完成Filter组件的注册"><a href="#通过注解扫描完成Filter组件的注册" class="headerlink" title="通过注解扫描完成Filter组件的注册"></a>通过注解扫描完成Filter组件的注册</h3><ol><li>创建Filter类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-99.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">· 添加@WebFilter注解</span><br><span class="line">· 创建Filter包</span><br><span class="line">· 创建一个implements了Filter类的类</span><br><span class="line">· 添加doFilter，init和destroy等方法</span><br></pre></td></tr></table></figure><ol start="2"><li>修改启动类</li></ol><p>步骤：<br><code>和WebServlet一样，都是添加@ServletComponentScan注解</code></p><ol start="3"><li>测试结果</li></ol><p><img src="/deng123-dev.github.io/images/pasted-102.png" alt="upload successful"></p><hr><h3 id="通过方法完成Filter组件的注册"><a href="#通过方法完成Filter组件的注册" class="headerlink" title="通过方法完成Filter组件的注册"></a>通过方法完成Filter组件的注册</h3><ol><li>创建Filter类</li></ol><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">· 创建Filter包</span><br><span class="line">· 创建一个implements了Filter类的类</span><br><span class="line">· 添加doFilter，init和destroy等方法</span><br><span class="line">(其实和通过注解扫描完成Fliter的注册步骤一样，唯一的不同是不用添加注解)</span><br></pre></td></tr></table></figure><ol start="2"><li>创建Filter配置类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-108.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">除开FilterRegistrationBean替代ServletRegistrationBean，</span><br><span class="line">其余和用方法配置servlet类的步骤一致，不做过多说明</span><br></pre></td></tr></table></figure><ol start="3"><li>测试结果</li></ol><p><img src="/deng123-dev.github.io/images/pasted-105.png" alt="upload successful"></p><hr><h2 id="Springboot整合Listener的方式"><a href="#Springboot整合Listener的方式" class="headerlink" title="Springboot整合Listener的方式"></a>Springboot整合Listener的方式</h2><hr><h3 id="什么是Listener"><a href="#什么是Listener" class="headerlink" title="什么是Listener"></a>什么是Listener</h3><p>Listener（监听器）就是一个实现特定接口的普通java程序，这个程序专门用于监听另一个java对象的方法调用或属性改变，当被监听对象发生上述事件后，监听器某个方法将立即被执行。</p><hr><h3 id="通过注解扫描完成Listener组件注册"><a href="#通过注解扫描完成Listener组件注册" class="headerlink" title="通过注解扫描完成Listener组件注册"></a>通过注解扫描完成Listener组件注册</h3><ol><li>创建Listener类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-109.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">·添加@WebListener注解</span><br><span class="line">·创建一个继承 ServletContextListener类的类</span><br></pre></td></tr></table></figure><ol start="2"><li>修改启动类</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">和WebServlet和WebFilter类一样，都是添加@ServletComponentScan注解</span><br></pre></td></tr></table></figure><hr><h3 id="通过方法完成Listener组件注册"><a href="#通过方法完成Listener组件注册" class="headerlink" title="通过方法完成Listener组件注册"></a>通过方法完成Listener组件注册</h3><ol><li>创建Listener类</li></ol><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">和第一种用注解扫描创建的listener一致，(其实和通过注解扫描完成Listener的注册步骤一样，唯一的不同是不用添加注解) 不做过多描述</span><br></pre></td></tr></table></figure><ol start="2"><li>创建Listener配置类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-112.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">除开ListenerRegistrationBean替代ListenerRegistrationBean和不用配置bean.url</span><br><span class="line">其余和用方法配置servlet类的步骤一致，不做过多说明</span><br></pre></td></tr></table></figure><ol start="3"><li>测试结果 </li></ol><p><img src="/deng123-dev.github.io/images/pasted-114.png" alt="upload successful"></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot（1）</title>
      <link href="/deng123-dev.github.io/2020/05/01/springboot%EF%BC%881%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/05/01/springboot%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="spring-boot入门"><a href="#spring-boot入门" class="headerlink" title="spring boot入门"></a>spring boot入门</h1><hr><h2 id="springboot的特点"><a href="#springboot的特点" class="headerlink" title="springboot的特点"></a>springboot的特点</h2><ul><li><p>springboot来简化spring应用开发</p></li><li><p>整个spring技术栈的大整合</p></li><li><p>J2EE的一站式解决方案</p><p>（我觉得简单来说就是对用户封装了很多细节，不需要用户考虑其是怎样实现的）</p><a id="more"></a></li></ul><p> 优点</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 快速创建独立运行的Spring项目以及主流框架集成</span><br><span class="line">2. 使用嵌入式的Servlet容器，应用无需打成WAR包</span><br><span class="line">3. starters自动依赖与版本控制</span><br><span class="line">4. 大量的自动配置，简化开发，也可以修改默认值</span><br><span class="line">5. 无需配置XML，无代码生成，开箱即用</span><br><span class="line">6. 准生产环境的运行时应用监控</span><br><span class="line">7. 与云计算的天然集成</span><br></pre></td></tr></table></figure><p> 缺点</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 入门容易，精通难</span><br><span class="line">2. 需要了解spring的具体框架，才能知道其具体实现原理（了解其底层API）</span><br></pre></td></tr></table></figure><hr><h2 id="如何创建一个springboot项目"><a href="#如何创建一个springboot项目" class="headerlink" title="如何创建一个springboot项目"></a>如何创建一个springboot项目</h2><ol><li><p>通过官网创建项目</p></li><li><p>通过IDEA脚手架创建项目</p></li><li><p>通过IDEA中的Maven创建项目</p></li></ol><p>（想要了解如何创建的小伙伴自行百度或者google，就不细说了）</p><hr><h1 id="微服务（架构风格）"><a href="#微服务（架构风格）" class="headerlink" title="微服务（架构风格）"></a>微服务（架构风格）</h1><hr><h2 id="单体应用"><a href="#单体应用" class="headerlink" title="单体应用"></a>单体应用</h2><p> 单体应用：将所有应用程序打包在一个独立的单元，可以是JAR包，WAR包,EAR或者其他归档形式</p><p><img src="/deng123-dev.github.io/images/pasted-74.png" alt="upload successful"><br>   虽然具有<strong>易于测试，易于部署</strong>等优点，但是随着项目的加大，会存在<strong>牵一发而动全身，受开发人员技术栈</strong>不同等原因的限制</p><hr><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p> 微服务：微服务架构是一种架构思想，将每一个功能元素都最终都是一个可独立替换和可独立升级的软件单元，微服务架构强调的重点是业务系统需要彻底的<strong>组件化和服务化</strong>，原有的<strong>单个业务系统会拆分为多个可以独立开发，设计，运行和运维的小应用</strong>，这些小应用之间通过服务完成交互和集成<br><img src="/deng123-dev.github.io/images/pasted-75.png" alt="upload successful"></p><p>微服务优点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">单个服务更易于开发、维护</span><br><span class="line">单个服务启动比较快</span><br><span class="line">局部修改容易部署</span><br><span class="line">技术栈不受限</span><br><span class="line">按需伸缩</span><br></pre></td></tr></table></figure><p>微服务缺点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运维要求高</span><br><span class="line">分布式固有的复杂性</span><br><span class="line">重复劳动</span><br></pre></td></tr></table></figure><p><strong><em>Spring Boot 是 Java 领域微服务架构最优落地技术</em></strong></p><ul><li><p>spring boot： 快速构建一个微服务应用</p></li><li><p>spring cloud：实现每个独立单元的互调，实现微服务的治理</p></li><li><p>spring cloud data flow：进行流式数据的批处理</p></li></ul><hr><h1 id="spring-boot项目结构："><a href="#spring-boot项目结构：" class="headerlink" title="spring boot项目结构："></a>spring boot项目结构：</h1><hr><h2 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h2><hr><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;2.3.1.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br></pre></td></tr></table></figure><ul><li><p>springboot的父级依赖，只有继承它才是真正的springboot项目</p></li><li><p>spring-boot-starter-parent,用来提供相应的Maven依赖</p></li></ul><hr><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>启动器依赖</p><hr><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br><span class="line">&lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure><p><strong>spring-boot-maven-plugin插件时将springboot的应用程序打包成jar包的插件</strong></p><hr><h2 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h2><p>基于main方法来启动springboot项目；</p><p>启动类在启动时会做注解扫描位置，扫描为同包或者子包下的注解，所以启动类的位置应放在包的根下</p><ul><li><p>启动类和启动器的区别</p><ul><li><p>启动类表示项目的启动入口</p></li><li><p>启动器表示jar包的坐标</p></li></ul></li></ul><hr><h3 id="创建启动类"><a href="#创建启动类" class="headerlink" title="创建启动类"></a>创建启动类</h3><p>启动类代码：<br><img src="/deng123-dev.github.io/images/pasted-81.png" alt="upload successful"></p><p>测试结果<br><img src="/deng123-dev.github.io/images/pasted-83.png" alt="upload successful"></p><p>注意：</p><ul><li>加上@SpringBootApplication注解</li><li>运用SpringApplication中的run方法</li></ul><hr><h2 id="启动器"><a href="#启动器" class="headerlink" title="启动器"></a>启动器</h2><p>springboot将所有的场景做成一个个的启动器，只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。</p><p> spring-boot-starter提供多达44个启动器</p><ul><li><p>spring-boot-starter</p><p>这是springboot的核心启动器，包括自动配置，日志，YAML</p></li><li><p>spring-boot-actuator</p><p>帮助监控和管理应用</p></li><li><p>spring-boot-starter-web</p><p>支持全栈式的web开发</p></li></ul><hr><h2 id="配置文件格式"><a href="#配置文件格式" class="headerlink" title="配置文件格式"></a>配置文件格式</h2><p>springboot提供一个名称为application的全局配置文件，支持properties和YAML格式</p><hr><h3 id="properties格式"><a href="#properties格式" class="headerlink" title="properties格式"></a>properties格式</h3><p><img src="/deng123-dev.github.io/images/pasted-84.png" alt="upload successful"></p><ul><li>使用键值对进行书写  key=value</li></ul><p><img src="/deng123-dev.github.io/images/pasted-88.png" alt="upload successful"></p><hr><h3 id="YAML格式"><a href="#YAML格式" class="headerlink" title="YAML格式"></a>YAML格式</h3><ul><li>大小写敏感</li><li>使用缩进代表层次关系</li><li>使用的部分只能出现一次</li></ul><p>错误写法：</p><p><img src="/deng123-dev.github.io/images/pasted-87.png" alt="upload successful"></p><p>正确写法：</p><p><img src="/deng123-dev.github.io/images/pasted-86.png" alt="upload successful"></p><hr><h2 id="配置文件存放位置及加载顺序"><a href="#配置文件存放位置及加载顺序" class="headerlink" title="配置文件存放位置及加载顺序"></a>配置文件存放位置及加载顺序</h2><hr><h3 id="配置文件存放位置"><a href="#配置文件存放位置" class="headerlink" title="配置文件存放位置"></a>配置文件存放位置</h3><ul><li><p>当前项目的根目录下</p></li><li><p>当前项目根目录下的一个config子目录中</p></li><li><p>项目的resource即classpath根目录下</p></li><li><p>项目的resource即classpath根目录下的config子目录下</p></li></ul><hr><h3 id="配置文件不同格式的加载顺序"><a href="#配置文件不同格式的加载顺序" class="headerlink" title="配置文件不同格式的加载顺序"></a>配置文件不同格式的加载顺序</h3><ul><li><p>优先读取application.properties。</p></li><li><p>如果同一个配置属性，默认读取第一个，默认使用第一个读取到的，后面读取的不会覆盖第一个</p></li></ul><hr><h3 id="配置文件不同位置的加载顺序"><a href="#配置文件不同位置的加载顺序" class="headerlink" title="配置文件不同位置的加载顺序"></a>配置文件不同位置的加载顺序</h3><p> 优先级（从高到低）</p><pre><code>根目录中的config子录-&gt;当前项目根目录-&gt;resource的config子目录-&gt;resource根目录</code></pre><hr><h2 id="配置文件中的占位符"><a href="#配置文件中的占位符" class="headerlink" title="配置文件中的占位符"></a>配置文件中的占位符</h2><ol><li><p>语法：<br>${}</p></li><li><p>作用</p><ul><li><p>${}中可以获取框架提供方法的值</p></li><li><p>可以获取配置文件中的键的值赋给另一个键作为值</p></li></ul></li></ol><hr><h2 id="bootstrap配置文件"><a href="#bootstrap配置文件" class="headerlink" title="bootstrap配置文件"></a>bootstrap配置文件</h2><hr><h3 id="bootstrap配置文件介绍"><a href="#bootstrap配置文件介绍" class="headerlink" title="bootstrap配置文件介绍"></a>bootstrap配置文件介绍</h3><p> springboot中的两种上下文对象，分为bootstrap和application，bootstrap是应用程序的父上下文，也就是说bootstrap加载优先于application，bootstrap主要从额外的资源加载配置信息，<strong>它是任何spring应用程序外部属性的来源</strong>，bootstrap里面的属性会优先加载，它们默认也不能被本地相同配置覆盖</p><hr><h3 id="bootstrap配置文件特征"><a href="#bootstrap配置文件特征" class="headerlink" title="bootstrap配置文件特征"></a>bootstrap配置文件特征</h3><ul><li><p>bootstrap由父ApplicationContext加载，比application优先加载</p></li><li><p>bootstrap的属性不能被覆盖</p></li></ul><hr><h3 id="bootstrap和-application的应用场景"><a href="#bootstrap和-application的应用场景" class="headerlink" title="bootstrap和 application的应用场景"></a>bootstrap和 application的应用场景</h3><ol><li><p>application主要用于springboot项目的自动化配置</p></li><li><p>bootstrap主要应用于：</p><ul><li><p>使用spring cloud config 配置中心时，需要bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息</p></li><li><p>一些固定不能被覆盖的属性</p></li><li><p>加密/解密的场景</p></li></ul></li></ol><hr><h2 id="springboot核心注解"><a href="#springboot核心注解" class="headerlink" title="springboot核心注解"></a>springboot核心注解</h2><ol><li><p>@SpringBootApplication</p><p>springboot的启动类</p></li><li><p>@SpringBootConfiguration</p><p>此注解是@Configuration注解的派生注解，和@Configuration注解的功能一致</p></li><li><p>@Configuration</p><p>通过对bean对象的操作替代spring中的xml文件</p></li><li><p>@EnableAutoConfiguration</p><p>springboot自动配置，尝试根据你添加的jar包依赖自动配置你的spring应用</p></li><li><p>@AutoConfigurationPackage</p><p>自动注入主类下所在包下所有的加了注解的类</p></li><li><p>@Import</p><ul><li><p>直接导入普通类</p></li><li><p>导入实现了ImportSelector接口的类</p></li><li><p>导入实现了ImportBeanDefinitionRegister接口的类</p></li></ul></li><li><p>@ComponentScan</p><p>组件扫描，可自动发现和装配一些bean</p></li><li><p>@ConfigurationProperties</p><p>扫描配置属性</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统概要（3）:存储和文件管理</title>
      <link href="/deng123-dev.github.io/2020/04/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%A6%81%EF%BC%883%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/04/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%A6%81%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h1><hr><h2 id="存储层次"><a href="#存储层次" class="headerlink" title="存储层次"></a>存储层次</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-165.png" alt="upload successful"><br> <a id="more"></a></p><h2 id="地址映射（地址重定位，地址变换）"><a href="#地址映射（地址重定位，地址变换）" class="headerlink" title="地址映射（地址重定位，地址变换）"></a>地址映射（地址重定位，地址变换）</h2><hr><ul><li><p>逻辑地址（相对地址，虚地址）</p><p>用户的程序经过汇编或编译后形成目标代码，目标代码通常采用相对地址的形式，其首地址为0，其余指令中的地址都相对于首地址而编址，一个用户作业的目标程序的逻辑地址集合成为该作业的<strong>逻辑地址空间</strong></p><p>不能用逻辑地址空间在内存中读取信息</p></li><li><p>物理地址（绝对地址，实地址）</p><p>内存中的存储单元的实际内容，可直接寻址，<br>物理地址的总体构成了用户程序实际运行对的物理地址空间</p><p>物理地址空间是由存储器地址总线扫描出来的<br>空间，其大小决定于实际安装的主存容量</p></li><li><p>地址映射（地址重定位，地址变换）</p><p>为了保证CPU执行指令时可正确访问存储单元，<br>需将用户程序中的逻辑地址转换为运行时由机器<br>直接寻址的物理地址，这一过程称为<strong>地址映射</strong></p><p>由于程序的<strong>逻辑地址与分配到的<br>内存物理地址不一致</strong>, 而CPU执行指令时，是按物理地址进行的，所以要进行地址转换</p></li></ul><h2 id="重定位（地址映射方法）"><a href="#重定位（地址映射方法）" class="headerlink" title="重定位（地址映射方法）"></a>重定位（地址映射方法）</h2><hr><p>   重定位：在<strong>可执行文件装入时</strong>需要解决可执行<br>   文件中地址（指令和数据）和内存地址的对应。由操作系统中的装入程序loader来完成。</p><p>   重定位方法：</p><ul><li><p>绝对装入</p><p>在可执行文件中记录内存地址，装入时<strong>直接定<br>位</strong>在上述(即文件中记录的地址)内存地址</p></li><li><p>可重定位装入</p><p>列出各个需要重定位的地址单元和<br>相对地址值。当用户程序被装入内存时，一次性实现<br>逻辑地址到物理地址的转换</p></li><li><p>动态装入</p><p>在可执行文件中记录虚拟内存地址，<strong>装入和执行时</strong> 通过硬件地址变换机构，完成虚拟地址到实际内存地址的变换。</p></li></ul><h2 id="分区存储管理方案"><a href="#分区存储管理方案" class="headerlink" title="分区存储管理方案"></a>分区存储管理方案</h2><hr><p>   系统把内存用户区划分为若干分区，一个进程占据一个分区</p><p><img src="/deng123-dev.github.io/images/pasted-167.png" alt="upload successful">   </p><ul><li><p>固定分区</p><p> 预先把可分配的内存空间分割成若干个连<br> 续区域，每一区域称为分区，分区大小固定不变，每个分区装一个且只能装一个作业</p></li><li><p>可变分区</p><ul><li><p>内存不是预先划分好的</p></li><li><p>作业装入时，根据作业的需求和内存空间的<br>使用情况来决定是否分配</p></li><li><p>若有足够的空间，则按需要分割一部分分区<br>给该进程；否则令其等待内存空间</p></li></ul></li><li><p>碎片问题</p><p> 经过一段时间的分配回收后，内存中存<br> 在很多很小的空闲块。它们每一个都很<br> 小，不足以满足分配要求；但其总和满<br> 足分配要求。这些空闲块被称为碎片</p><p> <strong>造成存储资源的浪费</strong></p></li></ul><h2 id="页式存储管理方案"><a href="#页式存储管理方案" class="headerlink" title="页式存储管理方案"></a>页式存储管理方案</h2><hr><ul><li>基本思想</li></ul><p>  <strong>把用户程序按逻辑页划分成大小相等</strong>的部分，称为页。从0开始编制页号，页内地址是相对于0编址</p><ul><li>逻辑地址</li></ul><p><img src="/deng123-dev.github.io/images/pasted-168.png" alt="upload successful"></p><ul><li>如何管理</li></ul><p><img src="/deng123-dev.github.io/images/pasted-169.png" alt="upload successful"><br>  <strong>页表：系统为每个进程建立一个页表，页表给出逻辑页号和具体内存块号相应的关系，页表放在内存，属于进程的现场信息，逻辑上相邻的页，物理上不一定相邻</strong></p><ul><li><p>硬件支持</p><ul><li><p>页表始址寄存器</p></li><li><p>页表长度寄存器</p></li><li><p>TLB(相联存储器，俗称快表)</p><ul><li><p>引入快表的目的：<strong>为了提高地址映射速度</strong></p></li><li><p>用途：保存正在运行进程的页表的子集（部分表项）</p></li><li><p>特点：按内容并行查找    </p><p><img src="/deng123-dev.github.io/images/pasted-172.png" alt="upload successful"></p></li></ul></li></ul></li></ul><h2 id="段式存储管理方案"><a href="#段式存储管理方案" class="headerlink" title="段式存储管理方案"></a>段式存储管理方案</h2><hr><ul><li><p>基本思想 </p><p>   <strong>按程序自身的逻辑关系</strong>划分为若干个程序段，每个程序段都有一个段名，且有一个段号</p></li><li><p>逻辑地址   </p><p><img src="/deng123-dev.github.io/images/pasted-170.png" alt="upload successful"></p></li></ul><ul><li><p>如何管理</p><p><img src="/deng123-dev.github.io/images/pasted-171.png" alt="upload successful"></p></li></ul><p> <strong>段表：记录了段号，段的首（地）址和长度之间的关系每一个程序设置一个段表，放在内存属于进程的现场信息</strong></p><p> <strong>注意：页式存储被划分到的内存空间是相等的，而段式存储是不相等的，而且内存随机分割，需要多少放多少</strong></p><ul><li><p>硬件支持</p><ul><li><p>页表始址寄存器</p></li><li><p>页表长度寄存器</p></li><li><p>TLB(相联存储器，俗称快表)</p><p><img src="/deng123-dev.github.io/images/pasted-173.png" alt="upload successful"></p></li></ul></li></ul><h2 id="交换技术和覆盖技术"><a href="#交换技术和覆盖技术" class="headerlink" title="交换技术和覆盖技术"></a>交换技术和覆盖技术</h2><hr><ul><li><p>为什么引入</p><p>在多道环境下扩充内存的方法，用以解决在较小的存储空间中运行较大程序时遇到     的矛盾</p></li><li><p>交换技术和覆盖技术的共同点 </p><p>进程的程序和数据主要放在外存，当前<br>需要执行的部分放在内存，内外存之间<br>进行信息交换</p></li></ul><h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><hr><p>  基本思想：<strong>把程序划分为若干个功能上相对独立的程序段，按照其自身的逻辑结构将那些不会同时执行的程序段共享同一块内存区域</strong><br>   <img src="/deng123-dev.github.io/images/pasted-175.png" alt="upload successful"></p><h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><hr><ol><li><p>为什么引入</p><p>当内存空间紧张时，系统将内存中某些进程暂时移到外存，把外存中某些进程换进内存，占据前者所占用的区域，这种技术是<strong>进程在内存与外存之间的动态调度</strong></p></li><li><p>交换技术和覆盖技术的不同点 </p><p>与覆盖技术相比，交换技术不要求用户给出程<br>序段之间的逻辑覆盖结构；而且，交换发生在<br> 进程或作业之间，而覆盖发生在同一进程或作<br> 业内。此外，覆盖只能覆盖那些与覆盖段无关<br> 的程序段   </p></li></ol><h2 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h2><hr><p>   以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的<strong>资源转换技术</strong></p><ul><li><p>基本思想</p><p>操作系统把程序当前使用的部分保留在内存，而把其它部分保存在磁盘上，并在需要时在内存和磁盘之间动态交换</p></li><li><p>目的</p><p>提高内存利用率</p></li></ul><h2 id="程序局部性原理"><a href="#程序局部性原理" class="headerlink" title="程序局部性原理"></a>程序局部性原理</h2><hr><ul><li><p>时间局部性</p><p>  一条指令被执行了，在不久的将来它可能再被执行</p></li><li><p>空间局部性</p><p>  若某一存储单元被使用，则在一定时间内，与<br>  该存储单元相邻的单元可能被使用</p></li></ul><h2 id="缺页中断（Page-Fault）处理"><a href="#缺页中断（Page-Fault）处理" class="headerlink" title="缺页中断（Page Fault）处理"></a>缺页中断（Page Fault）处理</h2><hr><p>在地址映射过程中，在页表中发现所要访问的 页不在内存，则产生缺页中断。操作系统接到 此中断信号后，就调出缺页中断处理程序，根据页表中给出的外存地址，将该页调入内存，使作业继续运行下去</p><h2 id="页面淘汰算法"><a href="#页面淘汰算法" class="headerlink" title="页面淘汰算法"></a>页面淘汰算法</h2><hr><ul><li>最近未使用页面淘汰算法（NRU——Not Recently Used）</li></ul><p>选择在最近一段时间内未使用过的一页并淘汰之</p><ul><li>先进先出页面淘汰算法（FIFO）</li></ul><p>选择在内存中驻留时间最长的页并淘汰之</p><ul><li>最近最少使用页面淘汰算法（LRU——Least Recently Used）</li></ul><p>选择最后一次访问时间距离当前时间最长的一页并淘汰之</p><h2 id="影响缺页次数的因素"><a href="#影响缺页次数的因素" class="headerlink" title="影响缺页次数的因素"></a>影响缺页次数的因素</h2><hr><ul><li>进程的物理页面数</li><li>页面本身的大小</li><li>程序的编制方法</li><li>页面淘汰算法</li></ul><h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><ol><li>文件的逻辑结构</li></ol><ul><li><p>有结构文件指的是一个以及以上的记录构成的文件，故又把它称为<strong>记录式文件</strong></p></li><li><p>无结构文件是指字符流构成的文件，故又称为<strong>流式文件</strong></p></li></ul><ol start="2"><li>文件存取</li></ol><p>通常由三种文件存取方法：<code>顺序存取法</code>、<code>直接存取法</code>和<code>按键存取法（索引存取法）</code>。文件存取法与文件的物理结构有关。</p><ol start="3"><li>文件控制块</li></ol><p>为了能对一个文件进行正确的存取，操作系统必须为文件设置用于描述和控制文件的数据结构，称之为“文件控制块（FCB）</p><ol start="4"><li>文件目录</li></ol><p>文件目录是指：为实现“按名存取”，必须建立文件名与辅存空间中物理地址的对应关系</p><ol start="5"><li><p>文件的物理结构</p><ul><li><p>顺序结构</p></li><li><p>连接结构</p></li><li><p>索引结构</p></li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统概要（2）：进程与线程</title>
      <link href="/deng123-dev.github.io/2020/04/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%A6%81%EF%BC%882%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/04/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%A6%81%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="进程线程模型"><a href="#进程线程模型" class="headerlink" title="进程线程模型"></a>进程线程模型</h1><hr><h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><hr><ul><li><p>进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的独立单位</p></li><li><p>为了描述程序在并发执行时对系统资源的共享，所需的一个描述程序执行时动态特征的概念</p><a id="more"></a> </li></ul><h2 id="程序与进程的区别"><a href="#程序与进程的区别" class="headerlink" title="程序与进程的区别"></a>程序与进程的区别</h2><hr><table><thead><tr><th>进程</th><th>程序</th></tr></thead><tbody><tr><td>进程更能真实地描述并发</td><td>程序不能</td></tr><tr><td>进程是动态的</td><td>程序是静态的</td></tr><tr><td>进程有生长周期</td><td>程序是相对长久的</td></tr><tr><td>进程具有创建其他进程的功能</td><td>一个程序可对应多个进程</td></tr><tr><td>进程由程序和数据两部分组成</td><td></td></tr></tbody></table><h2 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h2><hr><ul><li><p>进程切换的是什么</p><p>进程切换的是上下文，上下文是由程序正确运行所需的状态组成的，这个状态包括存放在存储器中的程序的代码和数据，他的栈，通用目的寄存器的内容，程序计数器，环境变量以及打开文件描述符的集合。</p></li><li><p>进程如何进行切换</p><p>从正在运行的进程中收回处理器，然后再使带运行进程来占用处理器，实质上就是把进程存放在处理器的寄存器中的数据找个地方存起来，从而把处理器的起存其腾出来给其他进程使用</p></li><li><p>何时进行进程切换</p><p>当有能力挂起正在cpu上运行的进程，并恢复以前挂起的进程的执行时</p></li></ul><h2 id="进程的不同状态和转换"><a href="#进程的不同状态和转换" class="headerlink" title="进程的不同状态和转换"></a>进程的不同状态和转换</h2><hr><ul><li><p>进程的3种状态</p><ul><li><p>运行态</p><p>进程占有CPU，并在CPU上运行</p></li><li><p>就绪态</p><p>一个进程已经具备运行条件，但由于无CPU暂时不能运行的状态（当调度给其CPU时，立即可以运行）</p></li><li><p>等待态</p><p> 阻塞态、封锁态、睡眠态<br>  指进程因等待某种事件的发生而暂时不能运行的状态（即使CPU空闲，该进程也不可运行）</p></li></ul></li><li><p>状态转换</p></li></ul><p><img src="/deng123-dev.github.io/images/pasted-160.png" alt="upload successful"></p><table><thead><tr><th>状态转换</th><th>进程状态转换的原因</th></tr></thead><tbody><tr><td>就绪 –&gt; 运行</td><td>调度程序选择一个新的进程运行</td></tr><tr><td>运行 –&gt; 就绪</td><td>(1)运行进程用完了时间片 (2) 一个高优先级进程处于就绪状态，中断正在运行的进程</td></tr><tr><td>运行 –&gt; 等待</td><td>(1)当一个进程必须等待时  (2) OS尚未完成服务  (3)对一资源的访问尚不能进行初始化I/O且必须等待结果 (4) 等待某一进程提供输入 (IPC)</td></tr><tr><td>等待 –&gt; 就绪</td><td>当所等待的事件发生时</td></tr></tbody></table><h2 id="PCB（进程控制块）"><a href="#PCB（进程控制块）" class="headerlink" title="PCB（进程控制块）"></a>PCB（进程控制块）</h2><hr><ol><li>概念</li></ol><p>系统为了管理进程设置的一个专门的数据结构，用它来记录进程的外部特征，描述进程的运动变化过程，PCB是感知进程存在的唯一标志</p><ol start="2"><li><p>PCB的内容</p><ul><li><p>进程描述信息</p><p>进程标识符，进程名，用户标识符</p></li><li><p>进程控制信息</p><p>当前状态，优先级，代码执行入口地址，<br>程序的外存地址，运行统计信息，进程的队列指针，进程的消息队列指针</p></li><li><p>所拥有的资源和使用情况<br> 虚拟地址空间的现状，打开文件列表</p></li><li><p>CPU现场保护信息<br>寄存器值，指向赋予该进程的段/页表的指针</p></li></ul></li></ol><ol start="3"><li><p>PCB的组织方式</p><p> PCB的大小决定了系统中最多可同时存在的进程个数，称为系统的并发度</p><ul><li><p>链接结构</p></li><li><p>索引结构<br> 对具有相同状态的进程，分别设置各自的PCB索引表，表明PCB在PCB表中的地址</p></li></ul></li></ol><h2 id="进程调度的各种算法"><a href="#进程调度的各种算法" class="headerlink" title="进程调度的各种算法"></a>进程调度的各种算法</h2><hr><ul><li><p>先来先服务调度算法</p><p>选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列</p></li></ul><ul><li><p>短作业(进程)优先调度算法</p><p>  短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行</p></li></ul><ul><li><p>时间片轮转法</p><p> 当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾</p></li></ul><ul><li><p>多级反馈队列调度法</p><p>  目前被公认的一种较好的进程调度算法</p></li></ul><ul><li><p>优先权调度算法</p><p>  该算法是把处理机分配给就绪队列中优先权最高的进程</p></li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><hr><ol><li><p>概念</p><p> 它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，</p></li><li><p>线程和进程的区别和联系</p><ul><li><p>联系</p><p>一个进程至少拥有一个线程–主线程，也可以有多个线程，一个线程必须有一个父进程。多个进程可以并发执行。一个进程可以创建和撤销另一个进程，同一个进程的多个线程可以并发执行</p></li><li><p>区别</p><ul><li><p>进程的系统开销大于线程</p></li><li><p>多进程的程序比多线程的程序更加健壮，但在切换时，耗费资源大，效率较差</p></li></ul></li></ul></li></ol><h1 id="进程的同步与通信"><a href="#进程的同步与通信" class="headerlink" title="进程的同步与通信"></a>进程的同步与通信</h1><hr><h2 id="进程在并发环境下的特点"><a href="#进程在并发环境下的特点" class="headerlink" title="进程在并发环境下的特点"></a>进程在并发环境下的特点</h2><hr><ul><li><p>程序结果的不可再现性</p><p>并发程序执行的结果与其执行的相对速度有关，是不确定的</p></li><li><p>程序的执行是间断性的</p><p>一个程序可能走到中途停下来，失去原有的时序关系</p></li><li><p>资源共享（失去封闭性）</p><h2 id="进程间的交互关系"><a href="#进程间的交互关系" class="headerlink" title="进程间的交互关系"></a>进程间的交互关系</h2><hr></li></ul><ul><li><p>互斥</p><p> 指多个进程不能同时使用同一个资源</p></li><li><p>死锁</p><p> 指多个进程互不想让，都得不到足够的资源</p></li><li><p>饥饿</p><p> 指一个进程一直得不到资源</p></li></ul><h2 id="互斥与同步"><a href="#互斥与同步" class="headerlink" title="互斥与同步"></a>互斥与同步</h2><p>  进程竞争带来的问题： </p><ul><li><p>死锁问题：一组进程如果都获得部分资源，还想要其他进程所占有的资源，最终所有的进程将陷入死锁</p></li><li><p>饥饿问题：一个进程由于其他进程总是优于它而被无限期拖延</p></li></ul><ul><li>进程的互斥：解决进程间竞争关系的手段</li></ul><p>   <strong>直接制约关系，源于进程合作</strong></p><p>   <strong><em>指若干个进程要使用同意共享资源时，任何时刻最多允许一个进程去使用，其他进程要使用必须等待占有资源的进程释放该资源</em></strong></p><ul><li><p>进程的同步：解决进程间协作关系的手段</p><p><strong>间接制约关系，源于资源共享</strong></p></li></ul><p>   <strong><em>一个进程依赖另一个进程的消息或信号，当一个进程没有得到来自于另一个进程的消息或信号时则需要等待，直到消息或信号到达才能被唤醒</em></strong></p><ul><li><p>临界资源</p><p>定义：系统中某些资源一次只允许一个进程使用</p></li><li><p>临界区</p><p>定义：进程中涉及到临界资源的程序段</p></li></ul><h2 id="实现互斥的几种解决方案"><a href="#实现互斥的几种解决方案" class="headerlink" title="实现互斥的几种解决方案"></a>实现互斥的几种解决方案</h2><hr><ul><li>硬件层面：禁用中断、特殊机器指令</li><li>软件层面：应用层面、操作系统层面</li></ul><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><hr><p>操作系统可从进程管理者的角度来处理互斥的问题，信号量就是操作系统提供的管理公有资源的有效手段</p><ol><li><p>信号量以及P,V操作</p><ul><li><p>P操作</p><p>该进程状态置为等待状态；<br>将该进程的PCB插入相应的等待队列末尾</p></li><li><p>V操作</p><p>唤醒相应等待队列s.queue中等待的一个进程<br>改变其状态为就绪态，并将其插入就绪队列</p><p><strong>P,V操作都是原语操作</strong></p></li></ul><p><strong>原语：是完成某种特定功能的一段程序，具有不可分割性或不可中断性</strong></p></li></ol><ol start="2"><li>生产者-消费者问题</li></ol><p><img src="/deng123-dev.github.io/images/pasted-162.png" alt="upload successful"></p><p><img src="/deng123-dev.github.io/images/pasted-163.png" alt="upload successful"></p><h2 id="进程的通信方式"><a href="#进程的通信方式" class="headerlink" title="进程的通信方式"></a>进程的通信方式</h2><p>实现进程间的低级通信，它只能传递简单的信号，不能传递交换大量信息，P.V操作称为低级通信原语</p><p>如果要在进程间传递大量信息则要用高级通信原语，称为进程间通信</p><ol><li>共享内存</li></ol><p>相互通信的进程间设置公共内存，一组进程向该公共内存中写入，另一组进程从公共内存中读出</p><p>  →实现两组进程间的信息交换</p><ol start="2"><li>消息传递</li></ol><p>系统提供了两个高级通信原语：send和receive</p><p>send：当要进行消息传递时执行send</p><p>receive：当接收者要接收消息时执行receive</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统概要（1）：系统机制</title>
      <link href="/deng123-dev.github.io/2020/04/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%A6%81/"/>
      <url>/deng123-dev.github.io/2020/04/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h1><hr><ol><li><p>操作系统的定义：</p><p>是一组主管并控制计算机操作，运行和管理硬件，软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序</p><a id="more"></a> </li><li><p>操作系统在计算机系统中的位置：</p><p>  <strong>内核和基石</strong></p></li></ol><ol start="3"><li><p>操作系统的特征</p><ul><li><p>并发：而并发性是指两个或者多个事件在同一时间的间隔内发生</p></li><li><p>共享：系统中的资源可供内存中多个并发执行的进程共同使用</p></li><li><p>虚拟：把物理实体变成逻辑上的对应物</p></li><li><p>异步：在多道程序运行环境，由于资源有限，程序的运行并不是一气呵成的，下多个进程并发执行是以“走走停停”的方式进行的，以不可知的速度运行下去的</p></li></ul></li></ol><ol start="4"><li><p>理解操作系统的不同角度</p><ul><li><p>作为软件来看</p></li><li><p>资源管理的观点</p></li><li><p>进程的观点</p></li><li><p>虚拟机观点</p></li><li><p>服务提供者观点</p></li></ul></li><li><p>操作系统向不同用户提供的不同接口</p><ul><li><p>系统命令：供用户用于组织和控制自己的作业运行。命令行，菜单式，GUI命令脚本</p></li><li><p>编程接口：供用户程序和系统程序调用操作系统的功能。系统调用和高基语言库函数</p></li></ul></li></ol><h1 id="系统机制"><a href="#系统机制" class="headerlink" title="系统机制"></a>系统机制</h1><hr><h2 id="cpu的工作模式和工作状态"><a href="#cpu的工作模式和工作状态" class="headerlink" title="cpu的工作模式和工作状态"></a>cpu的工作模式和工作状态</h2><hr><ol><li><p>cpu不同的工作模式</p><ul><li><p>实模式</p></li><li><p>保护模式 </p></li><li><p>系统管理模式</p></li></ul></li><li><p>管态：操作系统管理程序运行的状态，能执行指令全集，改变cpu状态的能力</p></li><li><p>目态：用户程序运行的状态，如果在目态下用户执行管态指令就会被中断</p></li></ol><h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><hr><h3 id="中断概念："><a href="#中断概念：" class="headerlink" title="中断概念："></a>中断概念：</h3><hr><p> cpu对于系统发生的某个事件做出的一些反应</p><p>  cpu暂停正在执行的程序，保留现场后自动转取执行相应事件的处理程序，处理完<br>成后返回断点，继续执行被打断的程序 </p><ul><li><p>事件：异步/同步事件</p></li><li><p>特点：随即发生的，可恢复的，自动处理的</p></li></ul><p>中断和异常的类型：</p><table><thead><tr><th>中断</th><th>异常</th></tr></thead><tbody><tr><td>I/O中断</td><td>系统调用</td></tr><tr><td>时钟中断</td><td>缺页异常</td></tr><tr><td>硬件故障</td><td>断点指令</td></tr><tr><td>程序性中断</td><td>其他程序性异常</td></tr></tbody></table><p>中断和异常的区别：      </p><p> 中断：和正执行指令无关，可以屏蔽</p><p> 异常：与正执行指令有关，不可屏蔽</p><h3 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h3><hr><ol><li><p>中断系统的两大组成部分</p><ul><li><p>硬件中断装置</p></li><li><p>软件中断处理程序</p></li></ul></li><li><p>相关概念</p><ul><li><p>中断源：引起中断发生的事件</p></li><li><p>中断寄存器： 记录中断</p></li><li><p>中断字：中断寄存器中的内容</p></li><li><p>系统堆栈：在内存开辟的一块用于临时保存现场</p></li></ul></li></ol><h3 id="中断优先级和中断屏蔽"><a href="#中断优先级和中断屏蔽" class="headerlink" title="中断优先级和中断屏蔽"></a>中断优先级和中断屏蔽</h3><hr><p> 处理机优先级：</p><p> 指出处理机正运行程序的中断响应级别。只允许处理机去响应比该优先级高的中断,而屏蔽低于或等于该优先级的中断</p><p> 中断屏蔽：</p><p> 指禁止CPU响应中断或禁止中断出现</p><h3 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h3><hr><p> 中断响应：发现中断，接收中断的过程，由中断装置完成</p><p> 中断响应的处理过程：<br><img src="/deng123-dev.github.io/images/pasted-156.png" alt="upload successful"></p><p>  （1） 在每条指令执行周期的最后时刻扫描中断寄存器，询问是否有中断信号</p><p>  （2） 若无中断信号，继续执行下一条指令</p><p>  （3） 若有中断，中断硬件将该中断触发器内容按规定编码送入PSW的相应位，称为中断码，通过交换中断向量引出中断处理程序</p><h3 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h3><hr><p><img src="/deng123-dev.github.io/images/pasted-176.png" alt="upload successful"></p><p> （1）设备给处理器发一个中断信号</p><p> （2）处理器处理完当前指令后响应中断</p><p> （3）处理器处理完当前指令后检测到中断，判断出中断来源并向发送中断的设备发送了确认中断信号</p><p> （4）处理器开始为软件处理中断做准备</p><p> （5）处理器根据中断源查询中断向量表，获得与该中断相联系的处理程序入口地址。</p><p> （6）中断处理程序开始工作</p><p> （7）中断处理结束时，处理器检测到中断返回指令</p><p> （8）PSW和PC恢复成中断前的值</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><hr><ol><li><p>系统调用概述 </p><p>系统调用：用户在程序中调用操作系统提供的一些子功能</p><ul><li><p>一种特殊的过程调用，由特殊的机器指令实现</p></li><li><p>系统调用时操作系统提供给编程人员的唯一接口</p></li><li><p>系统从目态转入管态</p></li><li><p>系统调用是一个低级过程，只能由汇编语言访问</p></li><li><p>利用系统调用，动态请求和释放系统资源</p></li></ul></li></ol><ol start="2"><li>系统调用的处理过程</li></ol><p><img src="/deng123-dev.github.io/images/pasted-159.png" alt="upload successful"><br><img src="/deng123-dev.github.io/images/pasted-158.png" alt="upload successful"></p><ol start="3"><li><p>系统调用参数传递</p><ul><li><p>由陷入指令自带参数</p></li><li><p>通过通用寄存器传递参数</p></li><li><p>在内存中开辟专用堆栈区传递参数</p></li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>web基础（2）</title>
      <link href="/deng123-dev.github.io/2020/04/04/web%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/04/04/web%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-超文本传输协议"><a href="#HTTP-超文本传输协议" class="headerlink" title="HTTP(超文本传输协议)"></a>HTTP(超文本传输协议)</h1><p> HTTP是基于<strong>C/S架构</strong>的<strong>应用层</strong>协议，请求通常是由 浏览器这样的客户端发起的，有web 服务器进行处理<br> 客户端和服务器通过交换各自的信息进行交互。<br> <a id="more"></a></p><ul><li>默认端口为<strong>80</strong></li><li>由像浏览器这样的客户端发出的消息叫做request </li><li>被服务器响应的消息叫做responses</li><li>无状态性：每次请求都是相互独立的</li></ul><h2 id="HTTP-request"><a href="#HTTP-request" class="headerlink" title="HTTP:request"></a>HTTP:request</h2><p>对于browser请求页面的流程：</p><ul><li>与服务器建立TCP连接；</li><li>发送HTTP请求；</li><li>收取HTTP响应，然后把网页在浏览器中显示出来。</li></ul><h3 id="请求格式"><a href="#请求格式" class="headerlink" title="请求格式"></a>请求格式</h3><p><img src="/deng123-dev.github.io/images/pasted-68.png" alt="upload successful"></p><h4 id="请求行和请求头部"><a href="#请求行和请求头部" class="headerlink" title="请求行和请求头部"></a>请求行和请求头部</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: www.sina.com.cn</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 xxx</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,en-US;q&#x3D;0.8</span><br></pre></td></tr></table></figure><ul><li>请求行解释</li></ul><table><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>GET</td><td>表示使用获取路径为/的资源</td></tr><tr><td>HTTP/1.1</td><td>表示使用的是HTTP  1.1的协议</td></tr></tbody></table><ul><li>请求头解释</li></ul><table><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>HOST</td><td>表示请求的主机名,表示浏览器正在请求的域名</td></tr><tr><td>User-Agent</td><td>表示客户端本身，例如浏览器的表示</td></tr><tr><td>Accept</td><td>表示浏览器能接收的数据类型，如text/<em>，images/</em></td></tr><tr><td>Accept-Language</td><td>表示浏览器偏好的语言</td></tr><tr><td>Accept-Encoding</td><td>表示浏览器可以支持的压缩类型，例如gzip, deflate, br</td></tr></tbody></table><h4 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h4><p>因为<strong>get通过URL传送数据</strong>，而<strong>post通过请求数据体传送数据</strong>，所以一般情况下get方法中不体现请求数据（<strong>当然也可以将请求数据放在get中的请求数据体中使其体现</strong>）</p><h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><p>请求参数的两种方式：</p><ol><li>URL（GET请求）：</li></ol><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浏览器？参数名&#x3D;参数值&amp;参数二&#x3D;参数值</span><br></pre></td></tr></table></figure><ol start="2"><li>request body（POST请求）</li></ol><p>通过request body传递参数</p><ol start="3"><li><p>参数格式：</p><ul><li><p>多个参数用&amp;隔开</p></li><li><p>参数以键值对的方式出现</p></li></ul></li></ol><h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载</p><p> 好处：</p><ul><li>缓解服务器端压力</li><li>提升性能(获取资源的耗时更短了)</li></ul><p>（关于缓存的内容确实少的可怜，其中一个重要原因在于我对缓存的了解太少，望各位大佬指教）</p><h3 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h3><table><thead><tr><th>动词名称</th><th>解释</th></tr></thead><tbody><tr><td>GET</td><td>从服务器取出资源（单个或多个）。</td></tr><tr><td>POST</td><td>在服务器新建资源。</td></tr><tr><td>PUT</td><td>在服务器更新资源（客户端提供改变后的完整资源）。</td></tr><tr><td>PATCH</td><td>在服务器更新(属性)资源（客户端提供改变的属性，比如说某个字段+1）。</td></tr><tr><td>DELETE</td><td>从服务器删除资源。</td></tr></tbody></table><p>还有两个不常用的HTTP动词：</p><table><thead><tr><th>动词名称</th><th>解释</th></tr></thead><tbody><tr><td>HEAD</td><td>获取资源的元数据。</td></tr><tr><td>OPTIONS</td><td>获取信息，关于资源的哪些属性是客户端可以改变的。</td></tr></tbody></table><h3 id="Get和Post的区别"><a href="#Get和Post的区别" class="headerlink" title="Get和Post的区别"></a>Get和Post的区别</h3><ul><li>Get：从服务器上面获取数据</li><li>post: 向服务器传输数据</li></ul><table><thead><tr><th>分类</th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>后退按钮/刷新</td><td>无害</td><td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td></tr><tr><td>书签</td><td>可收藏为书签</td><td>不可收藏为书签</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能缓存</td></tr><tr><td>传参数方式</td><td>用URL传参数</td><td>用body传参数</td></tr><tr><td>历史</td><td>参数保留在浏览器历史中。</td><td>参数不会保存在浏览器历史中。</td></tr><tr><td>对数据长度的限制</td><td>是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td><td>无限制。</td></tr><tr><td>对数据类型的限制</td><td>只允许 ASCII 字符。</td><td>没有限制。也允许二进制数据。</td></tr><tr><td>安全性</td><td>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td><td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr><tr><td>可见性</td><td>数据在 URL 中对所有人都是可见的。</td><td>数据不会显示在 URL 中。</td></tr></tbody></table><h3 id="发送post请求"><a href="#发送post请求" class="headerlink" title="发送post请求"></a>发送post请求</h3><p>三种发送post请求的方法：</p><ul><li><p>浏览器默认使用get请求</p></li><li><p>线上的默认工具发送 post请求</p></li><li><p>HTML from中可以指定get或post请求</p></li></ul><p><em>form中的post请求</em>：</p><pre><code>&lt;form action=&quot;https://www.baidu.com&quot; method=&quot;post&quot;&gt;          &lt;p&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;/p&gt;          &lt;p&gt;密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;/&gt;&lt;/p&gt;          &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;      &lt;/form&gt;    </code></pre><p> <em>展示的效果</em>：</p> <form action="https://www.baidu.com" method="post">            <p>用户名：<input type="text" name="name"/></p>            <p>密码：<input type="password" name="pwd"/></p>            <input type="submit" value="登录">        </form><h2 id="HTTP-response"><a href="#HTTP-response" class="headerlink" title="HTTP:response"></a>HTTP:response</h2><h3 id="reponse格式"><a href="#reponse格式" class="headerlink" title="reponse格式"></a>reponse格式</h3><p>HTTP响应也由三个部分组成，分别是：<strong>状态行、消息报头、响应正文</strong>。</p><ul><li><p>格式：</p><p> ＜status-line＞</p><p> ＜headers＞</p><p> ＜blank line＞</p><p> [＜response-body＞]</p></li><li><p>response和request的区别：</p></li></ul><p><strong><em>response用状态字段代替了request请求信息</em></strong></p><h3 id="reponse状态代码"><a href="#reponse状态代码" class="headerlink" title="reponse状态代码"></a>reponse状态代码</h3><ul><li>首数字的状态响应码以及对应情况 </li></ul><table><thead><tr><th>相应类别</th><th>代表情况</th></tr></thead><tbody><tr><td>1xx</td><td>指示信息–表示请求已接收，继续处理</td></tr><tr><td>2xx</td><td>成功–表示请求已被成功接收、理解、接受</td></tr><tr><td>3xx</td><td>重定向–要完成请求必须进行更进一步的操作</td></tr><tr><td>4xx</td><td>客户端错误–请求有语法错误或请求无法实现</td></tr><tr><td>5xx</td><td>服务器端错误–服务器未能实现合法的请求</td></tr></tbody></table><ul><li>常见状态码以及对应情况</li></ul><table><thead><tr><th>常见的状态代码</th><th>表示的情况</th></tr></thead><tbody><tr><td>200 OK：</td><td>客户端请求成功。</td></tr><tr><td>301 Moved Permanently</td><td>被请求的资源已永久移动到新位置</td></tr><tr><td>302 Found</td><td>要求客户端执行临时重定向</td></tr><tr><td>400 Bad Request：</td><td>客户端请求有语法错误，不能被服务器所理解。</td></tr><tr><td>403 Forbidden：</td><td>服务器收到请求，但是拒绝提供服务。</td></tr><tr><td>404 Not Found：</td><td>请求资源不存在，举个例子：输入了错误的URL。</td></tr><tr><td>500 Internal Server Error：</td><td>服务器发生不可预期的错误。</td></tr><tr><td>503 Server Unavailable：</td><td>服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。</td></tr></tbody></table><h1 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h1><h2 id="web服务器概览"><a href="#web服务器概览" class="headerlink" title="web服务器概览"></a>web服务器概览</h2><p><img src="/deng123-dev.github.io/images/pasted-69.png" alt="upload successful"></p><ul><li><p>web服务器：</p><ul><li>web服务器软件是一个服务端软件 </li><li>可以把静态网页部署到web服务器</li><li>web服务器主要运行静态页面 </li></ul></li><li><p>应用服务器：</p><ul><li>应用服务器可以运行动态页面</li></ul></li><li><p>web服务器和应用服务器通常一起使用</p></li><li><p>Web服务器主要 是处理向浏览器发送HTML以供浏览，而应用程序服务器提供访问商业逻辑的途径以供客户端应用程序使用。</p></li></ul><h2 id="常见的web服务器"><a href="#常见的web服务器" class="headerlink" title="常见的web服务器"></a>常见的web服务器</h2><ol><li><p>Apache服务器<br><img src="/deng123-dev.github.io/images/pasted-70.png" alt="upload successful"><br>Apache仍然是世界上用得最多的Web服务器，优势主要在于源代码开放，可以运行在几乎所有的Unix, Windows. Linux系统平台上</p></li><li><p>Nginx服务器</p></li></ol><p><img src="/deng123-dev.github.io/images/pasted-71.png" alt="upload successful"><br>只能运行在Linux/Unix，其特点是占有内存少，并发能力强</p><ol start="3"><li>ISS服务器</li></ol><p><img src="/deng123-dev.github.io/images/pasted-72.png" alt="upload successful"><br>Microsoft的W eb服务器产品为Internet Information Server C IIS ) .  IIS是允许在公共Intranet或Internet上发布信息的Web服务器。IIS只能运行在Microsoft Windows平台</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web基础（1）</title>
      <link href="/deng123-dev.github.io/2020/03/21/web%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/03/21/web%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="网络概览"><a href="#网络概览" class="headerlink" title="网络概览"></a>网络概览</h1><p>终端：用户与计算机进行交互的设备</p><p>网络：是由若干节点和连接这些节点的链路构成，表示诸多对象及其相互联系。</p><h2 id="按拓扑结构分类："><a href="#按拓扑结构分类：" class="headerlink" title="按拓扑结构分类："></a>按拓扑结构分类：</h2><ol><li>总线型</li></ol><p><img src="/deng123-dev.github.io/images/pasted-53.png" alt="upload successful"></p><a id="more"></a><ol start="2"><li>环型</li></ol><p><img src="/deng123-dev.github.io/images/pasted-54.png" alt="upload successful"><br>3. 星型</p><p><img src="/deng123-dev.github.io/images/pasted-55.png" alt="upload successful"><br>4. 树型</p><p><img src="/deng123-dev.github.io/images/pasted-56.png" alt="upload successful"><br>5. 网型</p><p><img src="/deng123-dev.github.io/images/pasted-57.png" alt="upload successful"></p><h2 id="按覆盖范围分"><a href="#按覆盖范围分" class="headerlink" title="按覆盖范围分"></a>按覆盖范围分</h2><ul><li>局域网 LAN</li><li>城域网 MAN</li><li>广域网 WAN<h2 id="网络主要功能"><a href="#网络主要功能" class="headerlink" title="网络主要功能"></a>网络主要功能</h2></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 资源共享</span><br><span class="line">2. 快速传输信息</span><br><span class="line">3. 提高系统可靠性</span><br><span class="line">4. 易于进行分布式处理</span><br><span class="line">5. 综合信息服务</span><br></pre></td></tr></table></figure><h1 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h1><h2 id="OSI（开放式系统互联模型）层次"><a href="#OSI（开放式系统互联模型）层次" class="headerlink" title="OSI（开放式系统互联模型）层次"></a>OSI（开放式系统互联模型）层次</h2><p><img src="/deng123-dev.github.io/images/pasted-58.png" alt="upload successful"></p><p><img src="/deng123-dev.github.io/images/pasted-59.png" alt="upload successful"></p><h2 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h2><p> TCP/IP协议族是一个四层协议系统：<br><img src="/deng123-dev.github.io/images/pasted-60.png" alt="upload successful"></p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><ol><li><p>实现网卡驱动，以处理数据在以太网等物理媒介的传输</p></li><li><p>为上层协议提供一个统一的接口</p></li><li><p>协议应用：</p><ul><li>以太网协议：<br>规定一组电信号就是一个数据包，一个数据包为<strong>一帧</strong>。数据包是从一个网卡发到另一个网卡，<strong>网卡地址</strong>，也就是帧首部所包含的<strong>MAC地址</strong>，具有全球唯一性。<strong>对电信号进行分组并形成具有特定意义的数据帧，然后以广播的形式通过物理介质发送给接收方。</strong></li></ul></li></ol><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ol><li><p>网络层的任务之一使选择这些中间节点，以确定两台主机间的通讯路径</p></li><li><p>其次网络层对上层协议隐藏了网络拓扑联结的细节，在使得传输层看来通讯双方是直接连接的</p></li><li><p>协议应用：</p><ul><li>IP协议：判断两台主机是否处于同一个网络，IP地址目前有两个版本，分别是IPV4，IPV6,IPV4是一个32位地址，常采用4个十进制数字表示。IP协议将这个32位的地址分为两部分，前面部分表示网络地址，后面部分表示该主机在局域网中的地址。由于各类地址的分发不尽相同，以c类地址为例，其中前24位就是网络地址，后8位就是主机地址。因此，<strong>如果两个IP地址在同一子网内，则网络地址一定相同。</strong>为了判断IP地址中的网络地址，IP协议还引入了子网掩码，IP地址和子网掩码通过<strong>按位与</strong>运算后就可以得到网络地址。</li><li>ARP(地址转换协议):根据IP地址获取物理地址的一个TCP/IP协议。</li><li>RARP(逆地址转换协议):允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址。</li><li>路由协议：ARP的MAC寻址还是局限在同一个子网中，因此网络层引入了路由协议，首先通过IP来判断主机是否在同一子网，如果在同一子网，通过ARP协议查询对应的MAC地址，然后以广播形式向子网内的主机发送数据包；如果不在同一子网，以太网会将数据包转发给本子网的网关进行路由。网关是互联网网上子网与子网之间的桥梁，网关进行多次转发，最终将数据包转发到目标IP所在的子网中，然后通过ARP获取目标及MAC,最终发送。</li></ul></li><li><p>IPV4数据包结构：<br><img src="/deng123-dev.github.io/images/pasted-61.png" alt="upload successful"></p></li><li><p>总结:<br>总而言之，网络层的主要工作是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.定义网络地址</span><br><span class="line">2.区分网络</span><br><span class="line">3.子网内MAC寻址</span><br><span class="line">4.对于不同子网数据包进行路由</span><br></pre></td></tr></table></figure><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>协议为网络端点主机上提供可靠、可靠、有效的报文传送服务。其功能紧密以来于网络层的虚拟电路或数据报服务，传输层定义了主机应用程序之间的连通性。传输层的服务要经历<strong><em>连接建立，数据传输,传输连接释放</em></strong>3个阶段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口</span><br></pre></td></tr></table></figure><h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>面向连接的，可靠传输的，有流量控制的，拥塞控制，面向字节流传输等很多优点，在端和端之间通信</p><h5 id="三次握手（面向连接）"><a href="#三次握手（面向连接）" class="headerlink" title="三次握手（面向连接）"></a>三次握手（面向连接）</h5><p>在通信之前，会通过三次握手机制来判断连接是否可用，UDP则不需要，直接传</p></li></ol><p><img src="/deng123-dev.github.io/images/pasted-62.png" alt="upload successful"></p><ul><li>第一次握手：<br>客户端想与服务器连接了，所以状态变为主动打开，同时发送一个连接请求给服务器端SYN=1，并且会携带x个字节过去。发送完请求连接报文后，客户端的状态变为了SYN_SENT，可以说这个状态是等待发送确认(为了发送第三次握手时的确认包)</li></ul><p>(<em>其实就是客户端和服务器谈恋爱，主动给服务器发一个消息，然后等待服务器的回应</em>)</p><ul><li>第二次握手：<br>服务器端收到连接请求报文后，从LSTTEN变为被动打开状态，然后给客户端返回两层报文。一是确认报文，而可以到达告诉客户端，我也打开连接了。发完后，变为SYN_RCVD状态（等待确认状态，等待接收客户端发过来的确认包）</li></ul><p>(<em>服务器这边收到了客户机想谈恋爱的消息，从被动状态变成主动，开始也给客户机发一个暗示客户机服务器想谈恋爱的消息</em>)</p><ul><li>第三次握手：<br>客户得到服务器端的确认知道服务器端也已经准备好了连接后，还会发一个确认报文到服务器端，告诉它，我收到你发送的报文了，接下来我们两个进行连接。客户端发送完确认报文后，进入ESTABLISHED，服务器接到了，也变成了 ESTABLISHED，连接完成。</li></ul><p>(<em>客户机收到了服务器发的消息，明白了服务器的意思，再给服务器发送一个表白的消息，正式的和服务器在一起，客户机和服务器的连接就建立了</em>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以划一波重点：</span><br><span class="line">三次握手的作用：确认双方对对方的收发能力是否正常</span><br></pre></td></tr></table></figure><h5 id="四次握手，关闭连接"><a href="#四次握手，关闭连接" class="headerlink" title="四次握手，关闭连接"></a>四次握手，关闭连接</h5><p><img src="/deng123-dev.github.io/images/pasted-63.png" alt="upload successful"><br>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭<br>(<em>相当一对情侣分手</em>)</p><ul><li><p>客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。<br>(<em>客户端要和服务端分手，就发了一个分手消息给服务端</em>)</p></li><li><p>服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。<br>(<em>服务器收到了这个消息，有点伤心而且不敢相信，发消息给客户端，这时客户端确认服务器收到了要分手的消息</em>)</p></li><li><p>服务器B关闭与客户端A的连接，发送一个FIN给客户端A。</p></li></ul><p>(<em>服务器确认了客户端执意与自己分手，直接与客户端分手并且中断了他们的连接</em>)</p><ul><li>客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。<br>(<em>客户端这时收到服务器发的分手消息，为她送上最后的祝福，同时也让服务器知道客户机收到了她的消息</em>)</li></ul><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><p>UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法<br>其有以下特点：</p><ul><li><p>面向无连接</p></li><li><p>有单播，多播和广播的功能</p></li><li><p>UDP 是面向报文的</p></li><li><p>不可靠性</p></li></ul><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="DNS-域名解析系统"><a href="#DNS-域名解析系统" class="headerlink" title="DNS(域名解析系统)"></a>DNS(域名解析系统)</h4><p>在internet上域名与IP地址一一对应，域名便于人们记忆，但机器之间只认IP地址，他们之间的转换称为<strong><em>域名解析</em></strong>,DNS就是专门用来解析域名解析的服务器</p><h4 id="DHCP-动态主机配置协议"><a href="#DHCP-动态主机配置协议" class="headerlink" title="DHCP(动态主机配置协议)"></a>DHCP(动态主机配置协议)</h4><p>DHCP（动态主机配置协议）是一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。能够动态分配IP地址</p><h4 id="FTP-文件传输协议"><a href="#FTP-文件传输协议" class="headerlink" title="FTP(文件传输协议)"></a>FTP(文件传输协议)</h4><p>用于Internet上的文件控制的双向传输，同时，它也是一个应用程序，TCP协议</p><p>FTP允许用户以文件操作的方式（如文件的增、删、改、查、传送等）与另一主机相互通信。然而， 用户并不真正登录到自己想要存取的计算机上面而成为完全用户， 可用FTP程序访问远程资源， 实现用户往返传输文件、目录管理以及访问电子邮件等等， 即使双方计算机可能配有不同的操作系统和文件存储方式</p><p><strong>ftp默认端口21</strong></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：线性表，栈和队列</title>
      <link href="/deng123-dev.github.io/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%8C%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/deng123-dev.github.io/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%8C%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><hr><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><hr><ul><li>数据结构是相互之间存在一种或多种特定关系的数据元素的集合 <a id="more"></a></li></ul><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><hr><p><strong>从逻辑关系上描述数据，与数据的存储无关</strong></p><ul><li>集合结构</li></ul><p>元素属于同一集合，非线性结构</p><ul><li>线性结构</li></ul><p>除元素属于同一集合，元素之间存在一对一的关系</p><ul><li>树结构</li></ul><p>元素之间存在一对多的关系，非线性结构</p><ul><li>图结构或网状结构</li></ul><p>元素之间存在多对多的关系，非线性结构</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><hr><ul><li>顺序存储结构</li></ul><p>存储器的相对位置来表示数据元素的逻辑关系</p><ul><li>链式存储结构</li></ul><p>数据元素的存放地址是否连续没有要求</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><hr><h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><hr><ul><li>有穷性 </li><li>确定性</li><li>可行性</li><li>输入</li><li>输出<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3></li></ul><hr><ul><li>时间复杂度</li></ul><p>算法计算量的大小</p><ul><li>算法空间复杂度</li></ul><p>算法所需存储空间大小</p><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><hr><ul><li>由n个数据特性相同构成的有限序列称为线性表 </li><li>特点：除第一个和最后一个数据元素，其他元素都有一个直接前驱和一个直接后继</li></ul><h2 id="线性表的顺序存储表示"><a href="#线性表的顺序存储表示" class="headerlink" title="线性表的顺序存储表示"></a>线性表的顺序存储表示</h2><hr><ol><li><p>由一组地址连续的存储单元存储线性表的数据元素</p></li><li><p>数组长度和线性表的长度区别：数组长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的，线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。</p></li><li><p>ASL（平均查找长度）：ASL=∑PiCi (i=1,2,3,…,n),</p></li><li><p>顺序表操作</p><ul><li><p>查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> int findElem (Sqlist L,int e)&#123;    int i;    for (i&#x3D;0,i&lt;L.length,++i)   &#x2F;&#x2F;遍历L长度中的每个位置        </span><br><span class="line"> if(e &#x3D;&#x3D; L.data[i])          &#x2F;&#x2F;获取每个位置对应的值和e值进行判断，这里的等于可以是大于、小于</span><br><span class="line"> return i;                    &#x2F;&#x2F;如果找到与e值相等的值，则返回该值对应的位置</span><br><span class="line">return -1;                        &#x2F;&#x2F;如果找不到，则返回-1&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> int insertElem(Sqlist &amp;L,int p,int e) &#x2F;&#x2F;L是顺序表的长度，要发生变化，所以用引用型&#123;    int i    if (p&lt;0 || p&gt;L.length || L.length&#x3D;&#x3D;maxsize) &#x2F;&#x2F;如果插入e的位置p小于0，或者是大于L的长度，或者是L的长度已经等于了顺序表最大存储空间  </span><br><span class="line"> return 0;</span><br><span class="line"> for (i&#x3D;L.length-1; i&gt;&#x3D;p;--i)    &#x2F;&#x2F;从L中的最后一个元素开始遍历L中位置大于p的每个位置  </span><br><span class="line"> L.data[i+1]&#x3D;L.data[i];    &#x2F;&#x2F;依次将第i个位置的值赋值给i+1    </span><br><span class="line"> L.data[p]&#x3D;e;                  &#x2F;&#x2F;将p位置插入e</span><br><span class="line"></span><br><span class="line">++(L.length);                 &#x2F;&#x2F;L的长度加1  </span><br><span class="line">return 1;                     &#x2F;&#x2F;插入成功，返回1&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int deleteElem (Sqlist &amp;L,int p,int &amp;e)    &#x2F;&#x2F;需要改变的变量用引用型&#123;    int i;    if(p&lt;0 || p&gt;L.length-1)    &#x2F;&#x2F;对位置p进行判断，如果位置不对，则返回0，表示删除失败      </span><br><span class="line">return 0;    </span><br><span class="line">e&#x3D;L.data[p];               &#x2F;&#x2F;将要删除的值赋值给e  </span><br><span class="line">for(i&#x3D;p;i&lt;L.length-1;++i)  &#x2F;&#x2F;从位置p开始，将其后边的元素逐个向前覆盖       </span><br><span class="line">L.data[i]&#x3D;L.data[i+1];</span><br><span class="line">--(L.length)               &#x2F;&#x2F;将表的长度减1</span><br><span class="line">return 1;                  &#x2F;&#x2F;删除成功，返回1&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="线性表的链式存储表示"><a href="#线性表的链式存储表示" class="headerlink" title="线性表的链式存储表示"></a>线性表的链式存储表示</h2><hr><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><hr><ol><li><p>链式线性表定义：由一组任意地址的存储单元存储线性表的数据元素</p></li><li><p>链表的存储密度=单链表数据项所占空间/节点所占空间</p></li><li><p>链表增加头结点作用：</p><ul><li>便于首元节点的处理</li><li>便于空表和非空表的统一处理</li></ul><p><img src="/deng123-dev.github.io/images/pasted-40.png" alt="upload successful"></p></li><li><p>单链表操作</p><ul><li>插入<br>将s插在p后<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;next&#x3D;p-&gt;next;p-&gt;next&#x3D;s;</span><br></pre></td></tr></table></figure></li><li>删除<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next&#x3D;p-&gt;next-&gt;next;</span><br></pre></td></tr></table></figure><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3></li></ul><hr><p>双向链表的结点有两个指针域，一个指向直接前驱，一个指向直接后继</p><ul><li>查找</li></ul><p>在双链表中查找值为x的结点，如果找到，则返回该结点的指针，否则返回NULL值。</p><figure class="highlight plain"><figcaption><span>findNode(DLNode *C,int x)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;    DLNode *p &#x3D; C -&gt; next;   </span><br><span class="line">while(p !&#x3D; NULL)</span><br><span class="line">&#123;  if(p -&gt; data &#x3D;&#x3D; x)</span><br><span class="line">          break;     </span><br><span class="line">p &#x3D; p -&gt; next;    &#125;  </span><br><span class="line">return p;&#125;</span><br></pre></td></tr></table></figure><ul><li>插入</li></ul><p>在双链表中p所指的结点之后插入一个结点s,核心思想就是将p的指向赋值给s,即让s指向p所指,s的前结点就是p,p的后结点就是s,具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s -&gt; next &#x3D; p -&gt; next;</span><br><span class="line">s -&gt; prior &#x3D; p;</span><br><span class="line">p -&gt; next &#x3D; s;</span><br><span class="line">s -&gt; next -&gt; prior &#x3D; s;</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><p>要删除双链表中p结点的后继结点，核心思想就是先将p的后继结点给到q,然后让p指向q的后继结点，q的后继结点的前结点就是p，然后把q释放掉，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  q &#x3D; p -&gt; next;</span><br><span class="line">p -&gt; &#x3D; q -&gt; next;</span><br><span class="line">q -&gt; next -&gt; prior &#x3D; p;</span><br><span class="line">free(q);</span><br></pre></td></tr></table></figure><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1></li></ol><hr><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><hr><ul><li><p><strong>栈是限定仅在表尾进行插入和删除操作的线性表</strong>，我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈，栈又称后进后出的线性表，简称LIFO结构。</p></li><li><p>栈首先是一个线性表，也就是说，栈元素具有线性关系，即前驱后继关系，只不过它是一种特殊的线性表而已。</p></li><li><p>栈的特殊之处在于<strong>限制了这个线性表的插入和删除位置，它始终只在栈顶进行。</strong>这也就使得：栈底是固定的，最先进栈的只能在栈底。</p></li><li><p>栈的插入操作，叫做进栈；栈的删除操作叫做出栈。</p><h3 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h3></li></ul><hr><p><img src="/deng123-dev.github.io/images/pasted-41.png" alt="upload successful"></p><ol><li><p>顺序栈的基本操作</p><ul><li>初始化栈<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int stack[maxsize];int top &#x3D; -1;</span><br></pre></td></tr></table></figure></li><li>元素x进栈<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack[++top] &#x3D; x</span><br></pre></td></tr></table></figure></li><li>元素x出栈<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; stack[top--]</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h3><hr><p><strong>把栈顶放在单链表的头部</strong>，用链表来存储栈的的数据结构称为链栈。<br><img src="/deng123-dev.github.io/images/pasted-42.png" alt="upload successful"></p><ul><li>链栈的插入操作：<br><img src="/deng123-dev.github.io/images/pasted-43.png" alt="upload successful"></li><li>链栈的删除操作</li></ul><p><img src="/deng123-dev.github.io/images/pasted-44.png" alt="upload successful"></p><ol><li>链栈的基本操作：</li></ol><ul><li>元素（指针p所指）进栈操作<br>/<em>类似于头插法建立链表</em>/</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void PushStack(LinkStack top, DataType data)</span><br><span class="line">&#123;</span><br><span class="line">    LStackNode*  p;</span><br><span class="line">    p &#x3D; (LStackNode*)(malloc(sizeof(LStackNode))); </span><br><span class="line">    if (p &#x3D;&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;内存分配失败！\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;data &#x3D; data;</span><br><span class="line">        p-&gt;next &#x3D; top-&gt;next;</span><br><span class="line">        top-&gt;next &#x3D; p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>出栈操作（出栈元素保存在x中）<br>/<em>类似于单链表的删除操作</em>/</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void PopStack(LinkStack top,DataType* data)</span><br><span class="line">&#123;</span><br><span class="line">    LStackNode* p;</span><br><span class="line">    p &#x3D; top-&gt;next;</span><br><span class="line">    if (p&#x3D;&#x3D;NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;栈为空！\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        top-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">        *data &#x3D; p-&gt;data;</span><br><span class="line">        free(p);   &#x2F;&#x2F;释放p指向的结点</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：排序</title>
      <link href="/deng123-dev.github.io/2020/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%8E%92%E5%BA%8F/"/>
      <url>/deng123-dev.github.io/2020/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概叙"><a href="#概叙" class="headerlink" title="概叙"></a>概叙</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-49.png" alt=" "></p><a id="more"></a><p> 相关知识点：</p><ul><li><p>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</p></li><li><p>不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</p></li><li><p>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</p></li><li><p>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数</p></li></ul><p>2.它们之间的性能比较：<br><img src="/deng123-dev.github.io/images/pasted-10.png" alt="upload successful"><br>当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：<code>快速排序``堆排序</code> <code>归并排序</code></p><p>排序有<code>内部排序</code>和<code>外部排序</code>,内部排序是数据记录在<code>内存</code>中进行排序，而外部排序是排序的数据很大，一次不能容纳全部的排序记录，而排序过程中需要访问<code>外存</code></p><p><code>八大排序就是内部排序。</code></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><hr><h3 id="简单插入排序"><a href="#简单插入排序" class="headerlink" title="简单插入排序"></a>简单插入排序</h3><hr><h4 id="算法描述："><a href="#算法描述：" class="headerlink" title="算法描述："></a>算法描述：</h4><hr><ul><li>从第一个元素开始划分出一个有序的序列</li><li>依次取出下一个元素,在已经排序的元素序列中从后向前扫描</li><li>如果已排序元素大于新元素，该元素移到下一个我位置</li><li>重复步骤3，直到找到新元素所在位置</li><li>重复2，5步骤<br><img src="/deng123-dev.github.io/images/pasted-33.png" alt="upload successful"><!-- more --><h4 id="c语言实现："><a href="#c语言实现：" class="headerlink" title="c语言实现："></a>c语言实现：</h4></li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> #直接插入排序</span><br><span class="line"> </span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">void InsertionSort(int* arr,int len)</span><br><span class="line">&#123;</span><br><span class="line">int i ,j;</span><br><span class="line">for (i &#x3D; 1;i &lt;&#x3D; len;i++)</span><br><span class="line">&#123;</span><br><span class="line">j &#x3D; i;</span><br><span class="line">while (j--)</span><br><span class="line">&#123;</span><br><span class="line">if (arr[j - 1] &gt; arr[j])</span><br><span class="line">&#123;</span><br><span class="line">int temp &#x3D; arr[j - 1];</span><br><span class="line">arr[j - 1] &#x3D; arr[j];</span><br><span class="line">arr[j] &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">break;&#x2F;&#x2F;小于退出while循环提高效率</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int arr[] &#x3D; &#123;8,3,9,5,6,7,1,4,0,2&#125;;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">int len &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);</span><br><span class="line">InsertionSort(arr,len);</span><br><span class="line">for (i &#x3D; 0;i &lt; (sizeof(arr) &#x2F; sizeof(arr[0]));i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><hr><h4 id="算法描述：-1"><a href="#算法描述：-1" class="headerlink" title="算法描述："></a>算法描述：</h4><hr><p>又称<strong>缩小增量排序</strong></p><ul><li>选择一个增量序列</li><li>每趟排序，根据对应的增量t，进行两两数据比较，将小的放在前，大的放在后</li><li>重复第二步，直到增量已用尽</li></ul><p><img src="/deng123-dev.github.io/images/pasted-35.png" alt="upload successful"><br>简单选择排序的基本思想：<code>比较+交换</code></p><h4 id="c语言实现：-1"><a href="#c语言实现：-1" class="headerlink" title="c语言实现："></a>c语言实现：</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">void swap(int* L, int* R)</span><br><span class="line">&#123;</span><br><span class="line">int temp &#x3D; *L;</span><br><span class="line">*L &#x3D; *R;</span><br><span class="line">*R &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">void ShellSort(int* arr, int len)</span><br><span class="line">&#123;</span><br><span class="line">for (int gap &#x3D; (len &#x2F; 2); gap &gt; 0;gap &#x2F;&#x3D; 2)&#x2F;&#x2F;设置gap起始间距为长度的一半</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;以gap为间距组从一个组，每次对这个组进行直接插入排序</span><br><span class="line">for (int i &#x3D; gap; i &lt; len;i++)</span><br><span class="line">&#x2F;&#x2F;以gap位置为起始，找到每一个元素以gap间隔为组向前进行直接插入排序</span><br><span class="line">&#123;</span><br><span class="line">int j &#x3D; i;</span><br><span class="line">while ((arr[j]&lt; arr[j - gap]) &amp;&amp; j - gap &gt;&#x3D; 0)</span><br><span class="line">&#123;</span><br><span class="line">swap(&amp;arr[j],&amp;arr[j -gap]);</span><br><span class="line">j -&#x3D; gap;&#x2F;&#x2F;找到之前所有的成员比较并排序</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int arr[] &#x3D; &#123; 8,3,9,5,6,7,1,4,0,2 &#125;;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">int len &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);</span><br><span class="line">ShellSort(arr, len);</span><br><span class="line">for (i &#x3D; 0;i &lt; len;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><hr><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><hr><h4 id="算法描述：-2"><a href="#算法描述：-2" class="headerlink" title="算法描述："></a>算法描述：</h4><hr><ul><li>第一轮从头到尾对n个元素进行两两比较，进行调换位置</li><li>需要对余下的n-1个数据进行从头到尾两两比较直到数据有序为止</li></ul><p><img src="/deng123-dev.github.io/images/pasted-36.png" alt="upload successful"></p><h4 id="c语言实现：-2"><a href="#c语言实现：-2" class="headerlink" title="c语言实现："></a>c语言实现：</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">void bubbleSort(int* arr,int len)</span><br><span class="line">&#123;</span><br><span class="line">int i, j;</span><br><span class="line">for (i &#x3D; 0;i &lt; len - 1;i++)</span><br><span class="line">&#123;</span><br><span class="line">for (j &#x3D; 0;j &lt; len - 1 - i;j++)</span><br><span class="line">&#123;</span><br><span class="line">if (arr[j] &gt; arr[j + 1])</span><br><span class="line">&#123;</span><br><span class="line">int temp &#x3D; arr[j];</span><br><span class="line">arr[j] &#x3D; arr[j + 1];</span><br><span class="line">arr[j + 1] &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int arr[] &#x3D; &#123;6,3,8,7,5,4,1,2,0&#125;;</span><br><span class="line">int len &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);</span><br><span class="line">bubbleSort(arr,len);</span><br><span class="line">for (i &#x3D; 0;i &lt; (sizeof(arr) &#x2F; sizeof(arr[0]));i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><hr><h4 id="算法描述：-3"><a href="#算法描述：-3" class="headerlink" title="算法描述："></a>算法描述：</h4><hr><p><strong>实例排序：</strong></p><p><strong><em>一趟排序结果：{49 38 65 97 76 13 27 49’}</em></strong></p><p><strong><em>二趟排序结果：{27 38 13} 49 {76 97 65 49’}</em></strong></p><p><strong><em>三趟排序结果：{13} 27 {38} 49 {76 97 65 49’}</em></strong></p><p><strong><em>四趟排序结果：13 27 38 49 {49’ 65} 76 {97}</em></strong></p><ul><li>定义low和high指向头尾两个关键数据</li></ul><ul><li>将low所指数据与其后面数据进行比较，如果比其小就把它放在该数据的前面</li></ul><ul><li>将high所指数据与其后面数据进行比较，如果比其大就把它放在该数据的后面</li></ul><ul><li>当low和high指针所指数据重叠时，将数据分为两组，重新设置头尾数据为low和high，重复上述操作，直至数据有序</li></ul><p><img src="/deng123-dev.github.io/images/pasted-37.png" alt="upload successful"></p><h4 id="c语言实现：-3"><a href="#c语言实现：-3" class="headerlink" title="c语言实现："></a>c语言实现：</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;assert.h&gt;</span><br><span class="line"> </span><br><span class="line">void QuickSort(int* arr,int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">int i &#x3D; left; </span><br><span class="line">int j &#x3D; right;</span><br><span class="line">int temp &#x3D; arr[i];</span><br><span class="line"> </span><br><span class="line">if (i &gt;&#x3D; j)</span><br><span class="line">return;</span><br><span class="line"> </span><br><span class="line">while (i !&#x3D; j)</span><br><span class="line">&#123;</span><br><span class="line">while (arr[j] &gt;&#x3D; temp &amp;&amp; i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">if (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] &#x3D; arr[j];</span><br><span class="line">&#125;</span><br><span class="line">while (arr[i] &lt;&#x3D; temp &amp;&amp; i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">if ( i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">arr[j] &#x3D; arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[i] &#x3D; temp;</span><br><span class="line">QuickSort(arr,left,i - 1);</span><br><span class="line">QuickSort(arr, i + 1, right);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int arr[] &#x3D; &#123;8,3,9,5,6,7,1,4,0,2&#125;;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">int len &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);</span><br><span class="line">QuickSort(arr,0,len - 1);</span><br><span class="line">for (i &#x3D; 0;i &lt; len ;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><hr><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><hr><h4 id="算法描述：-4"><a href="#算法描述：-4" class="headerlink" title="算法描述："></a>算法描述：</h4><hr><ul><li>在第一个位置开始从数组找到最小的数据</li></ul><ul><li>往下一个位置开始找到数组中最小的数据 </li></ul><ul><li>重复第二步，直到数组有序为止</li></ul><p><img src="/deng123-dev.github.io/images/pasted-38.png" alt="upload successful"></p><h4 id="c语言实现：-4"><a href="#c语言实现：-4" class="headerlink" title="c语言实现："></a>c语言实现：</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">void SelectionSort(int* arr, int len)</span><br><span class="line">&#123;</span><br><span class="line">int min;&#x2F;&#x2F;保存当前最小数字下标</span><br><span class="line">for (int i &#x3D; 0;i &lt; len - 1;i++)</span><br><span class="line">&#123;</span><br><span class="line">min &#x3D; i;</span><br><span class="line">for (int j &#x3D; i + 1;j &lt; len; j++)</span><br><span class="line">&#123;</span><br><span class="line">if (arr[min] &gt; arr[j])</span><br><span class="line">&#123;</span><br><span class="line">min &#x3D; j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int temp &#x3D; arr[min];</span><br><span class="line">arr[min] &#x3D; arr[i];</span><br><span class="line">arr[i] &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int arr[] &#x3D; &#123;8,3,9,5,6,7,1,4,0,2&#125;;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">int len &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);</span><br><span class="line">SelectionSort(arr,len);</span><br><span class="line">for (i &#x3D; 0;i &lt; len ;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><hr><h4 id="算法描述：-5"><a href="#算法描述：-5" class="headerlink" title="算法描述："></a>算法描述：</h4><hr><p>堆就是用数组实现的二叉树，所以没有父指针或字指针</p><p>堆分为两种：<strong>最大堆</strong> 和<strong>最小堆</strong></p><p>两者区别：</p><p>节点的值比每一个子节点的值都要大</p><p>节点的值比每一个子节点的值都要小</p><p>鉴于最大堆和最小堆是对称关系，理解其中一种即可。所以接下来我们为你们说明一下最大堆的排序</p><p>最大堆进行升序排序的思想：<br>1.<br>初始化堆：将数列a[1..n]构成最大堆</p><p>2.<br>交换数据：将a[1]和a[n] 交换，使a[n]是a[1…n]中的最大值；然后将a[1…n-1]重新调整为最大堆。 接着，将a[1]和a[n-1]交换，使a[n-1]是a[1…n-1]中的最大值；然后将a[1…n-2]重新调整为最大值。 依次类推，直到整个数列都是有序的。</p><h4 id="c语言实现：-5"><a href="#c语言实现：-5" class="headerlink" title="c语言实现："></a>c语言实现：</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;assert.h&gt;</span><br><span class="line">void AdjustHead(int *arr, int parent, int len)</span><br><span class="line">&#123;&#x2F;&#x2F;大堆</span><br><span class="line">assert(arr);</span><br><span class="line">int child &#x3D; parent * 2 + 1;</span><br><span class="line">while (child &lt; len)</span><br><span class="line">&#123;</span><br><span class="line">if (arr[child] &lt; arr[child + 1] &amp;&amp; child + 1 &lt; len)</span><br><span class="line">&#123;</span><br><span class="line">child +&#x3D; 1;&#x2F;&#x2F;左子树小于右子树交且合法时交换</span><br><span class="line">&#125;</span><br><span class="line">if (arr[child] &gt; arr[parent])</span><br><span class="line">&#123;&#x2F;&#x2F;将大值交给父亲节点</span><br><span class="line">int temp &#x3D; arr[child];</span><br><span class="line">arr[child] &#x3D; arr[parent];</span><br><span class="line">arr[parent] &#x3D; temp;</span><br><span class="line">&#x2F;&#x2F;复位，再次判断，防止左右孩子都大于双亲</span><br><span class="line">parent &#x3D; child;</span><br><span class="line">child &#x3D; parent * 2 + 1;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">return;&#x2F;&#x2F;不满足退出</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void HeapSort(int* arr, int len)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;建堆</span><br><span class="line">int root &#x3D; (len - 2) &gt;&gt; 1;&#x2F;&#x2F;找到最后一个非叶子节点</span><br><span class="line">for (root;root &gt;&#x3D; 0;--root)</span><br><span class="line">&#123;</span><br><span class="line">AdjustHead(arr, root, len);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;排序</span><br><span class="line">int end &#x3D; len - 1;</span><br><span class="line">while (end)</span><br><span class="line">&#123;</span><br><span class="line">int temp &#x3D; arr[0];</span><br><span class="line">arr[0] &#x3D; arr[end];</span><br><span class="line">arr[end] &#x3D; temp;</span><br><span class="line">&#x2F;&#x2F;循环排序每一个元素</span><br><span class="line">AdjustHead(arr,0,end);</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int arr[] &#x3D; &#123;8,3,9,5,6,7,1,4,0,2&#125;;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">int len &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);</span><br><span class="line">HeapSort(arr,len);</span><br><span class="line">for (i &#x3D; 0;i &lt; len ;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><hr><h3 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h3><hr><h4 id="算法描述：-6"><a href="#算法描述：-6" class="headerlink" title="算法描述："></a>算法描述：</h4><hr><ul><li>将长度为n的输入序列分为长度为n/2的子序列</li><li>对两个子序列分别采用归并排序</li><li>将两个排序号的子序列合并成一个最终的排序序列</li></ul><p><img src="/deng123-dev.github.io/images/pasted-39.png" alt="upload successful"></p><h4 id="c语言实现：-6"><a href="#c语言实现：-6" class="headerlink" title="c语言实现："></a>c语言实现：</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;assert.h&gt;</span><br><span class="line">&#x2F;&#x2F;合并</span><br><span class="line">void Merge(int* arr, int low, int mid, int high)</span><br><span class="line">&#123;</span><br><span class="line">int i &#x3D; low;&#x2F;&#x2F;第一组下标</span><br><span class="line">int j &#x3D; mid + 1;&#x2F;&#x2F;第二组下标</span><br><span class="line">int k &#x3D; 0;</span><br><span class="line">int arr2[100] &#x3D; &#123;0&#125;;&#x2F;&#x2F;临时排序存放序列</span><br><span class="line">&#x2F;&#x2F;循环判断arr[i]和arr[j]的值，谁小谁放在arr2中</span><br><span class="line">while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; high)</span><br><span class="line">&#123;</span><br><span class="line">if (arr[i] &lt;&#x3D; arr[j])</span><br><span class="line">&#123;</span><br><span class="line">arr2[k] &#x3D; arr[i];</span><br><span class="line">i++;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">arr2[k] &#x3D; arr[j];</span><br><span class="line">j++;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;当至少一组放完后，剩下的全部按顺序放入arr2（已经有序的数组）</span><br><span class="line">&#x2F;&#x2F;最后一组元素可能不过正常数量</span><br><span class="line">    while (i &lt;&#x3D; mid)</span><br><span class="line">&#123;</span><br><span class="line">arr2[k] &#x3D; arr[i];</span><br><span class="line">i++;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">while (j &lt;&#x3D; high)</span><br><span class="line">&#123;</span><br><span class="line">arr2[k] &#x3D; arr[j];</span><br><span class="line">j++;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;将arr2中的序列复制到arr中</span><br><span class="line">for (k &#x3D; 0, i &#x3D; low;i &lt;&#x3D; high;i++, k++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] &#x3D; arr2[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void MergeSort(int *arr, int len)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;间隔增加（gap就是一组几个元素）</span><br><span class="line">for( int gap &#x3D; 1;gap &lt; len;gap &#x3D; (gap * 2) )</span><br><span class="line">&#123;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;从间隔gap开始排序</span><br><span class="line">for (i &#x3D; 0;i + 2*gap - 1 &lt; len;i &#x3D; i + 2*gap)</span><br><span class="line">&#123;</span><br><span class="line">Merge(arr, i , i + gap - 1 , i + 2*gap - 1 );</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;当gap大于len的一半时，排序for无法排序的两个子组</span><br><span class="line">if (i + gap - 1 &lt; len) </span><br><span class="line">&#123;</span><br><span class="line">Merge(arr, i, i + gap - 1, len - 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int arr[] &#x3D; &#123;8,3,9,5,6,7,1,4,0,2&#125;;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">int len &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);</span><br><span class="line">MergeSort(arr,len );</span><br><span class="line">for (i &#x3D; 0;i &lt; len;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
