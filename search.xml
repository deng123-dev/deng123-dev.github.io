<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>软件构造概要（3）</title>
      <link href="/deng123-dev.github.io/2021/01/02/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E6%A6%82%E8%A6%81%EF%BC%883%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2021/01/02/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E6%A6%82%E8%A6%81%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="GUI软件构造"><a href="#GUI软件构造" class="headerlink" title="GUI软件构造"></a>GUI软件构造</h1><hr><ul><li><p>基本的GUI设计规范</p><ul><li><p>界面合理</p><p>要求有合理的布局和颜色搭配</p><a id="more"></a>  </li><li><p>风格一致</p><p>GUI应采用标准的组件、明确定义的术语，和用户的习惯和知识领域一致</p></li><li><p>元素标准</p><ul><li><p>窗口与对话框的标准</p></li><li><p>菜单和工具条的标准</p></li><li><p>图标的标准</p></li><li><p>基本组件的标准</p></li></ul></li></ul></li><li><p>GUI设计原则</p><ul><li><p>关注用户及其任务，而不是技术</p></li><li><p>首先考虑功能，然后才是表示</p></li><li><p>对任务的看法与用户保持一致</p></li><li><p>设计要符合常见情况</p></li><li><p>不要分散用户对目标注意力</p></li><li><p>促进学习</p></li><li><p>传递信息，而不仅仅是数据</p></li><li><p>设计应满足响应需求</p></li><li><p>通过用户试用发现改正错误</p></li></ul></li><li><p>事件驱动编程</p><p>主要用于GUI和其他为响应用户的交互做出特定动作的应用程序。在事件驱动编程的应用中，通常有一个监听事件的主循环，一旦监测到其中一个事件，就出发函数调用，执行相应的动作。事件驱动编程可以理解为实现MVC模式的一种技术方案，其适用于用户需求需要经常改变的应用程序</p></li></ul><h1 id="应用数据库"><a href="#应用数据库" class="headerlink" title="应用数据库"></a>应用数据库</h1><hr><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><hr><ul><li>码</li></ul><p>元组中的每一个分量依赖于其所在元组的标识</p><ul><li>候选码</li></ul><p>若关系中的某一属性组的值能唯一地标识一个元组，该属性组为候选码</p><ul><li>主码<br>若一个关系可以有多个候选码，则选择一个作为主码</li></ul><ul><li><p>事务</p><p>数据库应用程序的基本逻辑单元，是一个不可切分的基本单元</p></li><li><p>游标</p><p>系统为用户开设的一个数据缓冲区，用于存放sql语句的执行结果  </p></li><li><p>存储过程</p><p>在数据库系统中，一组为完成特定功能的SQL语句集，存储在数据库中，经过第一次编译后调用时不需要再次编译，用户通过指定存储过程的名字并给出参数来执行存储过程</p></li></ul><h2 id="数据库完整性约束"><a href="#数据库完整性约束" class="headerlink" title="数据库完整性约束"></a>数据库完整性约束</h2><hr><ul><li><p>实体完整性约束</p><p>若属性A是基本关系R的主属性，则A不能取空值</p></li><li><p>参照完整性</p><p>若属性或属性组F是基本关系R的外码，它与基本关系S的主码Ks相对应，则对于R中的每个元组在F上的值必须是空值或者等于S中某个元组的主码值</p></li><li><p>用户自定义完整性</p><p>满足用户对数据之间特定的约束条件</p></li></ul><h2 id="数据库编程及其连接方式"><a href="#数据库编程及其连接方式" class="headerlink" title="数据库编程及其连接方式"></a>数据库编程及其连接方式</h2><hr><p> JAVA中使用中间件JDBC（一种执行SQL语句的JAVA API）连接编程语言和数据库，其由一组用JAVA语言编写的类和接口组成，可为多种数据库提供统一访问</p><p> 使用JDBC操作数据库的步骤是</p><ul><li><p>与数据库建立连接</p></li><li><p>向数据库发送SQL语句，需要java.sql的支持</p></li><li><p>处理sql语句的返回结果</p><h1 id="基于复用的软件构造"><a href="#基于复用的软件构造" class="headerlink" title="基于复用的软件构造"></a>基于复用的软件构造</h1></li></ul><hr><ul><li><p>软件复用概念</p><p>在两次或多次不同的软件开发过程中重复使用相同或相近的软件模块的过程</p></li><li><p>可复用件类型</p><ul><li><p>通用构件</p><p>在程序设计语言的基础上提供通用的支持,如JAVA中的math包</p></li><li><p>特殊领域构件</p><p>完成软件产品应用领域的特殊功能，如图像处理、图像压缩、图像分析</p></li><li><p>特殊应用代码</p><p>只服务于当前开发的应用程序</p></li></ul></li><li><p>软件复用主要问题</p><ul><li><p>必须有可复用对象</p></li><li><p>所复用对象必须是有用的</p></li><li><p>复用者需要知道如何使用被复用的对象</p></li></ul></li><li><p>软件复用基本类型</p><ul><li><p>产品复用 </p><p>复用已有的软构件，通过构件集成得到新系统</p></li><li><p>过程复用</p><p>复用已有的软件开发过程，使用可复用的应用生成器来自动或半自动地生成所需系统</p></li></ul></li></ul><ul><li><p>设计模式</p><ul><li><p>基本概念</p><p>对给定环境下反复出现地问题一个通用的、可复用地方案</p></li><li><p>考虑因素</p><p> 模式名称、解决问题、设计元素及其之间的交互</p></li></ul></li><li><p>框架</p><ul><li>基本概念</li></ul><p>模式本身可能不足以开发一个完整的设计。在某些情况下，还需要为设计工作提供与实现相关的架构基础设施</p><ul><li><p>设计模式和框架的区别 </p><ul><li><p>设计模式</p><p>设计复用，对在某种环境中反复出现问题及解决方案的描述，适用于各个领域，比框架抽象</p></li><li><p>框架</p><p>部分代码复用，部分设计复用，一个框架往往含有一个或多个设计模式，针对某一特定领域</p></li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件构造概要（2）</title>
      <link href="/deng123-dev.github.io/2021/01/01/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E6%A6%82%E8%A6%81%EF%BC%882%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2021/01/01/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E6%A6%82%E8%A6%81%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="数据处理的软件构造"><a href="#数据处理的软件构造" class="headerlink" title="数据处理的软件构造"></a>数据处理的软件构造</h1><hr><h2 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h2><hr><ul><li>数据持久性</li></ul><p>数据能够长期存储的能力</p><a id="more"></a><ul><li>测试覆盖</li></ul><p>指测试系统覆盖被测试系统的程度</p><ul><li>语句覆盖</li></ul><p>设计测试用例，判断程序的每条语句是否都能执行</p><ul><li>路径覆盖</li></ul><p>要同时满足条件覆盖和判定覆盖</p><ul><li>判定覆盖</li></ul><p>设计测试用例，使得程序种的每个判断的分值都至少经历一次</p><ul><li>条件覆盖</li></ul><p>设计测试用例，使得程序中的简单布尔条件的所有可能值都至少满足一次</p><h2 id="防御性编程"><a href="#防御性编程" class="headerlink" title="防御性编程"></a>防御性编程</h2><hr><ul><li>基本思想</li></ul><p>程序员要预见其他程序员的过错，无效的输入，甚至有害的数据及使用者的过失，采取适当的措施保护自己的程序</p><ul><li><p>基本原则 </p><p>检查每个输入参数的数据</p></li><li><p>处理方法</p><ul><li><p>处理错误</p></li><li><p>使用异常</p></li></ul></li></ul><h2 id="表驱动编程"><a href="#表驱动编程" class="headerlink" title="表驱动编程"></a>表驱动编程</h2><hr><ul><li>什么是表驱动编程</li></ul><p>算式基的计算把加法、减法算式的约束条件，以及算式产生的信息都放在了一张表中，使程序在表中通过选择条件得到算式及其运算结果。如此编写程序的方式叫做表驱动编程</p><ul><li><p>使用表编程方法需考虑元素</p><ul><li><p>表项的内容</p></li><li><p>表项的查询</p><ul><li><p>直接访问</p><p>通过数组下标或矩阵下标直接访问表</p></li><li><p>阶梯访问</p><p>表中的项表示一个数据范围而不是对应不同的数据，而且数据的排序按照一定顺序</p></li><li><p>索引访问</p><p>首先为查询的数据建立一个索引表，用索引数据在索引表中找到关键字</p></li></ul></li></ul></li></ul><h1 id="用户交互的软件构造"><a href="#用户交互的软件构造" class="headerlink" title="用户交互的软件构造"></a>用户交互的软件构造</h1><hr><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><hr><ul><li><p>用户界面</p><p>如何把一组功能合理地组织并呈现给用户使用</p></li><li><p>用户交互</p><p>有关交互式计算机系统地设计、评估、实现等相关现象地学科</p></li><li><p>可用性</p><p>可用性是在某个考察时间，系统能够正常运行的概率</p></li><li><p>软件原型</p><p>目标系统地一个初步状态、形式或实例，为系统地以后阶段当作模型</p></li></ul><ul><li><p>软件集成</p><p>将多个软件地功能集合到一个软件上</p></li><li><p>功能集成</p><p>把具有不同功能的程序或模块关联起来</p></li><li><p>界面集成</p><p>具有不同功能的程序或模块提供一个统一的用户交互界面</p></li></ul><ul><li><p>自底向上集成</p><p>选择独立性最大或对其他模块依赖性最小的模块开始，从程序底部开始，逐次增加控制模块，直至完成整个程序</p></li><li><p>自顶向下集成</p><p>集成模块从根部的控制模块开始，以控制层次的顺序，逐次增加模块，直至形成整个系统的过程</p></li><li><p>增量式集成</p></li></ul><p>以一个基本模块或主模块为基础，每次增加一个或一组模块形成程序，直至所有模块都集成至部分程序构成软件整体</p><ul><li>持续集成</li></ul><p>软件开发过程中对程序频繁集成</p><ul><li><p>驱动程序</p><p>驱动模块的使命就是根据测试用例的设计去调用被测试模块，并且判断被测试模块的返回值是否与测试用例的预期结果相符</p></li><li><p>桩程序</p><p>桩模块的使命除了使得程序能够编译通过之外，还需要模拟返回被代替的模块的各种可能返回值</p></li><li><p>回归测试</p><p>复用之前的测试对集成后的软件或其中的某个子集重新测试，以确保修改的模块或其他程序变更没有传播不期望的副作用</p></li></ul><ul><li><p>软件建模</p><p>对客观进行有必要的抽象和简化，进行软件模型建立的过程</p><h2 id="交互设计的8条黄金规则"><a href="#交互设计的8条黄金规则" class="headerlink" title="交互设计的8条黄金规则"></a>交互设计的8条黄金规则</h2></li></ul><hr><ul><li><p>尽量保持一致</p></li><li><p>满足普遍的可用性</p></li><li><p>提供信息反馈</p></li><li><p>设计对话框以产生结束消息</p></li><li><p>预防并成立错误</p></li><li><p>允许撤销错位</p></li><li><p>支持内部控制点</p></li><li><p>减轻短时记忆负担</p></li></ul><h2 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a>静态测试</h2><hr><ul><li><p>什么是静态测试</p><p>静态测试不执行程序，而是通过阅读和分析代码及相关资料、发现软件错误的活动。静态测试又称人工手动测试</p></li><li><p>有哪些常见的静态测试</p><ul><li><p>桌面检查</p><p>程序员个人模拟计算机“阅读”程序，发现代码错误的方法</p></li><li><p>代码走查</p><p>两人进行，一人协调走查，另一人扮演测试者</p></li><li><p>正式审查</p><p>一种正式的结构化检查和评估方法，一般有计划、流程、结果和追查</p></li><li><p>同行审查</p><p> 对代码的全面质量审查，包括代码的可维护性、可扩展性、可使用性，以及安全和编程规范是否得到遵守，是软件开发队伍对程序质量和信赖性的自我评估</p></li><li><p>检查表</p><p>正式审查和同行评审都需要检查表。它们列出了容易出现的典型错误</p></li></ul></li></ul><h2 id="基于模型的测试"><a href="#基于模型的测试" class="headerlink" title="基于模型的测试"></a>基于模型的测试</h2><hr><p>将软件建模用于软件测试中，模型是对软件的抽象，有限状态图和场景模型在超越语句、函数等程序组成的抽象层次，从用户的角度、模块间的动态交互行为来刻画程序，适用于集成测试的用例设计</p><h1 id="代码重构和交付"><a href="#代码重构和交付" class="headerlink" title="代码重构和交付"></a>代码重构和交付</h1><hr><ul><li>什么是代码重构</li></ul><p>在不改变软件外部行为的前提下改善它的内部结构</p><ul><li>代码重构的3个时机</li></ul><p>给程序增量添加功能时、定位错误时、评审代码时</p><ul><li><p>测试阶段和内容</p><ul><li>单元测试</li></ul><p>对组成程序基本单元进行测试</p><ul><li>集成测试</li></ul><p>对两个或两个以上相互关联的程序单元进行测试</p><ul><li>系统测试</li></ul><p>把整个软件视为一个完整的系统，对其测试</p><ul><li><p>验收测试</p><p>确保软件准备就绪，可以在用户的环境让最终用户将其用于执行软件的既定功能和任务</p></li></ul></li></ul><ul><li>测试驱动开发</li></ul><p>一种不同于传统的软件开发流程的新型开发方式。它要求在编写某个功能的代码前先编写测试代码，然后只编写使测试通过的代码，通过测试推动整个软件的开发，有助于编写简洁可用和高质量的代码，加速开发过程</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式概要</title>
      <link href="/deng123-dev.github.io/2020/12/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/deng123-dev.github.io/2020/12/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h1><hr><ul><li>单一职责原则</li></ul><p>又称单一功能原则，面向对象五个基本原则之一，<strong><em>它规定一个类应该只有一个发生变化的原因</em></strong></p><a id="more"></a><p>所谓职责是指类发生变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。</p><p><strong>此原则的核心就是解耦和增强内聚性。</strong></p><ul><li>开闭原则</li></ul><p><strong><em>软件中的对象应该对于扩展是开放的，但对于修改是封闭的，</em></strong></p><p>这意味着一个实体是允许在不改变它的源代码的前提下变更它的行为，改变源代码需要一系列复杂的过程，遵循该原则的程序扩展时并不发生变化，因此无需上述复杂的过程</p><ul><li>里氏代换原则</li></ul><p><strong><em>任何基类可以出现的地方，子类一定可以出现.</em></strong></p><p>继承复用的基石。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><ul><li>依赖倒置原则</li></ul><p><strong><em>程序要依赖于抽象接口，不要依赖于具体实现</em></strong></p><p>要求对抽象进行编程，而不是对实现进行编程，降低了客户与事先模块间的耦合</p><ul><li>接口隔离原则</li></ul><p><strong><em>类不应该依赖于它不需要的接口。一个类对另一个类的依赖应该建立在最小的接口上</em></strong></p><h1 id="几种设计模式"><a href="#几种设计模式" class="headerlink" title="几种设计模式"></a>几种设计模式</h1><hr><ul><li><p>工厂模式</p><p>  <strong><em>实例化对象模式，是用工厂方法代替new操作的一种模式</em></strong></p><p>  当创建实例时所作的初始化工作较复杂时，可以创建工厂，将创建实例的工作与使用实例的工作分开。</p><p>  工厂模式又分为<strong>简单工厂</strong>和<strong>抽象工厂</strong>，这两个模式区别在于需要创建对象的复杂程度上</p></li><li><p>命令模式</p><p><strong><em>将一组行为抽象为对象，实现行为请求者和行为实行者之间的松耦合。</em></strong></p><ul><li><p>命令模式的本质是对命令进行封装</p></li><li><p>每一个命令都是一个操作</p></li><li><p>命令模式使得请求的一方不必知道接受请求一方的接口</p></li><li><p>使请求本身成为一个对象</p></li><li><p>命令模式的关键在于引入抽象命令接口</p></li></ul></li></ul><ul><li>适配器模式</li></ul><p><strong><em>适配器模式将一个类的接口适配成用户所期待的</em></strong>，<br>一个适配允许通常因为接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中<br>共有两类适配器模型：</p><p>1.对象适配器</p><p>在这种适配器模式中，适配器容纳一个它包裹的类的实例。在这种情况下，适配器调用被包裹对象的物理实体</p><p>2.类适配器</p><p>在这种适配器模式下，适配器继承自已实现的类（一般多重继承）</p><ul><li>观察者模式</li></ul><p>有时也被称为模型-视图模式，<strong><em>观察者模式是一种对象行为模式。它定义对象之间的一对多的依赖关系，当一个对象的状态改变时，所有依赖于它的对象都得到通知并自动更新</em></strong></p><p>观察者模式的主要的作用就是对对象解耦，将观察者和被观察者完全隔离。</p><ul><li>迭代器模式</li></ul><p>提供一种方法顺序访问一个聚合对象中的各种元素，而有不暴露对象的内部表示</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件构造概要（1）</title>
      <link href="/deng123-dev.github.io/2020/12/30/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E6%A6%82%E8%AE%BA/"/>
      <url>/deng123-dev.github.io/2020/12/30/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h1><hr><h2 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h2><hr><ul><li>程序</li></ul><p>为了解决某个特定问题而用程序设计语言描述的适合计算机处理的语句序列</p><ul><li>软件</li></ul><p>程序和程序设计发展到一定规模后并且在逐步商业化的过程中形成的</p><a id="more"></a><ul><li>软件生存周期</li></ul><p>一个软件从出生到消亡的整个周期时间</p><ul><li>软件过程</li></ul><p>把软件开发工作分成若干个都有特定结果的步骤或活动，按照一定方式开展软件活动</p><ul><li>需求定义</li></ul><p>研究用户需求、确定软件定义</p><ul><li>软件设计</li></ul><p>为达到某一目的，通过制定计划、进行思考，建立一个可行的方案，并用程序设计语言明确表示整个过程</p><ul><li>软件维护</li></ul><p>对已开发并发布、交付使用的软件产品进行完善、纠正错误、改进性能</p><ul><li>CMMI（Capability Maturity Model Integer）</li></ul><p>软件能力成熟度模型</p><ul><li>TSP（Team Software Process）</li></ul><p>团队软件过程</p><ul><li>PSP（Personal Software Process）</li></ul><p>个体软件过程</p><ul><li>Scrum</li></ul><p>一个用于开发和维护复杂软件产品的框架</p><ul><li>IDE</li></ul><p>开发集成环境</p><ul><li>软件构造</li></ul><p>通过编码、验证、单元测试、集成测试和调试的组合，详细地创建可工作、有意义地软件。</p><ul><li>声明式语言</li></ul><p>告诉计算机做什么地高级语言</p><ul><li>原则</li></ul><p>一个已接受并专业化地指导行动的最高标准或准则</p><ul><li>机制</li></ul><p>指的是有机体的构造、功能机器相关关系、工作原理</p><ul><li>方法</li></ul><p>获得一个客体的过程</p><ul><li>最佳实践</li></ul><p>存在某种技术、方法、过程、活动或机制，可以使生产达到最优</p><ul><li>问题空间</li></ul><p>问题，用户需求和待开发的应用软件</p><ul><li>解空间</li></ul><p>针对问题空间的所有解</p><h2 id="软件开发过程的类型"><a href="#软件开发过程的类型" class="headerlink" title="软件开发过程的类型"></a>软件开发过程的类型</h2><hr><ul><li><p>瀑布开发</p><ul><li><p>概念 </p><p>也叫软件生存期模型，把开发分成6个基本活动，并规定了它们自上而下、相互连接的固定次序，如同瀑布逐级下落。该开发过程是当前活动接受上一项活动的工作结果，验证并将其作为自己的输入，然后实施完成所需的工作内容，如此反复循环</p></li><li><p>特点</p><p>每个阶段不能省略；产生大量文档，增加工作量；只有等末期才能看到开发成果；早期的错误要等到后期的测试阶段才能发现  </p></li><li><p>适合的软件类型</p><p>强调文档、分层结构清晰，变化需求不易变的软件</p></li></ul></li><li><p>敏捷开发</p><ul><li>概念</li></ul><p>可以应对快速变化的需求的一种软件开发能力，采用迭代、循序渐进的方法进行软件开发，它是把一个大项目分成多个相互联系、但也可以独立运行的小项目，分别完成，此过程中软件一直是可使用的状态。</p><ul><li>特点</li></ul><p>能快速适应需求的变动；能让客户参与；迭代；小版本</p><ul><li>适合的软件类型</li></ul><p>软件需求可能随时改变的软件</p></li></ul><h2 id="程序设计和软件开发"><a href="#程序设计和软件开发" class="headerlink" title="程序设计和软件开发"></a>程序设计和软件开发</h2><hr><ul><li><p>程序设计</p><p>程序设计是解决特定问题而编写程序的过程，“程序=数据结构+算法”，程序设计的活动包括分析、编码、测试、排错等阶段；程序设计是个人的科学。</p></li><li><p>软件开发</p><p> 软件开发包括程序设计、数据库设计、用户界面设计、软件接口设计和各种复杂的配置；软件开需要团队的分工合作，采用工程化的方法，按照项目进度完成开发</p></li></ul><h2 id="软件构造活动的前提"><a href="#软件构造活动的前提" class="headerlink" title="软件构造活动的前提"></a>软件构造活动的前提</h2><ul><li><p>选择合适的编程语言</p></li><li><p>编程工具和集成开发环境</p></li><li><p>软件运行环境</p></li><li><p>软件开发的最佳实践</p></li></ul><h2 id="技术理解"><a href="#技术理解" class="headerlink" title="技术理解"></a>技术理解</h2><ul><li>设计模式</li></ul><p>对软件设计中普遍存在的问题所提出的解决方案</p><ul><li>结对编程</li></ul><p>一种敏捷软件开发方法，两个程序员在一个计算机上共同工作。一个人输入代码，而另一个人审查他输入的每一行代码；特点是增加纪律性，写出更好的代码等</p><ul><li>重构</li></ul><p>就是通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性。特点是改进软件设计使软件更容易被理解，帮你找到bug，提高软件的开发速度</p><ul><li>持续集成</li></ul><p>团队开发成员经常集成他们的工作，以发现集成当中的错误</p><ul><li>意图导向编程</li></ul><p>每一个问题都可以分解成一系列的功能性步骤，在写代码的过程中，会按照顺序有意识的去完成每一个步骤；而意图导向编程则是先假设每一个步骤都有一个理想的方法来完成，而不关注每个步骤的具体实现，在这种情况下，需要关心的是每个方法的输入参数，返回值以及什么样的名字最符合它的含义。</p><h1 id="模块化软件构造"><a href="#模块化软件构造" class="headerlink" title="模块化软件构造"></a>模块化软件构造</h1><hr><h2 id="概念理解-1"><a href="#概念理解-1" class="headerlink" title="概念理解"></a>概念理解</h2><hr><ul><li>分解</li></ul><p>将一个大的问题划分成一个个相对简单、独立的问题，运用合适的方法分别解决</p><ul><li>模块化</li></ul><p>把问题分解成容易理解、便于控制、便于实现的子问题的一个重要手段</p><ul><li>逐步求精</li></ul><p>每一步程序的抽象程度都越来越低</p><ul><li>软件测试</li></ul><p>使用人工或自动手段来运行或测定某个系统的过程，以检测它是否满足预定的需求</p><ul><li>测试需求</li></ul><p>分析用户需求和设计，梳理不当需求，明确，细化和罗列出需求，并且将每个用户需求表示成可以检测的需求</p><ul><li>测试设计</li></ul><p>包括测试用例设计，是否实施所有层次的测试，是否采用测试工具或自动化测试框架、哪些测试采用哪些工具、如何组织人员进行测试</p><ul><li>测试覆盖</li></ul><p>指测试系统覆盖被测试系统的程度，一项给定测试或一组测试对某个给定系统或构件的所有指定测试用例进行处理所达到的程度</p><ul><li>软件调试</li></ul><p>当程序不能编译运行或者测试后发现错误了，程序员要发现可能的错误并且去除他，这个过程叫做调试</p><ul><li>缺陷</li></ul><p>软件bug，软件产品中存在的问题</p><ul><li>软件质量</li></ul><p>许多质量属性的综合体现，各种质量属性反映了软件质量的不同方面，包括可用性、功能性、可靠性、效率、可移植性、可维护性</p><ul><li>编程风格</li></ul><p>如何使用命名标识符、注释程序、编排程序格式等</p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><hr><ul><li><p>基本原则</p><ul><li>模块可分解性</li><li>模块可组装性 </li><li>模块可理解性</li><li>模块连续性</li><li>模块保护性</li></ul></li><li><p>模块化的作用 </p></li></ul><p>程序模块化可以把复杂的问题简单化</p><ul><li><p>模块内聚性</p><p>内聚性是对一个模块内部各个组成元素之间相互结合的紧密程度的度量指标。<br>下列是7种不同的内聚：（内聚度从弱到强）</p><p>偶然内聚；逻辑内聚；时间内聚；过程内聚；通信内聚；顺序内聚；功能内聚</p></li></ul><ul><li><p>模块耦合性</p><p>耦合性是一个模块与系统内其他模块及外部世界的关联程度的度量。<br>下列是7种不同的耦合：（耦合度从低到高）</p><p>非直接耦合；数据耦合；标记耦合；控制耦合；外部耦合；公共耦合；内容耦合</p><h1 id="面向对象的软件构造"><a href="#面向对象的软件构造" class="headerlink" title="面向对象的软件构造"></a>面向对象的软件构造</h1></li></ul><hr><h2 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h2><hr><ul><li><p>抽象</p><p>对一个过程或一件事物的某些细节有目的的隐藏，以便把其他方面、细节或结构表达的更清楚</p></li><li><p>封装</p><p>把一个事物的性质和行为结合在一起成为构件，对外形成该事物的界限；信息隐蔽</p></li><li><p>信息隐蔽</p><p>外界不能直接存取构件的内部信息及隐藏起来的操作</p></li><li><p>抽象数据类型</p><p>与表示无关的数据类型，是一个数据类型及定义在该模型上的一组操作 </p></li><li><p>分类</p><p>试图把具有共同构造或表现出共同行为的事情分成一组</p></li><li><p>多态</p><p>接口的多种不同的实现方式</p></li><li><p>接口</p><p>自己提供给外界的一种抽象化物</p></li><li><p>聚合</p><p>部分和整体之间的关系，部分可以独立于整体</p></li><li><p>组合</p><p>部分和整体之间的关系，部分不能离开整体</p></li><li><p>UML</p><p>统一建模语言</p></li><li><p>上转型对象</p><p>假设，A类是B类的父类，当我们用子类创建一个对象，并把这个对象的引用放到父类的对象中时，A a;<br>B b=new B();<br>a=b;<br>称这个父类对象 a是子类对象b的上转型对象。</p></li><li><p>单元测试框架</p><p>每个程序单元进行测试的框架</p></li><li><p>设计模式</p><p>面向对象程序设计在开发过程种出现了一些反复可用、解决实际问题的解决方案</p></li><li><p>设计原则</p></li></ul><p>为良好的软件设计提供了指南和准则，让我们判断什么是好的软件</p><h2 id="软件测试和软件调试"><a href="#软件测试和软件调试" class="headerlink" title="软件测试和软件调试"></a>软件测试和软件调试</h2><hr><ul><li><p>软件测试</p><p>选择性地运行程序，目的是显示程序有错误、没有按照预期执行或产生预期的结果</p></li><li><p>软件调试</p><p>选择性地运行程序，目的是发现程序的出错的根源和位置，并修改程序</p></li><li><p>测试和调试的联系</p><p>测试发现程序出现的错误，调试来修改出错的程序</p></li><li><p>为什么调试是一项智力活动</p></li></ul><h2 id="面向对象的5个基本原则"><a href="#面向对象的5个基本原则" class="headerlink" title="面向对象的5个基本原则"></a>面向对象的5个基本原则</h2><hr><ul><li>单一职责原则</li></ul><p><strong><em>它规定一个类应该只有一个发生变化的原因</em></strong></p><ul><li>开闭原则</li></ul><p><strong><em>软件中的对象应该对于扩展是开放的，但对于修改是封闭的，</em></strong></p><ul><li>里氏代换原则</li></ul><p><strong><em>任何基类可以出现的地方，子类一定可以出现.</em></strong></p><ul><li>依赖倒置原则</li></ul><p><strong><em>程序要依赖于抽象接口，不要依赖于具体实现</em></strong></p><ul><li>接口隔离原则</li></ul><p><strong><em>客户端不应该依赖于它不需要的接口。一个类对另一个类的依赖应该建立在最小的接口上</em></strong></p><h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><hr><ul><li><p>JAVA注解</p><p>为程序的元素（类、方法、成员变量）加上更直观的说明，这些说明信息是与程序的业务逻辑无关，并且供指定的工具或框架使用</p></li><li><p>JUnit基本注解</p><ul><li>@Test  ：测试方法</li><li>@Before ：在每个测试方法执行前都要执行一次</li><li>@After：在每个测试方法之后都要执行依次</li><li>@Runwith：执行测试的运行器</li><li>@Ignore：在测试种会被忽略</li></ul></li><li><p>JUnit断言</p><ul><li><p>断言的作用</p><p>比较待测程序的运行结果和预期结果是否一致</p></li><li><p>JUnit测试步骤</p><ul><li>为待测软建立一个测试类</li><li>为测试做必要的准备</li><li>为测试类的成员变量/函数编写测试方法</li><li>运行测试，查看结果，修改代码</li><li>每次修改代码，重复上述两步</li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UML(统一建模语言)概要</title>
      <link href="/deng123-dev.github.io/2020/12/30/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80%E6%A6%82%E8%A6%81/"/>
      <url>/deng123-dev.github.io/2020/12/30/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80%E6%A6%82%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr><ul><li>什么是模型</li></ul><p>通过主观意识借助实体或者虚拟表现构成客观阐述形态结构的一种表达目的的物件。</p><p>从广义来讲：如果一件事物能随着另一间事物的改变而改变，那么此事物就是另一个事物的模型。</p><a id="more"></a><ul><li>什么是建模</li></ul><p>建模，就是建立模型，就是为了理解事物而对事物做出的一种抽象，是对事物一种无歧义的书面表述。建立系统模型的过程，又叫做模型化。</p><p>凡是用模型描述系统的因果关系或相互关系的过程都属于建模</p><ul><li><p>UML的作用和特点</p><ul><li><p>作用</p><p>为软件系统建立可视化模型；</p><p>为软件系统建立构件；</p><p>为软件系统建立文档。</p></li><li><p>特点</p><p>面向对象</p><p>可视化</p><p>独立于进程</p><p>独立于程序设计语言</p><p>易于掌握使用</p></li></ul></li></ul><h1 id="基本概念-术语"><a href="#基本概念-术语" class="headerlink" title="基本概念/术语"></a>基本概念/术语</h1><hr><ul><li>类</li></ul><p>类是面向对象系统中最基本的组成元素<br>。类是现实世界事物的抽象原型。它描述一类对象的行为和状态。</p><ul><li>对象</li></ul><p>对象是类的一个特定实例</p><ul><li>类的属性</li></ul><p>属性描述了类的所有对象共有的特性</p><ul><li>类的操作</li></ul><p>操作是类的所有对象共有的行为的抽象</p><ul><li>接口</li></ul><p>自己提供给外界的一种抽象化物</p><ul><li>节点</li></ul><p>系统运行时的物理单元，代表具有内存以及处理能力的计算资源</p><ul><li>组件</li></ul><p>代表了一个接口定义良好的软件模块</p><ul><li>包</li></ul><p>是一个用来将模型元素分组的通用机制</p><ul><li><p>关联：<br>表示两个类之间存在的某种语义间的联系，规定一种事物的对象可以与另一种事物的对象相连</p><ul><li><p>聚合</p><p>特殊的关联关系，表示类之间的关系是整体和部分的关系，部分可以独立于整体</p></li><li><p>组合</p><p>组合是聚合的变种，它加入了一些重要的语义，部分不能离开整体。</p></li></ul></li><li><p>泛化</p></li></ul><p>一种继承关系，表示一般和特殊的关系</p><ul><li>实现</li></ul><p>被规定对接口和实现接口的类或组件之间的关系</p><ul><li>依赖</li></ul><p>如果一个模型元素的变化会影响另一个模型元素，那么就说这两个模型元素存在依赖关系</p><h1 id="建模工具"><a href="#建模工具" class="headerlink" title="建模工具"></a>建模工具</h1><hr><h2 id="静态建模"><a href="#静态建模" class="headerlink" title="静态建模"></a>静态建模</h2><hr><h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3><hr><p>描述的是系统外部参与者所理解的系统功能，用例模型用于需求分析阶段。它描述了待开发系统的功能需求；它将系统看作黑盒，从外部参与者的角度来理解系统；它还驱动了需求分析之后各阶段的开发工作。</p><p>用例图的组成</p><ul><li><p>用例：系统提供的服务<br><img src="/deng123-dev.github.io/images/pasted-232.png" alt="upload successful">  </p></li><li><p>参与者：角色，系统的用户<br><img src="/deng123-dev.github.io/images/pasted-231.png" alt="upload successful"></p></li><li><p>用例图中的各种关系</p><ul><li><p>参与者与用例间的关联关系：参与者与用例之间的通信，也成为关联或通信关系<br><img src="/deng123-dev.github.io/images/pasted-233.png" alt="upload successful"></p></li><li><p>用例与用例之间的关系：包含关系（include）包含关系描述的是一个用例需要某种功能，而该功能被另外一个用例定义，那么在用例的执行过程中，就可以调用已经定义好的用例<br><img src="/deng123-dev.github.io/images/pasted-234.png" alt="upload successful"></p></li><li><p>用例与用例之间的关系：扩展关系用一个用例（可选）扩展另一个用例（基本例）的功能，将一些常规的动作放在一个基本用例中，将可选的或只在特定条件下才执行的动作放在它的扩展用例中<br><img src="/deng123-dev.github.io/images/pasted-236.png" alt="upload successful"></p></li></ul></li></ul><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><hr><p>类图是面向对象建模中最常用的图，类图描述类、接口、协作以及他们之间的关系</p><ul><li>类图的表示</li></ul><p><img src="/deng123-dev.github.io/images/pasted-241.png" alt="upload successful"></p><p>具体类在类图中用矩形框表示，矩形框分为三层：第一层是类名字。第二层是类的成员变量；第三层是类的方法成员变量以及方法前的访问修饰符用符号来表示：</p><p>“+”表示 public；</p><p>“-”表示 private；</p><p>“#”表示 protected；</p><p>不带符号表示 default。</p><ul><li>类图之间的关系</li></ul><p><img src="/deng123-dev.github.io/images/pasted-237.png" alt="upload successful"></p><h3 id="包图"><a href="#包图" class="headerlink" title="包图"></a>包图</h3><hr><p>描述包及包组间的关系</p><ul><li><p>类包图：<br> 3个经验法可以遵循</p><ul><li>将具有继承关系的类分到一个包里</li><li>将具有组合关系的类分到一个包里</li><li>将协作较多的类分到一个包里</li></ul></li><li><p>用例包图：<br> 1个经验法可以遵循<br> 将有包含关系或扩展关系的用例放在一个包里</p></li></ul><h3 id="部署图"><a href="#部署图" class="headerlink" title="部署图"></a>部署图</h3><hr><p><img src="/deng123-dev.github.io/images/pasted-242.png" alt="upload successful"><br>描述了节点和运行其上的组件的配置，它是用来为面向对象系统物理实现建模的两种图之一，其极大程度上描述了运行系统的硬件拓扑，它为系统中物理节点、节点之间的关系的静态方面建立了可视化模型，并规定了细节</p><p>部署图有两大元素：</p><ul><li><p>节点</p></li><li><p>依赖关系、关联关系</p></li></ul><h2 id="动态建模"><a href="#动态建模" class="headerlink" title="动态建模"></a>动态建模</h2><hr><h3 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h3><hr><p><img src="/deng123-dev.github.io/images/pasted-243.png" alt="upload successful"><br>顺序图是强调消息时间顺序的交互图，描述了对象之间传送消息的时间顺序，用于表示用例中行为的顺序</p><p>建模元素</p><ul><li><p>角色<br>可以是人或系统或其子系统</p></li><li><p>对象<br>可以与角色进行交互，用矩形框表示，对象名带有下划线</p></li><li><p>生命线<br>从对象图标底部中心位置向下的一条虚线</p></li><li><p>激活期<br>也被称为控制焦点，代表对下个执行一项操作的时期，是顺序图中表示时间段的符号，用小矩形表示，也被称为激活条或控制期，矩形长度代表激活的持续时间</p></li><li><p>消息<br>对象之间某种形式的通信，用带有箭头的线并附以消息表达式的方式表示</p><ul><li><p>同步消息：<br>仅当发送者要发送一个消息而且接受者已经做好接收这个消息的准备时才能发送的消息<br><img src="/deng123-dev.github.io/images/pasted-238.png" alt="upload successful"></p></li><li><p>异步消息：<br>不管接受者是否做好了准备，发送者都可以发送的消息<br><img src="/deng123-dev.github.io/images/pasted-239.png" alt="upload successful"></p></li><li><p>返回消息：表示从过程调用返回，用一个开放箭头的虚线表示<br><img src="/deng123-dev.github.io/images/pasted-240.png" alt="upload successful"></p></li></ul></li></ul><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><hr><p>描述特定对象的所有可能状态、状态跃迁以及引起状态跃迁的事件</p><p><img src="/deng123-dev.github.io/images/pasted-245.png" alt="upload successful"></p><h3 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h3><hr><p><img src="/deng123-dev.github.io/images/pasted-246.png" alt="upload successful"><br>描述了从活动到活动的流。活动是在状态机中进行的一个非原子的执行，它由一系列动作组成。动作由可执行的、不可分的计算</p><p>活动图主要包含了下列元素：</p><ul><li>动作状态</li></ul><p>所有可执行的、不可分的计算，比如发信号、创建、破坏对象</p><ul><li>活动状态</li></ul><p>活动状态是非原子的、可以分解的，活动状态即组合起来的动作状态</p><ul><li>跃迁</li></ul><p>表示从一个动作或活动传递到下一个动作或活动状态的路径</p><ul><li>对象</li></ul><p>表示当前状态的客体存在</p><p>带泳道的活动图</p><p><img src="/deng123-dev.github.io/images/pasted-247.png" alt="upload successful"></p><h3 id="通信图（协作图）"><a href="#通信图（协作图）" class="headerlink" title="通信图（协作图）"></a>通信图（协作图）</h3><hr><p><img src="/deng123-dev.github.io/images/pasted-244.png" alt="upload successful"><br>强调了参与交互作用的对象的组织。</p><p>和顺序图的共同点：二者都是用对象间的交互来描述用例的；</p><p>和顺序图的不同点：时序图强调交互的时间次序。协作图强调交互的空间结构。</p><p>但是很少使用通信图，因为顺序图更简洁，更直观</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git基础</title>
      <link href="/deng123-dev.github.io/2020/11/30/git%E5%9F%BA%E7%A1%80/"/>
      <url>/deng123-dev.github.io/2020/11/30/git%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="git简介"><a href="#git简介" class="headerlink" title="git简介"></a>git简介</h1><hr><h2 id="版本控制简介"><a href="#版本控制简介" class="headerlink" title="版本控制简介"></a>版本控制简介</h2><hr><p>什么是版本控制</p><p><code>版本控制是一种在开发过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看历史记录，备份以便恢复以前的软件工程技术。</code></p><a id="more"></a><p>优点：</p><ul><li><p>实现跨区域多人协同开发</p></li><li><p>追踪和记载一个或者多个文件的1历史记录</p></li><li><p>组织和保护你的源代码和文件</p></li><li><p>统计工作量</p></li><li><p>并行开发、提高开发效率</p></li><li><p>跟踪记录整个软件的开发过程</p></li><li><p>减轻开发人员的负担</p></li></ul><p>用于多人协同开发项目的技术</p><h2 id="版本控制分类"><a href="#版本控制分类" class="headerlink" title="版本控制分类"></a>版本控制分类</h2><hr><h3 id="本地版本控制"><a href="#本地版本控制" class="headerlink" title="本地版本控制"></a>本地版本控制</h3><hr><p>记录文件的每次更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用</p><p><img src="/deng123-dev.github.io/images/pasted-228.png" alt="upload successful"></p><h3 id="集中版本控制"><a href="#集中版本控制" class="headerlink" title="集中版本控制"></a>集中版本控制</h3><hr><p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改</p><p><img src="/deng123-dev.github.io/images/pasted-229.png" alt="upload successful"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode知识总结（7）</title>
      <link href="/deng123-dev.github.io/2020/11/08/leetcode%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%887%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/11/08/leetcode%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%887%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h1><p><strong><em>tags:树</em></strong></p><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-221.png" alt="upload successful"></p><a id="more"></a><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><hr><ul><li>利用前序遍历</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">&#x2F;&#x2F;从顶向下交换</span><br><span class="line">public TreeNode invertTree(TreeNode root)&#123;</span><br><span class="line">if(root&#x3D;&#x3D;null) return null;</span><br><span class="line">TreeNode rightTree&#x3D;root.right;</span><br><span class="line">root.right&#x3D;invertTree(root.left);</span><br><span class="line">root.left&#x3D;invertTree(rightTree);</span><br><span class="line">return root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用中序遍历</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">    if(root&#x3D;&#x3D;null) return null; </span><br><span class="line">   invertTree(root.left);&#x2F;&#x2F;递归找到左结点</span><br><span class="line">   TreeNode rightNode&#x3D;root.right;&#x2F;&#x2F;保存右结点</span><br><span class="line">   root.right&#x3D;root.left;</span><br><span class="line">   root.left&#x3D;rightNode;</span><br><span class="line">   invertTree(root.left);&#x2F;&#x2F;递归找到右结点，继续交换，因为此时左右结点已经交换，所以此时的右结点为root.left</span><br><span class="line">   return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用后序遍历</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    &#x2F;&#x2F;从下向上交换</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">    if(root&#x3D;&#x3D;null) return null; </span><br><span class="line">    TreeNode leftNode&#x3D;invertTree(root.left);</span><br><span class="line">    TreeNode rightNode&#x3D;invertTree(root.right);</span><br><span class="line">    root.right&#x3D;leftNode;</span><br><span class="line">    root.left&#x3D;rightNode;</span><br><span class="line">    return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1><p><strong><em>tags:树</em></strong></p><hr><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-222.png" alt="upload successful"></p><h2 id="编写代码-1"><a href="#编写代码-1" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">    if(root&#x3D;&#x3D;null) return 0;</span><br><span class="line">    int left&#x3D;maxDepth(root.left);</span><br><span class="line">    int right&#x3D;maxDepth(root.right);</span><br><span class="line">    return left&gt;right?left+1:right+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h1><p><strong><em>tags:树</em></strong></p><hr><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-223.png" alt="upload successful"></p><h2 id="编写代码-2"><a href="#编写代码-2" class="headerlink" title="编写代码"></a>编写代码</h2><hr><ul><li>用递归实现：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class solution&#123;</span><br><span class="line">public bollean isSymmetric(TreeNode root)&#123;</span><br><span class="line">if(root&#x3D;null)&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return cmp(root.left,root.right);</span><br><span class="line">&#125;</span><br><span class="line">private boolean cmp(TreeNode node1,TreeNode node2)&#123;</span><br><span class="line">if(node1&#x3D;&#x3D;null&amp;&amp;node2&#x3D;&#x3D;null)&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">if(node1&#x3D;&#x3D;null||node2&#x3D;&#x3D;null||node1.val!&#x3D;node2.val)&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"> return cmp(node1.left,node2.right)&amp;&amp;cmp(node1.right,node2.left);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用迭代实现：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">public boolean isSymmetric(TreeNode root)&#123;</span><br><span class="line">if(root&#x3D;&#x3D;null)&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">Queue&lt;TreeNode&gt;queue &#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">queue.offer(root.left);</span><br><span class="line">queue.offer(root.right);</span><br><span class="line"></span><br><span class="line">while(!queue.isEmpty())&#123;</span><br><span class="line">TreeNode node1&#x3D;queue.poll();</span><br><span class="line">TreeNode node2&#x3D;queue.poll();</span><br><span class="line">if(node1&#x3D;&#x3D;null&amp;&amp;node2&#x3D;&#x3D;null)&#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">if(node1&#x3D;&#x3D;null||node2&#x3D;&#x3D;null||node1.val!&#x3D;node2.val)&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">queue.offer(node1.left);</span><br><span class="line">queue.offer(node2.right);</span><br><span class="line">queue.offer(node1.right);</span><br><span class="line">queue.offer(node2.left);</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h1><hr><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-224.png" alt="upload successful"></p><h2 id="编写代码-3"><a href="#编写代码-3" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    double  last&#x3D;-Double.MAX_VALUE;</span><br><span class="line">    public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">    if(root&#x3D;&#x3D;null)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if(isValidBST(root.left))&#123;&#x2F;&#x2F;对树进行中序遍历</span><br><span class="line">    if(last&lt;root.val)&#123;&#x2F;&#x2F;设定变量last为当前遍历到的最大值</span><br><span class="line">        last&#x3D;root.val;</span><br><span class="line">        return isValidBST(root.right);&#x2F;&#x2F;只有根结点大于上一个结点时才会执行右遍历，否则直接返回false</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; </span><br><span class="line">   return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h1><p><strong><em>tags:树</em></strong></p><hr><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-225.png" alt="upload successful"></p><h2 id="编写代码-4"><a href="#编写代码-4" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    if(root&#x3D;&#x3D;null) </span><br><span class="line">    return new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res&#x3D;new ArrayList&lt;&gt;();&#x2F;&#x2F;用来存放结果</span><br><span class="line">    Queue&lt;TreeNode&gt; queue&#x3D;new LinkedList&lt;TreeNode&gt;();&#x2F;&#x2F;用来存放每一层需要遍历的结点</span><br><span class="line">    queue.add(root);</span><br><span class="line">    while(!queue.isEmpty())&#123;</span><br><span class="line">        int count&#x3D;queue.size();&#x2F;&#x2F;定义每层需要遍历结点的个数</span><br><span class="line">        List&lt;Integer&gt; list&#x3D;new ArrayList&lt;Integer&gt;();&#x2F;&#x2F;用来存放每一层遍历的结果 </span><br><span class="line">        while(count&gt;0)&#123;&#x2F;&#x2F;每次循环意味着遍历二叉树的一层</span><br><span class="line">        TreeNode node&#x3D;queue.poll();</span><br><span class="line">        list.add(node.val);&#x2F;&#x2F;将当前遍历的结点的值放入表中</span><br><span class="line">        if(node.left!&#x3D;null)</span><br><span class="line">          queue.add(node.left); </span><br><span class="line">        if(node.right!&#x3D;null)  </span><br><span class="line">           queue.add(node.right);</span><br><span class="line">           count--;   </span><br><span class="line">        &#125;</span><br><span class="line">        res.add(list);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h1><p><strong><em>tags:DFS</em></strong></p><hr><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-226.png" alt="upload successful"></p><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><hr><ul><li>枚举法（通过递归将所有的结果枚举出来，找出正确的结果）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int count&#x3D;0;</span><br><span class="line">    public int findTargetSumWays(int[] nums, int S) &#123;</span><br><span class="line">    calculate(nums,0,0,S);</span><br><span class="line">    return count; </span><br><span class="line">   &#125;</span><br><span class="line">   public void calculate(int[] nums,int i,int sum,int S)&#123;</span><br><span class="line">   if(i&#x3D;&#x3D;nums.length)&#123;&#x2F;&#x2F;判断递归是否已经到第四个元素</span><br><span class="line">       if(sum&#x3D;&#x3D;S)&#x2F;&#x2F;判断这条路径上的结果是否附和预期</span><br><span class="line">       count++;</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">       calculate(nums,i+1,sum+nums[i],S);&#x2F;&#x2F;递归数值做加法</span><br><span class="line">       calculate(nums,i+1,sum-nums[i],S);&#x2F;&#x2F;递归数值做减法</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>耗时以及消耗内存</p><p><img src="/deng123-dev.github.io/images/pasted-227.png" alt="upload successful"></p><ul><li>动态规划</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findTargetSumWays(int[] nums, int S) &#123;</span><br><span class="line">    int [][] dp&#x3D;new int [nums.length][2001];&#x2F;&#x2F;定义数组存放实现目标和的方法个数，横坐标表示当前计算的深度，纵坐标表示当前计算的结果 </span><br><span class="line">    dp[0][nums[0]+1000]&#x3D;1;</span><br><span class="line">    dp[0][-nums[0]+1000]+&#x3D;1;</span><br><span class="line">    for(int i&#x3D;1;i&lt;nums.length;i++)&#123;</span><br><span class="line">         for(int sum&#x3D;-1000;sum&lt;&#x3D;1000;sum++)&#123;</span><br><span class="line">         if(dp[i-1][sum+1000]&gt;0)&#123;</span><br><span class="line">         dp[i][sum+nums[i]+1000]+&#x3D;dp[i-1][sum+1000];</span><br><span class="line">         dp[i][sum-nums[i]+1000]+&#x3D;dp[i-1][sum+1000];</span><br><span class="line">         &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return S&gt;1000? 0:dp[nums.length-1][S+1000];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode知识总结（6）</title>
      <link href="/deng123-dev.github.io/2020/10/28/leetcode%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%886%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/10/28/leetcode%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%886%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="打家劫舍III"><a href="#打家劫舍III" class="headerlink" title="打家劫舍III"></a>打家劫舍III</h1><p><strong><em>tags:树</em></strong></p><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-213.png" alt="upload successful"></p><a id="more"></a><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int rob(TreeNode root) &#123;</span><br><span class="line">       int[] res&#x3D;helper(root); </span><br><span class="line">       return Math.max(res[0],res[1]); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int[] helper(TreeNode r)&#123;</span><br><span class="line">    if(r&#x3D;&#x3D;null) return new int[2];</span><br><span class="line">    int[] left&#x3D;helper(r.left);</span><br><span class="line">    int[] right&#x3D;helper(r.right);</span><br><span class="line">    int[] res&#x3D;new int[2];</span><br><span class="line">    res[0]&#x3D;Math.max(left[0],left[1])+Math.max(right[0],right[1]);</span><br><span class="line">    res[1]&#x3D;r.val+left[0]+right[0];</span><br><span class="line">    return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h1><p><strong><em>tags:树</em></strong></p><hr><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-214.png" alt="upload successful"></p><h2 id="编写代码-1"><a href="#编写代码-1" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; memory&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">    public int numTrees(int n) &#123;</span><br><span class="line">    return helper(1,n);</span><br><span class="line">    &#125;</span><br><span class="line">    public int helper(int begin,int end)&#123;</span><br><span class="line">        if(memory.containsKey(end-begin))</span><br><span class="line">        return memory.get(end-begin);</span><br><span class="line">        if(begin&gt;end)</span><br><span class="line">        return 1;</span><br><span class="line">        int sum&#x3D;0;</span><br><span class="line">        for(int i&#x3D;begin;i&lt;&#x3D;end;i++)&#123;</span><br><span class="line">            int leftSize&#x3D;helper(begin,i-1);</span><br><span class="line">            int rightSize&#x3D;helper(i+1,end);</span><br><span class="line">            sum+&#x3D;leftSize*rightSize;</span><br><span class="line">        &#125;</span><br><span class="line">        memory.put(end-begin,sum);</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结"><a href="#解题思路和知识总结" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><ul><li><p>解题思路</p><p> 因为二叉搜索树的种类只与结点个数有关，那么建立备忘录，防止重复计算。通过循环递归计算出左右子树的个数</p></li><li><p>知识总结</p><ul><li>containsKey：判断是否包含指定的键名</li></ul></li></ul><h1 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h1><p><strong><em>tags:树</em></strong></p><hr><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-215.png" alt="upload successful"></p><h2 id="编写代码-2"><a href="#编写代码-2" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123;</span><br><span class="line">    if(t1&#x3D;&#x3D;null)</span><br><span class="line">    return t2;</span><br><span class="line">    if(t2&#x3D;&#x3D;null)</span><br><span class="line">    return t1;</span><br><span class="line">    t1.val+&#x3D;t2.val;</span><br><span class="line">    t1.left&#x3D;mergeTrees(t1.left,t2.left);</span><br><span class="line">    t1.right&#x3D;mergeTrees(t1.right,t2.right);</span><br><span class="line">    return t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结-1"><a href="#解题思路和知识总结-1" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><ul><li><p>解题思路</p><p>这道题可以用二叉树的先序遍历进行求解</p></li></ul><h1 id="二叉树展开成链表"><a href="#二叉树展开成链表" class="headerlink" title="二叉树展开成链表"></a>二叉树展开成链表</h1><p><strong><em>tags:树</em></strong></p><hr><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-216.png" alt="upload successful"></p><h2 id="编写代码-3"><a href="#编写代码-3" class="headerlink" title="编写代码"></a>编写代码</h2><hr><ul><li>优化前代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void flatten(TreeNode root) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) return;</span><br><span class="line">        flatten(root.left);</span><br><span class="line">        TreeNode left &#x3D; root.left;</span><br><span class="line">        TreeNode right &#x3D; root.right;</span><br><span class="line">        if (left !&#x3D; null) &#123;</span><br><span class="line">            root.right &#x3D; left;</span><br><span class="line">            while (left.right !&#x3D; null) left &#x3D; left.right;</span><br><span class="line">            left.right &#x3D; right;</span><br><span class="line">            root.left &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        flatten(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化前执行结果</p><p><img src="/deng123-dev.github.io/images/pasted-217.png" alt="upload successful"></p><ul><li>优化后代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void flatten(TreeNode root) &#123;</span><br><span class="line">        List&lt;TreeNode&gt; list &#x3D; new ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        preorderTraversal(root, list);</span><br><span class="line">        int size &#x3D; list.size();</span><br><span class="line">        for (int i &#x3D; 1; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode prev &#x3D; list.get(i - 1), curr &#x3D; list.get(i);</span><br><span class="line">            prev.left &#x3D; null;</span><br><span class="line">            prev.right &#x3D; curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void preorderTraversal(TreeNode root, List&lt;TreeNode&gt; list) &#123;</span><br><span class="line">        if (root !&#x3D; null) &#123;</span><br><span class="line">            list.add(root);</span><br><span class="line">            preorderTraversal(root.left, list);</span><br><span class="line">            preorderTraversal(root.right, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结-2"><a href="#解题思路和知识总结-2" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><ul><li><p>解题思路</p><p>这道题有两个解题代码</p><ul><li>一个是优化前代码，它的执行思路是进行先序遍历递归操作，在递归的过程中将结点的右结点放在左结点之后，因为这样的操作在每次递归之后都要找到最右边的结点，增加了时间复杂度</li><li>一个是优化后代码，它的执行思路进行先序遍历将树的每个结点依次放入到数组列表中，再将数组列表中的数据建树</li></ul></li></ul><h1 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h1><p><strong><em>tags:树</em></strong></p><hr><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-218.png" alt="upload successful"></p><h2 id="编写代码-4"><a href="#编写代码-4" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class solution&#123;</span><br><span class="line">public TreeNode lowestCommonAncestor(TreeNode root,TreeNode p,TreeNode q)&#123;</span><br><span class="line">if(root&#x3D;&#x3D;null)&#123;</span><br><span class="line">return root;</span><br><span class="line">&#125;</span><br><span class="line">if(root&#x3D;&#x3D;p||root&#x3D;&#x3D;q)&#123;</span><br><span class="line">return root;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode left&#x3D;lowestCommonAncestor(root.left,p,q);</span><br><span class="line">TreeNode right&#x3D;lowestCommonAncestor(root.right,p,q);</span><br><span class="line">if(left!&#x3D;null&amp;&amp;right!&#x3D;null)&#123;</span><br><span class="line">return root;</span><br><span class="line">&#125;</span><br><span class="line">else if(left!&#x3D;null)&#123;</span><br><span class="line">return left;</span><br><span class="line">&#125;</span><br><span class="line">else if(right!&#x3D;null)&#123;</span><br><span class="line">return right;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结-3"><a href="#解题思路和知识总结-3" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><ul><li><p>解题思路</p><p>这道题是通过root结点来找到树的祖先，递归，当找不到目标结点时就返回空结点，当遇到结点等于两个待查找结点之一时直接返回该结点，每次递归完成后判断左右结点是否为空，哪边不为空返回哪边的结点，两边都不为空返回它们的父结点</p></li></ul><h1 id="从先序遍历和中序遍历构造二叉树"><a href="#从先序遍历和中序遍历构造二叉树" class="headerlink" title="从先序遍历和中序遍历构造二叉树"></a>从先序遍历和中序遍历构造二叉树</h1><hr><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-219.png" alt="upload successful"></p><h2 id="编写代码-5"><a href="#编写代码-5" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private Map&lt;Integer, Integer&gt; indexMap;</span><br><span class="line"></span><br><span class="line">    public TreeNode myBuildTree(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) &#123;</span><br><span class="line">        if (preorder_left &gt; preorder_right) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 前序遍历中的第一个节点就是根节点</span><br><span class="line">        int preorder_root &#x3D; preorder_left;</span><br><span class="line">        &#x2F;&#x2F; 在中序遍历中定位根节点</span><br><span class="line">        int inorder_root &#x3D; indexMap.get(preorder[preorder_root]);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 先把根节点建立出来</span><br><span class="line">        TreeNode root &#x3D; new TreeNode(preorder[preorder_root]);</span><br><span class="line">        &#x2F;&#x2F; 得到左子树中的节点数目</span><br><span class="line">        int size_left_subtree &#x3D; inorder_root - inorder_left;</span><br><span class="line">        &#x2F;&#x2F; 递归地构造左子树，并连接到根节点</span><br><span class="line">        &#x2F;&#x2F; 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span><br><span class="line">        root.left &#x3D; myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);</span><br><span class="line">        &#x2F;&#x2F; 递归地构造右子树，并连接到根节点</span><br><span class="line">        &#x2F;&#x2F; 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br><span class="line">        root.right &#x3D; myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">        int n &#x3D; preorder.length;</span><br><span class="line">        &#x2F;&#x2F; 构造哈希映射，帮助我们快速定位根节点</span><br><span class="line">        indexMap &#x3D; new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            indexMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结-4"><a href="#解题思路和知识总结-4" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><ul><li><p>解题思路</p><p>这道题的解题思路就在它的注释中</p></li></ul><h1 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h1><hr><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-220.png" alt="upload successful"></p><h2 id="编写代码-6"><a href="#编写代码-6" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    int ans;</span><br><span class="line">    public int diameterOfBinaryTree(TreeNode root) &#123;</span><br><span class="line">    ans&#x3D;1;</span><br><span class="line">    depth(root);</span><br><span class="line">    return ans-1;</span><br><span class="line">    &#125;</span><br><span class="line">    public int depth(TreeNode node)&#123;</span><br><span class="line">        if(node&#x3D;&#x3D;null)&#123;</span><br><span class="line">            return 0;&#x2F;&#x2F;访问到空结点了，返回0</span><br><span class="line">        &#125;</span><br><span class="line">    int L&#x3D;depth(node.left);&#x2F;&#x2F;左儿子为根的子树的深度</span><br><span class="line">    int R&#x3D;depth(node.right);&#x2F;&#x2F;右儿子为根的子树的深度</span><br><span class="line">    ans&#x3D;Math.max(ans,L+R+1);&#x2F;&#x2F;计算d_node即L+R+1并更新ans</span><br><span class="line">    return Math.max(L,R)+1;&#x2F;&#x2F;返回该结点为根的子树的深度</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode知识总结（5）</title>
      <link href="/deng123-dev.github.io/2020/10/16/leetcode%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%885%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/10/16/leetcode%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%885%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="任务调度器"><a href="#任务调度器" class="headerlink" title="任务调度器"></a>任务调度器</h1><p><strong><em>tags:贪心算法</em></strong></p><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-203.png" alt="upload successful"></p><a id="more"></a><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class solution&#123;</span><br><span class="line">public int leastInterval(char[] tasks,int n)&#123;</span><br><span class="line">int[] map&#x3D;new int[25];</span><br><span class="line">for(char c:tasks)&#123;</span><br><span class="line">map[c-&#39;A&#39;]++;</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(map);</span><br><span class="line">int time&#x3D;0;</span><br><span class="line">while(map[25]&gt;0)&#123;</span><br><span class="line">int i&#x3D;0;</span><br><span class="line">while(i&lt;&#x3D;n)&#123;</span><br><span class="line">if(map[25]&#x3D;&#x3D;0)&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if(i&lt;26&amp;&amp;map[25-i]&gt;0)</span><br><span class="line">map[25-i]--;</span><br><span class="line">time++;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(map);</span><br><span class="line">&#125;</span><br><span class="line">return time;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结"><a href="#解题思路和知识总结" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><ul><li><p>解题思路</p><p>这道题的关键在于如何在一个任务的冷却时间更多执行其他任务，先将每个任务出现的次数放入数组，然后对数组进行排序，从出现次数最多的任务开始执行（因为这样执行会更加高效）</p></li></ul><h1 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h1><p><strong><em>tags:排序</em></strong></p><hr><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-204.png" alt="upload successful"></p><h2 id="编写代码-1"><a href="#编写代码-1" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] merge(int[][] intervals) &#123;</span><br><span class="line">     if(intervals.length&#x3D;&#x3D;0)&#123;</span><br><span class="line">     return new int[0][2];</span><br><span class="line">     &#125;</span><br><span class="line">     Arrays.sort(intervals,new Comparator&lt;int[]&gt;()&#123;</span><br><span class="line">     public  int compare(int[] interval1,int[] interval2)&#123;</span><br><span class="line">        return interval1[0]-interval2[0];</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">    List &lt;int[]&gt; merged &#x3D;new ArrayList&lt;int[]&gt;();</span><br><span class="line">    for(int i&#x3D;0;i&lt;intervals.length;++i)&#123;</span><br><span class="line">    int L&#x3D;intervals[i][0],R&#x3D;intervals[i][1];</span><br><span class="line">    if(merged.size()&#x3D;&#x3D;0||merged.get(merged.size()-1)[1]&lt;L)&#123;</span><br><span class="line">        merged.add(new int[]&#123;L,R&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        merged.get(merged.size()-1)[1]&#x3D;Math.max(merged.get(merged.size()-1)[1],R);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">return merged.toArray(new int[merged.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结-1"><a href="#解题思路和知识总结-1" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><ul><li>解题思路</li></ul><p>根据每组数组的前一个数据进行升序排列，设置一个一维长度长度可变的数组，将数据装入一维数组前进行比较，如果数据的左数据比数组队尾元素大，则全部装入，如果队尾数据在左数据和右数据之间，则用右数据替换队尾元素，如果左，右数据都比数据小，则不做改变</p><h1 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a>颜色分类</h1><hr><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-205.png" alt="upload successful"></p><h2 id="编写代码-2"><a href="#编写代码-2" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line"> public void sortColors(int[] nums) &#123;</span><br><span class="line">    int n&#x3D;nums.length;</span><br><span class="line">    int ptr&#x3D;0;  </span><br><span class="line">    for(int i&#x3D;0;i&lt;n;++i)&#123;</span><br><span class="line">     if(nums[i]&#x3D;&#x3D;0)&#123;</span><br><span class="line">        int temp&#x3D;nums[i];</span><br><span class="line">         nums[i]&#x3D;nums[ptr];</span><br><span class="line">         nums[ptr]&#x3D;temp;</span><br><span class="line">         ++ptr;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     for(int i&#x3D;ptr;i&lt;n;++i)&#123;</span><br><span class="line">         if(nums[i]&#x3D;&#x3D;1)&#123;</span><br><span class="line">          int temp&#x3D;nums[i];</span><br><span class="line">          nums[i]&#x3D;nums[ptr];</span><br><span class="line">          nums[ptr]&#x3D;temp;</span><br><span class="line">          ++ptr;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结-2"><a href="#解题思路和知识总结-2" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><ul><li><p>解题思路</p><p>这道题设置一个数组当前遍历的索引变量，遍历整个数组，通过交换将数组进行排序</p></li></ul><h1 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h1><p><strong><em>tags:排序，链表</em></strong></p><hr><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-206.png" alt="upload successful"></p><h2 id="编写代码-3"><a href="#编写代码-3" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode sortList(ListNode head) &#123;</span><br><span class="line">    if(head&#x3D;&#x3D;null || head.next&#x3D;&#x3D;null)</span><br><span class="line">    return head;</span><br><span class="line">    ListNode fast &#x3D;head.next,slow&#x3D;head;</span><br><span class="line">    while(fast!&#x3D;null&amp;&amp;fast.next!&#x3D;null)&#123;</span><br><span class="line">      slow&#x3D;slow.next;</span><br><span class="line">      fast&#x3D;fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode tmp&#x3D;slow.next;</span><br><span class="line">    slow.next&#x3D;null;</span><br><span class="line">    ListNode left&#x3D;sortList(head);</span><br><span class="line">    ListNode right&#x3D;sortList(tmp);</span><br><span class="line">    ListNode h&#x3D;new ListNode(0);</span><br><span class="line">    ListNode res&#x3D;h;</span><br><span class="line">    while(left!&#x3D;null&amp;&amp;right!&#x3D;null)&#123;</span><br><span class="line">     if(left.val&lt;right.val)&#123;</span><br><span class="line">           h.next&#x3D;left;</span><br><span class="line">           left&#x3D;left.next;</span><br><span class="line">     &#125;                              </span><br><span class="line">     else &#123;</span><br><span class="line">           h.next&#x3D;right;</span><br><span class="line">           right&#x3D;right.next; </span><br><span class="line">     &#125;</span><br><span class="line">     h&#x3D;h.next;                                         </span><br><span class="line">    &#125;    </span><br><span class="line">    h.next&#x3D;left!&#x3D;null?left:right;</span><br><span class="line">    return res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结-3"><a href="#解题思路和知识总结-3" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><ul><li><p>解题思路</p><p>运用递归先将链表按照二等分一直分直到只剩下一个元素，<br>再排序，设置双指针将链表合并且排序</p><h1 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a>汉明距离</h1><p><strong><em>tags:位运算</em></strong></p><hr><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><hr></li></ul><p><img src="/deng123-dev.github.io/images/pasted-207.png" alt="upload successful"></p><h2 id="编写代码-4"><a href="#编写代码-4" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int hammingDistance(int x, int y) &#123;</span><br><span class="line">    int z&#x3D;x^y;</span><br><span class="line">    int sum&#x3D;0;</span><br><span class="line">    while(z!&#x3D;0)</span><br><span class="line">    &#123;</span><br><span class="line">      sum+&#x3D;z&amp;1;</span><br><span class="line">      z&#x3D;z&gt;&gt;1;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结-4"><a href="#解题思路和知识总结-4" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><ul><li><p>解题思路 </p><p>先对数字进行异或处理，再进行循环和1按位与并且向右移一位</p></li></ul><h1 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h1><p><strong><em>tags:位运算</em></strong></p><hr><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-208.png" alt="upload successful"></p><h2 id="编写代码-5"><a href="#编写代码-5" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int singleNumber(int[] nums) &#123;</span><br><span class="line">    int single&#x3D;0;</span><br><span class="line">    for(int num:nums)&#123;</span><br><span class="line">    single^&#x3D;num;</span><br><span class="line">    &#125;   </span><br><span class="line">    return single;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结-5"><a href="#解题思路和知识总结-5" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><ul><li><p>解题思路</p><p>运用异或来进行那个数的求解，因为两个相同的数异或的值为0</p></li></ul><h1 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h1><p><strong><em>tags:位运算</em></strong></p><hr><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-209.png" alt="upload successful"></p><h2 id="编写代码-6"><a href="#编写代码-6" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">public int majorityElement(int[] nums)&#123;</span><br><span class="line">int count&#x3D;1;</span><br><span class="line">int maj&#x3D;nums[0];</span><br><span class="line">for(int i&#x3D;1;i&lt;nums.length;i++)&#123;</span><br><span class="line">if(maj&#x3D;&#x3D;nums[i])&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">count--;</span><br><span class="line">if(count&#x3D;&#x3D;0)&#123;</span><br><span class="line"> maj&#x3D;nums[i+1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return maj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结-6"><a href="#解题思路和知识总结-6" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><ul><li><p>解题思路</p><p>摩尔算法：从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个</p></li></ul><h1 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a>比特位计数</h1><hr><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-210.png" alt="upload successful"></p><h2 id="编写代码-7"><a href="#编写代码-7" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] countBits(int num) &#123;</span><br><span class="line">    int [] res&#x3D; new int[num+1];</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;num;i++)&#123;</span><br><span class="line">    res[i]&#x3D;res[i&gt;&gt;1]+(i&amp;1);</span><br><span class="line">    &#125;</span><br><span class="line">   return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结-7"><a href="#解题思路和知识总结-7" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><ul><li><p>解题思路</p><p>将数据的二进制表示向右移一位，表示前面一个数据二进制含1<br>的个数，i&amp;1判断最后一位是否需要加0</p></li></ul><h1 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h1><hr><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-211.png" alt="upload successful"></p><h2 id="编写代码-8"><a href="#编写代码-8" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class solution&#123;</span><br><span class="line">List &lt;List&lt;Integer&gt;&gt; res&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">res.add(new ArrayList&lt;&gt;());</span><br><span class="line">for(int i&#x3D;0;i&lt;nums.length;i++)&#123;</span><br><span class="line">int all&#x3D;res.size();</span><br><span class="line">for(int j&#x3D;0;j&lt;all;j++)&#123;</span><br><span class="line">List&lt;Integer&gt;tmp&#x3D;new ArrayList&lt;&gt;(res.get(j));</span><br><span class="line">tmp.add(nums[i]);</span><br><span class="line">res.add(tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="知识总结和解题思路"><a href="#知识总结和解题思路" class="headerlink" title="知识总结和解题思路"></a>知识总结和解题思路</h2><hr><ul><li>解题思路</li></ul><p>先将数组中添加一对数组的括号，通过双层遍历，最内层的每次遍历都是每个位置的元素加上本层的对应元素，</p><h1 id="路径总和III"><a href="#路径总和III" class="headerlink" title="路径总和III"></a>路径总和III</h1><p><strong><em>tags:树，递归</em></strong></p><hr><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-212.png" alt="upload successful"></p><h2 id="编写代码-9"><a href="#编写代码-9" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class solution&#123;</span><br><span class="line">int pathnumber;</span><br><span class="line">public int pathSum(TreeNode root,int sum)&#123;</span><br><span class="line">if(root&#x3D;&#x3D;null) return 0;</span><br><span class="line">Sum(root,sum);</span><br><span class="line">pathSum(root.left,sum);</span><br><span class="line">pathSum(root.right,sum);</span><br><span class="line">return pathnumber;</span><br><span class="line">&#125;</span><br><span class="line">public void Sum(TreeNode root,int sum)&#123;</span><br><span class="line">if(root&#x3D;&#x3D;null) return;</span><br><span class="line">sum-&#x3D;root.val;</span><br><span class="line">if(sum&#x3D;&#x3D;0)&#123;</span><br><span class="line">pathnumber++;</span><br><span class="line">&#125;</span><br><span class="line">Sum(root.left,sum);</span><br><span class="line">Sum(root.right,sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结-8"><a href="#解题思路和知识总结-8" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><ul><li>解题思路</li></ul><p>双重递归，首先先序递归遍历每个节点，再以每个节点作为起始点递归寻找满足条件的路径。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode知识总结（4）</title>
      <link href="/deng123-dev.github.io/2020/09/18/leetcode%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%884%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/09/18/leetcode%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%884%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h1><p><strong><em>tags:栈，二叉树</em></strong></p><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-190.png" alt="upload successful"></p><a id="more"></a><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; inorderTraversal(TreeNode root)&#123;</span><br><span class="line">List&lt;Integer&gt; list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">Stack&lt;TreeNode&gt; stack&#x3D;new Stack&lt;&gt;();</span><br><span class="line">TreeNode cur&#x3D;root;</span><br><span class="line">while(cur!&#x3D;null||!stack.isEmpty())&#123;</span><br><span class="line">if(cur!&#x3D;null)&#123;</span><br><span class="line">stack.push(cur);</span><br><span class="line">cur&#x3D;cur.left;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cur&#x3D;stack.pop();</span><br><span class="line">list.add(cur.val);</span><br><span class="line">cur&#x3D;cur.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结"><a href="#解题思路和知识总结" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><ul><li><p>解题思路</p><p>先建立一个栈，用来存放遍历过的结点，同时通过入栈和出栈来控制需要访问到哪个结点，根据左根右的顺序进行遍历</p></li></ul><h1 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h1><hr><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images%5Cpasted-191.png" alt="upload successful"></p><h2 id="编写代码-1"><a href="#编写代码-1" class="headerlink" title="编写代码"></a>编写代码</h2><hr><p>优化前代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] dailyTemperatures(int[] T) &#123;</span><br><span class="line">    int []list&#x3D;new int[T.length];</span><br><span class="line">     </span><br><span class="line">    for(int i&#x3D;0;i&lt;T.length-1;i++)&#123;  </span><br><span class="line">    for(int j&#x3D;i+1;j&lt;T.length;j++)&#123;</span><br><span class="line">    if(T[j]&gt;T[i]) &#123;</span><br><span class="line">     list[i]&#x3D;j-i;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化前耗时：</p><p><img src="/deng123-dev.github.io/images/pasted-193.png" alt="upload successful"></p><p>优化后代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">public int[] dailyTemperatures(int[] T)&#123;</span><br><span class="line">Stack&lt;Integer&gt; stack&#x3D;new Stack&lt;&gt;();</span><br><span class="line">int[] res&#x3D;new int [T.length];</span><br><span class="line">for(int i&#x3D;0;i&lt;T.length;i++)&#123;</span><br><span class="line">while(!stack.isEmpty()&amp;&amp;T[i]&gt;T[stack.peek()])&#123;</span><br><span class="line">   int temp&#x3D;stack.pop();</span><br><span class="line">    res[temp]&#x3D;i-temp;</span><br><span class="line">&#125;</span><br><span class="line">stack.push(i);</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后耗时：</p><p><img src="/deng123-dev.github.io/images/pasted-192.png" alt="upload successful"></p><h2 id="解题思路和知识总结-1"><a href="#解题思路和知识总结-1" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><ul><li>解题思路</li></ul><p>优化前的代码：</p><p>直接用双层循环，当后面元素大于需要检索元素时，直接将数字输出</p><p>优化后的代码：</p><p>创建一个栈，用来存放所检索元素的序列，循环</p><h1 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h1><hr><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-194.png" alt="upload successful"></p><h2 id="编写代码-2"><a href="#编写代码-2" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class solution&#123;</span><br><span class="line">    public String decodeString(String s)&#123;</span><br><span class="line">     Stack&lt;String&gt; stack&#x3D;new Stack&lt;String&gt;();</span><br><span class="line">     for(int i&#x3D;0;i&lt;s.length();i++)&#123;</span><br><span class="line">     if(s.charAt(i)&#x3D;&#x3D;&#39;]&#39;)&#123;</span><br><span class="line">     String string&#x3D;&quot;&quot;;</span><br><span class="line">     while(!stack.isEmpty()&amp;&amp;!stack.peek().equals(&quot;[&quot;))</span><br><span class="line">     stirng&#x3D;string+stack.pop();</span><br><span class="line">     stack.pop();</span><br><span class="line">     </span><br><span class="line">     String countstring&#x3D;&quot;&quot;;</span><br><span class="line">     while(!stack.isEmpty()&amp;&amp;stack.peek().charAt(0)&gt;&#x3D;0&amp;&amp;stack.peek().charAt(0)&lt;&#x3D;9)</span><br><span class="line">     countstring&#x3D;stack.pop()+countstring;</span><br><span class="line">     int count&#x3D;Integer.parseInt(countString);</span><br><span class="line">     </span><br><span class="line">     String retstring&#x3D;&quot;&quot;;</span><br><span class="line">     for(int i&#x3D;0;i&lt;count;i++)</span><br><span class="line">     retstring&#x3D;retstring+string;</span><br><span class="line">     stack.push(retstring);</span><br><span class="line">     &#125;   </span><br><span class="line">    else &#123;</span><br><span class="line">    String str&#x3D;&quot;&quot;+s.charAt(i);</span><br><span class="line">    stack.push(str); </span><br><span class="line">    &#125;    </span><br><span class="line">   &#125;   </span><br><span class="line">   String aaa&#x3D;&quot;&quot;;</span><br><span class="line">   while(!stack.isEmpty())</span><br><span class="line">   aaa&#x3D;aaa+stack.pop();</span><br><span class="line">   return aaa;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组中的第k大个元素"><a href="#数组中的第k大个元素" class="headerlink" title="数组中的第k大个元素"></a>数组中的第k大个元素</h1><p><strong><em>tags:排序，c++</em></strong></p><hr><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-195.png" alt="upload successful"></p><h2 id="编写代码-3"><a href="#编写代码-3" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void swap(int&amp; a,int&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        int temp&#x3D;a;</span><br><span class="line">        a&#x3D;b;b&#x3D;temp;</span><br><span class="line">    &#125;</span><br><span class="line">    void quicksort(vector&lt;int&gt;&amp; nums,int l,int r)</span><br><span class="line">    &#123;</span><br><span class="line">        if (l&gt;&#x3D;r) return;</span><br><span class="line">        int i&#x3D;l,j&#x3D;r,mid&#x3D;rand()%(r-l+1)+l;</span><br><span class="line">        swap(nums[mid],nums[l]);</span><br><span class="line">        int temp&#x3D;nums[l];</span><br><span class="line">        while (i!&#x3D;j)</span><br><span class="line">        &#123;</span><br><span class="line">            while (i&lt;j&amp;&amp;nums[j]&gt;&#x3D;temp) j--;</span><br><span class="line">            while (i&lt;j&amp;&amp;nums[i]&lt;&#x3D;temp) i++;</span><br><span class="line">            if (i&lt;j) swap(nums[i],nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        nums[l]&#x3D;nums[i];nums[i]&#x3D;temp;</span><br><span class="line">        quicksort(nums,l,i-1);</span><br><span class="line">        quicksort(nums,i+1,r);</span><br><span class="line">    &#125;</span><br><span class="line">    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        quicksort(nums,0,(int)nums.size()-1);</span><br><span class="line">        return nums[nums.size()-k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结-2"><a href="#解题思路和知识总结-2" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><ul><li>解题思路</li></ul><p>先使用快速排序算法将元素大小整理好，再选出第k大的元素</p><h1 id="前k个高频元素"><a href="#前k个高频元素" class="headerlink" title="前k个高频元素"></a>前k个高频元素</h1><p><strong><em>tags:堆</em></strong></p><hr><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-198.png" alt="upload successful"></p><h2 id="编写代码-4"><a href="#编写代码-4" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">public int[] topKFrequent(int[] nums,int k)&#123;</span><br><span class="line">Map&lt;Integer,Integer&gt; occurrences&#x3D;new Hashmap&lt;Integer,Integer&gt;();</span><br><span class="line"></span><br><span class="line">for(int num:nums)&#123;</span><br><span class="line">occurrences.put(num,occurrences.getOrDefault(num,0)+1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityQueue&lt;int[]&gt; queue&#x3D;new PriorityQueue&lt;int[]&gt;(new  Comparator &lt;int[]&gt;()&#123;</span><br><span class="line">   public int compare(int[] m,int [] n)&#123;</span><br><span class="line">   return m[1]-n[1];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line">for(Map.Entry&lt;Integer,Integer&gt; entry: occurrences.entrySet())&#123;</span><br><span class="line">int num&#x3D;entry.getKey(),count&#x3D;entry.getValue();</span><br><span class="line">if(queue.size()&#x3D;&#x3D;k)&#123;</span><br><span class="line">   if(queue.peek()[1]&lt;count)&#123;</span><br><span class="line">     queue.poll();</span><br><span class="line">     queue.offer(new int[]&#123;num,count&#125;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">  queue.offer(new int[]&#123;num,count&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int[] res&#x3D;new int[k];</span><br><span class="line">for(int i&#x3D;0;i&lt;k;++i)</span><br><span class="line">res[i]&#x3D;queue.poll()[0];</span><br><span class="line"> return res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结-3"><a href="#解题思路和知识总结-3" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><ul><li><p>解题思路</p><p>首先创建一个每个数字出现频率的哈希表，key对应相对数字，value对应出现的次数<br>将哈希表中的数据放入小顶堆（容量为k），当value大于堆顶时就放入堆中，这样就<br>得出了出现次数大于k的对应数字</p></li><li><p>知识总结</p><ul><li>Map.getOrDefault(Object key, V defaultValue)方法的作用是：当Map集合中有这个key时，就使用这个key值； 如果没有就使用默认值defaultValue。</li></ul><ul><li><p>Comparator是一个比较器接口，可以用来进行排序。该代码的是一个升序</p></li><li><p>Map.Entry是Map声明的一个内部接口，此接口为泛型，定义为Entry&lt;K,V&gt;。它表示Map中的一个实体（一个key-value对）。接口中有getKey(),getValue方法。</p></li></ul></li></ul><h1 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h1><p><strong><em>tags：贪心算法</em></strong></p><hr><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-199.png" alt="upload successful"></p><h2 id="编写代码-5"><a href="#编写代码-5" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canJump(int[] nums) &#123;</span><br><span class="line">    int n&#x3D;1; </span><br><span class="line">    for(int i&#x3D;nums.length-2;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">    if(nums[i]&gt;&#x3D;n)&#123; </span><br><span class="line">        n&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i&#x3D;&#x3D;0&amp;&amp;n&gt;1)</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结-4"><a href="#解题思路和知识总结-4" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><ul><li><p>解题思路</p><ul><li>从后往前遍历数组，设定一个n值表示所需要跳的次数才能到达终点（因为每个位置允许跳一次，这个指标即可以用来判断是否能到达终点）</li></ul><h1 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h1><hr><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><hr></li></ul><p><img src="/deng123-dev.github.io/images/pasted-202.png" alt="upload successful"></p><h2 id="编写代码-6"><a href="#编写代码-6" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class solution&#123;</span><br><span class="line">pubic int[][]reconstructionQueue(int[][] people)&#123;</span><br><span class="line">Arrays.sort(people,new Comparator&lt;int[]&gt;()&#123;</span><br><span class="line">@Override</span><br><span class="line">public int compare(int[] o1,int[] o2)&#123;</span><br><span class="line">return o1[0]&#x3D;&#x3D;o2[0]?o1[1]-o2[1]:o2[0]-o1[0];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">List&lt;int[]&gt; output &#x3D;new Linkedlist&lt;&gt;();</span><br><span class="line">for(int[] p:people)&#123;</span><br><span class="line">   output.add(p[1],p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int n&#x3D;people.length;</span><br><span class="line">return output.toArray(new int[n][2]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结-5"><a href="#解题思路和知识总结-5" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><ul><li>解题思路</li></ul><p>这道题的思路是将身高h进行降序排序，k进行升序排序，排列好之后，从前到后分别找到每对数组对应的k值将它插入第k个位置，如果前面元素占据该位置就要给它让位</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>springboot （5）</title>
      <link href="/deng123-dev.github.io/2020/09/15/springboot-%EF%BC%885%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/09/15/springboot-%EF%BC%885%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Springboot 整合持久层技术</p><h1 id="整合JDBC"><a href="#整合JDBC" class="headerlink" title="整合JDBC"></a>整合JDBC</h1><hr><h2 id="搭建项目环境"><a href="#搭建项目环境" class="headerlink" title="搭建项目环境"></a>搭建项目环境</h2><hr><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><hr><p>利用navicat创建users表</p><p><img src="/deng123-dev.github.io/images/pasted-196.png" alt="upload successful"></p><a id="more"></a><h3 id="修改pom文件，添加相关依赖"><a href="#修改pom文件，添加相关依赖" class="headerlink" title="修改pom文件，添加相关依赖"></a>修改pom文件，添加相关依赖</h3><hr><p><img src="/deng123-dev.github.io/images/pasted-197.png" alt="upload successful"></p><h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><hr><h3 id="添加durid数据源依赖"><a href="#添加durid数据源依赖" class="headerlink" title="添加durid数据源依赖"></a>添加durid数据源依赖</h3><hr><p><img src="/deng123-dev.github.io/images/pasted-200.png" alt="upload successful"></p><h3 id="创建properties文件"><a href="#创建properties文件" class="headerlink" title="创建properties文件"></a>创建properties文件</h3><hr><p><img src="/deng123-dev.github.io/images/pasted-201.png" alt="upload successful"></p><h3 id="创建数据源的配置类"><a href="#创建数据源的配置类" class="headerlink" title="创建数据源的配置类"></a>创建数据源的配置类</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode知识总结  （3）</title>
      <link href="/deng123-dev.github.io/2020/09/04/leetcode%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-%EF%BC%883%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/09/04/leetcode%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h1><p><strong><em>tags:贪心算法</em></strong></p><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-185.png" alt="upload successful"></p><a id="more"></a><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">    int profit&#x3D;0;</span><br><span class="line">    for(int i&#x3D;1;i&lt;prices.length;i++)&#123;</span><br><span class="line">         if(prices[i]&gt;prices[i-1])</span><br><span class="line">         profit+&#x3D;prices[i]-prices[i-1];</span><br><span class="line">    &#125;</span><br><span class="line">    return profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识"><a href="#解题思路和知识" class="headerlink" title="解题思路和知识"></a>解题思路和知识</h2><hr><ul><li><p>解题思路</p><p>其实只需要当天股票的价格比前一天的价格贵再将其买出去即可</p></li></ul><h1 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h1><p><strong><em>tags:贪心算法，双指针</em></strong></p><hr><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-186.png" alt="upload successful"></p><h2 id="编写代码-1"><a href="#编写代码-1" class="headerlink" title="编写代码"></a>编写代码</h2><hr><p>C语言代码(双指针)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool isSubsequence(char * s, char * t)&#123;</span><br><span class="line">while(*s&amp;&amp;*t)&#123;</span><br><span class="line">if(*s&#x3D;&#x3D;*t)&#123;</span><br><span class="line">s++;</span><br><span class="line">t++;</span><br><span class="line">&#125;</span><br><span class="line">else t++;</span><br><span class="line">&#125;</span><br><span class="line">if(*s&#x3D;&#x3D;&#39;\0&#39;)</span><br><span class="line">return true;</span><br><span class="line">else return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JAVA代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">public boolean isSubsequence(String s,String t)&#123;</span><br><span class="line">int index&#x3D;-1;</span><br><span class="line">for(char c:s.toCharArray())&#123;</span><br><span class="line">index&#x3D;t.indexOf(c,index+1);</span><br><span class="line">if(index&#x3D;&#x3D;1) return false;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识-1"><a href="#解题思路和知识-1" class="headerlink" title="解题思路和知识"></a>解题思路和知识</h2><ul><li><p>解题思路</p><ul><li><p>C语言<br>运用了双指针，子字符串和字符串的指针遍历数组，指针后移，判断子字符串的指针有没有到最后位置</p></li><li><p>java语言<br>，</p><h1 id="平衡分割字符串"><a href="#平衡分割字符串" class="headerlink" title="平衡分割字符串"></a>平衡分割字符串</h1></li></ul></li></ul><p><strong><em>tags:贪心算法，栈</em></strong></p><hr><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-187.png" alt="upload successful"></p><h2 id="编写代码-2"><a href="#编写代码-2" class="headerlink" title="编写代码"></a>编写代码</h2><hr><p>优化前代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int balancedStringSplit(String s) &#123;</span><br><span class="line">    Stack&lt;Character&gt; stackR&#x3D;new Stack&lt;Character&gt;();          </span><br><span class="line">    Stack&lt;Character&gt; stackL&#x3D;new Stack&lt;Character&gt;();</span><br><span class="line">    int count&#x3D;0;</span><br><span class="line">    for(char c:s.toCharArray())&#123;</span><br><span class="line">    if(c&#x3D;&#x3D;&#39;L&#39;) stackR.push(c);</span><br><span class="line">    if(c&#x3D;&#x3D;&#39;R&#39;) stackL.push(c); </span><br><span class="line">    if(stackL.size()&#x3D;&#x3D;stackR.size()) </span><br><span class="line">    count++; </span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int balancedStringSplit(String s) &#123;</span><br><span class="line">        int num &#x3D; 0;</span><br><span class="line">        int n &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            if (s.charAt(i)&#x3D;&#x3D;&#39;R&#39;)</span><br><span class="line">                n++;</span><br><span class="line">            if (s.charAt(i) &#x3D;&#x3D; &#39;L&#39;)</span><br><span class="line">                n--;</span><br><span class="line">            if (n &#x3D;&#x3D; 0)</span><br><span class="line">                num++;</span><br><span class="line">        &#125;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结"><a href="#解题思路和知识总结" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><ul><li>解题思路</li></ul><p>优化后的代码时间复杂度明显降低</p><h1 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h1><p><strong><em>tags:贪心算法</em></strong></p><hr><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-188.png" alt="upload successful"></p><h2 id="编写代码-3"><a href="#编写代码-3" class="headerlink" title="编写代码"></a>编写代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findContentChildren(int[] g, int[] s) &#123;</span><br><span class="line">    int child&#x3D;0;</span><br><span class="line">    int cookie&#x3D;0;</span><br><span class="line">    Arrays.sort(g);</span><br><span class="line">    Arrays.sort(s);</span><br><span class="line">    while(child&lt;g.length&amp;&amp;cookie&lt;s.length)&#123;</span><br><span class="line">    if(g[child]&lt;&#x3D;s[cookie])</span><br><span class="line">    child++;</span><br><span class="line">    cookie++;</span><br><span class="line">     &#125;     </span><br><span class="line">    return child; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结-1"><a href="#解题思路和知识总结-1" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><ul><li><p>解题思路</p><p>需要先将数组进行排序，进行循环，当用当前饼干可以满足当前孩子的需求，可以满足的孩子数量+1，饼干只可以用一次，因为饼干如果小的话，就是无法满足被抛弃，满足的话就是被用了。</p></li></ul><h1 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h1><p><strong><em>tags:贪心算法</em></strong></p><hr><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-189.png" alt="upload successful"></p><h2 id="编写代码-4"><a href="#编写代码-4" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean lemonadeChange(int[] bill)&#123;</span><br><span class="line">    int five&#x3D;0,ten&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;bill.length;i++)&#123;</span><br><span class="line">    if(bill[i]&#x3D;&#x3D;5) five++;</span><br><span class="line">    else if(bill[i]&#x3D;&#x3D;10)&#123;</span><br><span class="line">        ten++;</span><br><span class="line">        five--;</span><br><span class="line">        if(five&lt;0) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(bill[i]&#x3D;&#x3D;20)&#123;</span><br><span class="line">        if(ten&#x3D;&#x3D;0)</span><br><span class="line">        five&#x3D;five-3;</span><br><span class="line">        else if(ten&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            five--;</span><br><span class="line">            ten--;</span><br><span class="line">        &#125;    </span><br><span class="line">       if(five&lt;0) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结-2"><a href="#解题思路和知识总结-2" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><ul><li><p>解题思路</p><p>设置five和ten两个变量，设置循环，</p><p>对应得到的不同的情况对应的值加上或者减去对应数值</p><p>当所得值为20时，分为两种情况十元够时，用十元返还，十元不够时，用5元返还</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode知识总结（2）</title>
      <link href="/deng123-dev.github.io/2020/07/26/leetcode%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%882%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/07/26/leetcode%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="删除最外层的括号"><a href="#删除最外层的括号" class="headerlink" title="删除最外层的括号"></a>删除最外层的括号</h1><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-178.png" alt="upload successful"></p><a id="more"></a><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;   </span><br><span class="line">    public String removeOuterParentheses(String S) &#123;</span><br><span class="line">    int level&#x3D;0;&#x2F;&#x2F;定义当前括号在里面第几层</span><br><span class="line">    StringBuilder s&#x3D;new StringBuilder();</span><br><span class="line">    for(char c:S.toCharArray())&#123;</span><br><span class="line">    if(c&#x3D;&#x3D;&#39;)&#39;) level--;&#x2F;&#x2F;当遇到‘）‘时退出一层</span><br><span class="line">    if(level&gt;0) s.append(c);</span><br><span class="line">    if(c&#x3D;&#x3D;&#39;(&#39;) level++;&#x2F;&#x2F;当遇到’（‘时进入一层</span><br><span class="line">    &#125;</span><br><span class="line">    return s.toString();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><hr><ul><li><p>知识总结</p><p>StringBuilder和StringBuffer是String类的同伴类。它们表示一个可变的字符序列。   StringBuffer是线程安全的，StringBuilder不是线程安全的。</p></li></ul><h1 id="删除字符串的所有相邻重复项"><a href="#删除字符串的所有相邻重复项" class="headerlink" title="删除字符串的所有相邻重复项"></a>删除字符串的所有相邻重复项</h1><hr><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-179.png" alt="upload successful"></p><h2 id="编写代码-1"><a href="#编写代码-1" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String removeDuplicates(String S) &#123;</span><br><span class="line">    Stack&lt;Character&gt; stack&#x3D;new Stack&lt;&gt;();</span><br><span class="line">    for(char c: S.toCharArray())&#123;&#x2F;&#x2F;进行删除重复字符串的操作</span><br><span class="line">        if(stack.isEmpty()||c!&#x3D;stack.peek())</span><br><span class="line">        stack.push(c);</span><br><span class="line">        else stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder s&#x3D;new StringBuilder();&#x2F;&#x2F;将栈的数据结构变成字符串形式</span><br><span class="line">    for(char c:stack)</span><br><span class="line">    s.append(c);</span><br><span class="line">    return s.toString();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="用栈操作构建数组"><a href="#用栈操作构建数组" class="headerlink" title="用栈操作构建数组"></a>用栈操作构建数组</h1><hr><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-180.png" alt="upload successful"></p><h2 id="编写代码-2"><a href="#编写代码-2" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; buildArray(int[] target, int n) &#123;</span><br><span class="line">    List&lt;String&gt; result &#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">    for(int i&#x3D;1,j&#x3D;0;i&lt;&#x3D;n&amp;&amp;j&lt;target.length;i++)&#123;&#x2F;&#x2F;元素从1到n开始循环，target数组元素和循环元素作比较</span><br><span class="line">    if(i&lt;target[j])&#123;&#x2F;&#x2F;如果当前循环元素比target数组元素小</span><br><span class="line">    result.add(&quot;Push&quot;);</span><br><span class="line">    result.add(&quot;Pop&quot;);</span><br><span class="line">    &#125;  </span><br><span class="line">    else if(i&#x3D;&#x3D;target[j])&#123;&#x2F;&#x2F;如果当前循环元素和target元素相同，则target数组指向下一个</span><br><span class="line">        result.add(&quot;Push&quot;);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;     </span><br><span class="line">     &#125;</span><br><span class="line">     return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="知识总结-1"><a href="#知识总结-1" class="headerlink" title="知识总结"></a>知识总结</h2><hr><ul><li><p>相关知识</p><ul><li><p>创建动态数组操作</p><p>List<String> list =new ArrayList&lt;&gt;();</p></li><li><p>往线性表中添加元素</p><p>list.add()</p></li></ul></li></ul><h1 id="整理字符串"><a href="#整理字符串" class="headerlink" title="整理字符串"></a>整理字符串</h1><p><strong><em>tags:栈</em></strong></p><hr><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-181.png" alt="upload successful"></p><h2 id="编写代码-3"><a href="#编写代码-3" class="headerlink" title="编写代码"></a>编写代码</h2><hr><ul><li>第一种代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class solution&#123;</span><br><span class="line">public String makeGood(String s)&#123;</span><br><span class="line">if(s.length()&#x3D;&#x3D;0||s.length()&#x3D;&#x3D;1) return s;</span><br><span class="line">Stack&lt;Character&gt; stack &#x3D;new Stack&lt;&gt;();</span><br><span class="line">for(int i&#x3D;0;i&lt;s.length();i++)&#123;</span><br><span class="line">char cur&#x3D;s.charAt(i);</span><br><span class="line">if(stack.isEmpty())&#123;</span><br><span class="line">stack.push(s.charAt(i));</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">char tmp&#x3D;stack.peek();</span><br><span class="line">if(cur-tmp&#x3D;32||cur-tmp&#x3D;&#x3D;-32)&#123;</span><br><span class="line"> stack.pop();</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">  stack.push(cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String res&#x3D;&quot;&quot;;</span><br><span class="line">while(!stack.isEmpty())&#123;</span><br><span class="line">res+&#x3D;String.valueOf(stack.peek());</span><br><span class="line">stack.pop();</span><br><span class="line">&#125;</span><br><span class="line"> StringBuilder sb&#x3D;new StringBuilder(res);</span><br><span class="line"> return sb.reverse().toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>第二种代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String makeGood(String s) &#123;</span><br><span class="line">    Stack&lt;Character&gt; characterstorage&#x3D;new Stack&lt;&gt;();    </span><br><span class="line">    for(char character:s.toCharArray())&#123;</span><br><span class="line">    if(!characterstorage.isEmpty())&#123;</span><br><span class="line">    if(character-characterstorage.peek()&#x3D;&#x3D;32||character-characterstorage.peek()&#x3D;&#x3D;-32) </span><br><span class="line">    characterstorage.pop();</span><br><span class="line">    else characterstorage.push(character);</span><br><span class="line">    &#125;</span><br><span class="line">    else characterstorage.push(character);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    StringBuilder sb&#x3D;new StringBuilder();</span><br><span class="line">    while(!characterstorage.isEmpty())</span><br><span class="line">    sb.append(characterstorage.pop());</span><br><span class="line">    return sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路和知识"><a href="#解题思路和知识" class="headerlink" title="解题思路和知识"></a>解题思路和知识</h2><hr><ul><li><p>相关知识</p><ul><li>charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。</li></ul></li></ul><h1 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h1><p><strong><em>tags:堆</em></strong></p><hr><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-182.png" alt="upload successful"></p><h2 id="编写代码-4"><a href="#编写代码-4" class="headerlink" title="编写代码"></a>编写代码</h2><hr><ul><li>第一种代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line">class Solution&#123;</span><br><span class="line"> public int[]getLeastNumbers(int[] arr,int k)&#123;</span><br><span class="line"> int len&#x3D;arr.length;</span><br><span class="line"> if(k&#x3D;&#x3D;0||k&gt;len)</span><br><span class="line"> return new int [0];</span><br><span class="line"> PriorityQueue &lt;Integer&gt; maxHeap&#x3D;new PriorityQueue&lt;&gt;(k,(o1,o2)-&gt; - o1 + o2);</span><br><span class="line"> for(int i&#x3D;0;i&lt;k;i++)</span><br><span class="line"> maxHeap.add(arr[i]);</span><br><span class="line"> for(int i&#x3D;k;i&lt;len;i++)&#123;</span><br><span class="line"> Integer head &#x3D;maxHeap.peek();</span><br><span class="line"> if(head&gt;arr[i])&#123;</span><br><span class="line"> maxHeap.poll();</span><br><span class="line"> maxHeap.add(arr[i]);  </span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return Arrays.stream(maxHeap.toArray(new Integer[0])).mapToInt(Integer::valueOf).toArray();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">public static void main(String args)&#123;</span><br><span class="line">Solution solution &#x3D;new Solution();</span><br><span class="line">int[] arr&#x3D;&#123;3,2,1&#125;;</span><br><span class="line">int k&#x3D;2;</span><br><span class="line">int [] res&#x3D;getLeastNumbers(arr,k);</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(res));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二种代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] getLeastNumbers(int[] arr, int k) &#123;</span><br><span class="line">    int[] vec&#x3D;new int [k];</span><br><span class="line">    PriorityQueue&lt;Integer&gt; queue&#x3D;new PriorityQueue&lt;Integer&gt;(new Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">  public int compare(Integer num1,Integer num2)&#123;</span><br><span class="line">      return num2-num1;</span><br><span class="line">  &#125;&#x2F;&#x2F;建立一个大根堆</span><br><span class="line">&#125;);</span><br><span class="line">for(int i&#x3D;0;i&lt;k;++i)&#123;</span><br><span class="line">   queue.offer(arr[i]);&#x2F;&#x2F;用传入元素k为大小初始化大根堆并将前k个数组元素放入其中</span><br><span class="line">&#125;</span><br><span class="line">for(int i&#x3D;k;i&lt;arr.length;++i)&#123;</span><br><span class="line">    if(!queue.isEmpty()&amp;&amp;arr[i]&lt;queue.peek())&#123;&#x2F;&#x2F;当数组元素小于大根堆顶时，将其交换</span><br><span class="line">     queue.poll();</span><br><span class="line">     queue.offer(arr[i]);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i&#x3D;0;i&lt;k;++i)&#123;</span><br><span class="line">    vec[i]&#x3D;queue.poll();&#x2F;&#x2F;将大根堆元素放置在数组里</span><br><span class="line">&#125;</span><br><span class="line">return vec;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="知识总结-2"><a href="#知识总结-2" class="headerlink" title="知识总结"></a>知识总结</h2><hr><ul><li><p>PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>(); //小顶堆，默认容量为11</p></li><li><p>PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(11,new Comparator<Integer>(){ //大顶堆，容量11</p></li></ul><h1 id="最后一个石头的重量"><a href="#最后一个石头的重量" class="headerlink" title="最后一个石头的重量"></a>最后一个石头的重量</h1><p><strong><em>tags:堆</em></strong></p><hr><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-183.png" alt="upload successful"></p><h2 id="编写代码-5"><a href="#编写代码-5" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lastStoneWeight(int[] stones) &#123;</span><br><span class="line">    PriorityQueue &lt;Integer&gt; stonegroup &#x3D;new PriorityQueue&lt;&gt;(6,(o1,o2)-&gt;o2-o1);&#x2F;&#x2F;建立大根堆</span><br><span class="line">    for(int i:stones)&#123;</span><br><span class="line">    stonegroup.offer(i);&#x2F;&#x2F;将所有石头放入堆中</span><br><span class="line">    &#125;</span><br><span class="line">    while(stonegroup.size()&gt;&#x3D;2)&#123;&#x2F;&#x2F;当堆中石头数量大于2时</span><br><span class="line">    int x&#x3D;stonegroup.poll();</span><br><span class="line">    int y&#x3D;stonegroup.poll();</span><br><span class="line">    if(x&gt;&#x3D;y)</span><br><span class="line">    stonegroup.offer(x-y);&#x2F;&#x2F;粉碎石头</span><br><span class="line">    else     </span><br><span class="line">    stonegroup.offer(y-x);</span><br><span class="line">    &#125;</span><br><span class="line">    return stonegroup.size()&#x3D;&#x3D;1?stonegroup.peek():0;&#x2F;&#x2F;最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。</span><br><span class="line">    &#125;                                            </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识-1"><a href="#解题思路和知识-1" class="headerlink" title="解题思路和知识"></a>解题思路和知识</h2><hr><ul><li>解题思路</li></ul><p>将数据压入大根堆，通过循环进行操作</p><h1 id="数据流中的第k大元素"><a href="#数据流中的第k大元素" class="headerlink" title="数据流中的第k大元素"></a>数据流中的第k大元素</h1><p><strong><em>tags:堆</em></strong></p><hr><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-184.png" alt="upload successful"></p><h2 id="编写代码-6"><a href="#编写代码-6" class="headerlink" title="编写代码"></a>编写代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class KthLargest&#123;</span><br><span class="line">  final PriorityQueue&lt;Integer&gt; q;</span><br><span class="line">  final int k;</span><br><span class="line">  public KthLargest(int k, int[] nums) &#123;</span><br><span class="line">  this.k&#x3D;k;</span><br><span class="line">  q&#x3D;new PriorityQueue&lt;Integer&gt;(k);</span><br><span class="line">  for(int i;nums)</span><br><span class="line">  add(i);</span><br><span class="line">  &#125;</span><br><span class="line">  public int add(int val)&#123;</span><br><span class="line">  if(q.size()&lt;k)</span><br><span class="line">  q.offer(val);</span><br><span class="line">  else if(val&gt;q.peek())</span><br><span class="line">  q.poll();</span><br><span class="line">  q.offer(val);</span><br><span class="line">&#125;</span><br><span class="line"> return q.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识-2"><a href="#解题思路和知识-2" class="headerlink" title="解题思路和知识"></a>解题思路和知识</h2><ul><li>解题思路</li></ul><p>建立小根堆，将数据填满小根堆，填满后，将待添入元素和栈顶元素（小根堆的栈顶元素最小）作比较，如果比栈顶元素大就放入堆中，这个就实现了最大的几个数这个功能，然后直接取栈顶元素</p><ul><li><p>知识总结</p><p>java中的final关键字：</p><ul><li><p>修饰类：表示这个类不能被继承</p></li><li><p>修饰方法：想要该方法在被子类继承的时候被覆盖</p></li><li><p>修饰变量：如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</p></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 知识总结（1）</title>
      <link href="/deng123-dev.github.io/2020/07/06/leetcode-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%881%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/07/06/leetcode-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h1><p><strong><em>tags: 栈</em></strong></p><hr><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-151.png" alt="upload successful"></p><a id="more"></a><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><hr><ul><li><p>JAVA: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">    Stack&lt;Character&gt; stack&#x3D;new Stack&lt;&gt;();</span><br><span class="line">    for(char c:s.toCharArray())&#123;</span><br><span class="line">    if(c&#x3D;&#x3D;&#39;(&#39;) stack.push(&#39;)&#39;);</span><br><span class="line">    else if(c&#x3D;&#x3D;&#39;[&#39;) stack.push(&#39;]&#39;);</span><br><span class="line">    else if(c&#x3D;&#x3D;&#39;&#123;&#39;) stack.push(&#39;&#125;&#39;);</span><br><span class="line">    else if(stack.isEmpty()||c!&#x3D;stack.pop()) </span><br><span class="line">    return false;</span><br><span class="line">    &#x2F;&#x2F;stack.isEmpty()判断前括号比较少的情况，c!&#x3D;stack.pop()判断对应位置的括号是否相同</span><br><span class="line">    &#125;</span><br><span class="line">    return stack.isEmpty();&#x2F;&#x2F;判断后括号比较少的情况</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><hr><ul><li>解题思路</li></ul><p><img src="/deng123-dev.github.io/images/pasted-147.png" alt="upload successful"></p><ul><li><p>知识总结</p><ul><li><p><code>for(char c:s.toCharArray())</code>把char类型的s元素赋值给c，再执行循环</p></li><li><p><code>toCharArray()</code>toCharArray() 方法将字符串转换为字符数组。</p></li></ul></li></ul><h1 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h1><p><strong><em>tags: 栈</em></strong></p><hr><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-149.png" alt="upload successful"></p><h2 id="编写代码-1"><a href="#编写代码-1" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class MinStack &#123;</span><br><span class="line">    int min&#x3D;Integer.MAX_VALUE;</span><br><span class="line">    Stack&lt;Integer&gt; stack;</span><br><span class="line">    &#x2F;** initialize your data structure here. *&#x2F;</span><br><span class="line">    public MinStack() &#123;</span><br><span class="line">    stack&#x3D;new Stack&lt;&gt;();    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">    if(x&lt;&#x3D;min)&#123;&#x2F;&#x2F;判断数据是否是最小的元素</span><br><span class="line">      stack.push(min);&#x2F;&#x2F;如果是的话，就将上一个最小元素压入栈</span><br><span class="line">      min&#x3D;x; &#x2F;&#x2F;将x赋给最小值     </span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void pop() &#123;</span><br><span class="line">     if(stack.pop()&#x3D;&#x3D;min)&#123;&#x2F;&#x2F;判断出栈元素是否是最小值</span><br><span class="line">        min&#x3D;stack.pop(); &#x2F;&#x2F;如果是就将再出栈一个元素并将它赋给最小值</span><br><span class="line">     &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int top() &#123;</span><br><span class="line">    return stack.peek(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getMin() &#123;</span><br><span class="line">    return min;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结"><a href="#解题思路和知识总结" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><ul><li><p>解题思路 </p><p>定义一个最小值min。<br>入栈时：向栈中压入一个元素时，将它与min作比较，如果比min小，就先将min的值压入栈中，然后将元素的值赋给min<br>出栈时：栈顶元素和min作比较，如果相等，将元素出栈后再将其赋给min</p></li><li><p>知识总结（栈的基本操作）</p><ul><li><p>创建栈：private Stack<Integer> datastack;</p></li><li><p>入栈操作：push</p></li><li><p>出栈操作：pop</p></li><li><p>判断栈空：isEmpty</p></li><li><p>取栈顶：peek</p></li></ul></li></ul><h1 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h1><p><strong><em>tags:栈</em></strong></p><hr><h2 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-152.png" alt="upload successful"></p><h2 id="编写代码-2"><a href="#编写代码-2" class="headerlink" title="编写代码"></a>编写代码</h2><hr><p>第一种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class MyStack &#123;</span><br><span class="line">     Queue &lt;Integer&gt;mainqueue;&#x2F;&#x2F;输出队列</span><br><span class="line">     Queue &lt;Integer&gt;helpqueue;&#x2F;&#x2F;辅助队列</span><br><span class="line">    &#x2F;** Initialize your data structure here. *&#x2F;</span><br><span class="line">    public MyStack() &#123;</span><br><span class="line">    mainqueue&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">    helpqueue&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Push element x onto stack. *&#x2F;</span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">    while(!mainqueue.isEmpty()) </span><br><span class="line">    helpqueue.offer(mainqueue.poll());&#x2F;&#x2F;将输出队列除当前需插入元素之外的其他所有元素放入辅助队列</span><br><span class="line">    mainqueue.offer(x);&#x2F;&#x2F;元素入队</span><br><span class="line">    while(!helpqueue.isEmpty())</span><br><span class="line">    mainqueue.offer(helpqueue.poll());&#x2F;&#x2F;将存放在辅助队列里的元素重新放回输出队列</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Removes the element on top of the stack and returns that element. *&#x2F;</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">    return mainqueue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Get the top element. *&#x2F;</span><br><span class="line">    public int top() &#123;</span><br><span class="line">     return mainqueue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Returns whether the stack is empty. *&#x2F;</span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">      return mainqueue.isEmpty();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class MyStack</span><br><span class="line">&#123;</span><br><span class="line">private Queue &lt;Integer&gt; a;</span><br><span class="line">private Queue &lt;Integer&gt; b;</span><br><span class="line">private int top;</span><br><span class="line">public MyStack()&#123;</span><br><span class="line">a&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">b&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public  void push()&#123;</span><br><span class="line">a.offer(x);</span><br><span class="line">top&#x3D;x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int pop()&#123;</span><br><span class="line">while(a.size()&gt;1)</span><br><span class="line">b.offer(a.poll());</span><br><span class="line">int t&#x3D;a.peek();</span><br><span class="line">a.poll();</span><br><span class="line">Queue tmp&#x3D;a;</span><br><span class="line">a&#x3D;b;</span><br><span class="line">b&#x3D;tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void gettop()&#123;</span><br><span class="line">return top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void empty()&#123;</span><br><span class="line">return a.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总结-1"><a href="#解题思路和知识总结-1" class="headerlink" title="解题思路和知识总结"></a>解题思路和知识总结</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-153.png" alt="upload successful"></p><ul><li><p>知识总结</p><ul><li><p>创建队列： Queue<String> q = new LinkedList<String>() </p></li><li><p>添加元素：offer</p></li><li><p>返回第1个元素并将它删除：poll</p></li><li><p>返回第一个元素：peek</p></li></ul></li></ul><h1 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h1><p><strong><em>tags:栈</em></strong></p><hr><h2 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-154.png" alt="upload successful"></p><h2 id="编写代码-3"><a href="#编写代码-3" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class MyQueue &#123;</span><br><span class="line">    private Stack&lt;Integer&gt; a;&#x2F;&#x2F;数据栈</span><br><span class="line">    private Stack&lt;Integer&gt; b;&#x2F;&#x2F;临时栈</span><br><span class="line">    &#x2F;** Initialize your data structure here. *&#x2F;</span><br><span class="line">    public MyQueue() &#123;</span><br><span class="line">    a&#x3D;new Stack&lt;&gt;();</span><br><span class="line">    b&#x3D;new Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** 初始化你的数据结构 *&#x2F;</span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">    while(!a.isEmpty())</span><br><span class="line">    b.push(a.pop());</span><br><span class="line">    a.push(x);</span><br><span class="line">    while(!b.isEmpty())</span><br><span class="line">    a.push(b.pop());</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**从队头删除元素并返回该元素*&#x2F;</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">    return  a.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** 返回头元素 *&#x2F;</span><br><span class="line">    public int peek() &#123;</span><br><span class="line">     return a.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** 判断队列是否为空 *&#x2F;</span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">    return a.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路和知识总计"><a href="#解题思路和知识总计" class="headerlink" title="解题思路和知识总计"></a>解题思路和知识总计</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-155.png" alt="upload successful"></p><h1 id="下一个更大元素"><a href="#下一个更大元素" class="headerlink" title="下一个更大元素"></a>下一个更大元素</h1><p><strong><em>tag:栈</em></strong></p><hr><h2 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-161.png" alt="upload successful"></p><h2 id="编写代码-4"><a href="#编写代码-4" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack&#x3D;new Stack&lt;&gt;();</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; hm&#x3D;new HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">    int[] result&#x3D;new int [nums1.length];&#x2F;&#x2F;返回结果的数组</span><br><span class="line">    for(int num:nums2)&#123;</span><br><span class="line">    while(!stack.isEmpty()&amp;&amp;num&gt;stack.peek())&#x2F;&#x2F;当数据大于栈顶元素</span><br><span class="line">    hm.put(stack.pop(),num);&#x2F;&#x2F;栈顶元素出栈和当前比它大的数据放入hash表组成key-value</span><br><span class="line">    stack.push(num);</span><br><span class="line">    &#125; </span><br><span class="line">    for(int i&#x3D;0;i&lt;nums1.length;i++)&#123;</span><br><span class="line">    result[i]&#x3D;hm.getOrDefault(nums1[i],-1);&#x2F;&#x2F;返回每个key所对应的value值，如果没有则默认返回-1</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="知识总计"><a href="#知识总计" class="headerlink" title="知识总计"></a>知识总计</h2><hr><ul><li><p>知识总结</p><ul><li><p>创建hash表</p><p>HashMap<Integer> hash=new HashMap<Integer>();</p></li><li><p>hash的put方法</p><p> hash（key，value）</p></li><li><p>hash获取默认值的方法</p><p>hash.getOrDeault(key,默认值)</p></li></ul></li></ul><h1 id="棒球比赛"><a href="#棒球比赛" class="headerlink" title="棒球比赛"></a>棒球比赛</h1><p><strong><em>tags:栈</em></strong></p><hr><h2 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-164.png" alt="upload successful"></p><h2 id="编写代码-5"><a href="#编写代码-5" class="headerlink" title="编写代码"></a>编写代码</h2><hr><ul><li>第一种代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int calPoints(String[] ops) &#123;</span><br><span class="line">    Stack&lt;Integer&gt; scores&#x3D;new Stack&lt;&gt;();</span><br><span class="line">    int sums&#x3D;0 ; </span><br><span class="line">    for(String s:ops)&#123;</span><br><span class="line">    if(s.equals(&quot;+&quot;)&amp;&amp;!scores.isEmpty())&#123;&#x2F;&#x2F;本轮得分是前两轮得分总和</span><br><span class="line">        int sum&#x3D;0;</span><br><span class="line">        int second&#x3D;scores.pop();&#x2F;&#x2F;取出第二个需要相加的数据</span><br><span class="line">        if(!scores.isEmpty())&#x2F;&#x2F;判断栈空</span><br><span class="line">        sum&#x3D;second+scores.peek();&#x2F;&#x2F;第一个数据和第二个数据相加</span><br><span class="line">        scores.push(second);&#x2F;&#x2F;将第二个数据放入栈中</span><br><span class="line">        scores.push(sum);&#x2F;&#x2F;将相加结果放入栈中</span><br><span class="line">    &#125;</span><br><span class="line">    else if(s.equals(&quot;D&quot;)&amp;&amp;!scores.isEmpty())&#123;&#x2F;&#x2F;本轮得分是前一轮得分的双倍</span><br><span class="line">    int doubles&#x3D;scores.peek()*2;</span><br><span class="line">    scores.push(doubles);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(s.equals(&quot;C&quot;)&amp;&amp;!scores.isEmpty())&#123;&#x2F;&#x2F;前一轮得分无效</span><br><span class="line">    scores.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else &#123;</span><br><span class="line">    scores.push(Integer.valueOf(s));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(!scores.isEmpty())&#123;&#x2F;&#x2F;将之前所得得分全部相加</span><br><span class="line">    sums+&#x3D;scores.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return sums;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二种代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int calPoints(String[] ops) &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack&#x3D;new Stack();</span><br><span class="line">    int sum&#x3D;0;</span><br><span class="line">    for(String c:ops)&#123;</span><br><span class="line">      if(c.equals(&quot;D&quot;)&amp;&amp;!stack.isEmpty()) &#123;</span><br><span class="line">      stack.push(stack.peek()*2);              </span><br><span class="line">     sum+&#x3D;stack.peek();                          </span><br><span class="line">      &#125;  </span><br><span class="line">     else if(c.equals(&quot;C&quot;)&amp;&amp;!stack.isEmpty())&#123;</span><br><span class="line">      sum-&#x3D;stack.peek();</span><br><span class="line">      stack.pop();</span><br><span class="line">      &#125;    </span><br><span class="line">     else if(c.equals(&quot;+&quot;)&amp;&amp;!stack.isEmpty())&#123;</span><br><span class="line">        int top&#x3D;stack.pop();</span><br><span class="line">        int newtop&#x3D;top+stack.peek();</span><br><span class="line">        stack.push(top);</span><br><span class="line">        stack.push(newtop);</span><br><span class="line">        sum+&#x3D;stack.peek();</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">          stack.push(Integer.valueOf(c));  </span><br><span class="line">          sum+&#x3D;Integer.valueOf(c);         </span><br><span class="line">       &#125;                                      </span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="知识总计-1"><a href="#知识总计-1" class="headerlink" title="知识总计"></a>知识总计</h2><hr><ul><li><p>知识总结</p><ul><li><p>变量.equals(值)</p><p> 用于单纯的值相等，“==”对对象而言是看是否指向同一个引用</p></li><li><p>Integer valueOf(int i)：返回一个表示指定的 int 值的 Integer 实例。</p></li><li><p>Integer valueOf(String s):返回保存指定的 String 的值的 Integer 对象。</p></li><li><p>Integer valueOf(String s, int radix): 返回一个 Integer 对象，该对象中保存了用第二个参数提供的基数进行解析时从指定的 String 中提取的值。</p></li></ul></li></ul><h1 id="比较含退格符的字符串"><a href="#比较含退格符的字符串" class="headerlink" title="比较含退格符的字符串"></a>比较含退格符的字符串</h1><p><strong><em>tags:栈</em></strong></p><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-177.png" alt="upload successful"></p><h2 id="编写代码-6"><a href="#编写代码-6" class="headerlink" title="编写代码"></a>编写代码</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean backspaceCompare(String S, String T) &#123;</span><br><span class="line">        return build(S).equals(build(T));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String build(String S) &#123;</span><br><span class="line">        Stack&lt;Character&gt; ans &#x3D; new Stack();</span><br><span class="line">        for (char c: S.toCharArray()) &#123;</span><br><span class="line">            if (c !&#x3D; &#39;#&#39;)</span><br><span class="line">                ans.push(c);</span><br><span class="line">            else if (!ans.empty())</span><br><span class="line">                ans.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return String.valueOf(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot（4）</title>
      <link href="/deng123-dev.github.io/2020/06/04/springboot%EF%BC%884%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/06/04/springboot%EF%BC%884%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是JSP"><a href="#什么是JSP" class="headerlink" title="什么是JSP"></a>什么是JSP</h1><hr><p>视图层技术</p><p>JSP全称Java Server Pages，是一种动态网页开发技术，JAVA+html的复合体。它使用JSP标签在HTML网页中插入Java代码。标签通常以&lt;%开头以%&gt;结束。</p><p>JSP是一种Java servlet，主要用于实现Java web应用程序的用户界面部分。网页开发者们通过结合HTML代码、XHTML代码、XML元素以及嵌入JSP操作和命令来编写JSP。</p><p>JSP通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页。</p><a id="more"></a><h1 id="springboot整合Thymeleaf"><a href="#springboot整合Thymeleaf" class="headerlink" title="springboot整合Thymeleaf"></a>springboot整合Thymeleaf</h1><hr><h2 id="Thymeleaf介绍"><a href="#Thymeleaf介绍" class="headerlink" title="Thymeleaf介绍"></a>Thymeleaf介绍</h2><hr><p>简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP，通常后端程序员要根据前端程序员做出的页面进行具体业务的实现，因为JSP和html不能直接复用，如果用JSP作为视图技术，那么对于html页面的内容难复用，但是Thymeleaf能够对html数据渲染。</p><p>Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。<strong>这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。</strong></p><p>注意：</p><ul><li><p>Thymeleaf适合做单体应用</p></li><li><p>Thymeleaf不适合做基于服务的，分布式，前后端分离，那就无法体现其特点</p></li></ul><h2 id="Thymeleaf基本使用"><a href="#Thymeleaf基本使用" class="headerlink" title="Thymeleaf基本使用"></a>Thymeleaf基本使用</h2><hr><ol><li>修改pom文件</li></ol><p><img src="/deng123-dev.github.io/images/pasted-129.png" alt="upload successful"></p><ol start="2"><li>创建页面跳转的controller类 </li></ol><p><strong>注意：因为templates比static安全性更高。所以不能通过url直接访问templates中的文件,所以要做一个页面跳转类实现页面跳转</strong></p><p><img src="/deng123-dev.github.io/images/pasted-130.png" alt="upload successful"></p><ol start="3"><li>创建视图</li></ol><p><img src="/deng123-dev.github.io/images/pasted-131.png" alt="upload successful"></p><ol start="4"><li>测试结果</li></ol><p><img src="/deng123-dev.github.io/images/pasted-132.png" alt="upload successful"></p><h2 id="Thymeleaf迭代遍历-th-each"><a href="#Thymeleaf迭代遍历-th-each" class="headerlink" title="Thymeleaf迭代遍历:th:each"></a>Thymeleaf迭代遍历:th:each</h2><hr><p>th:each:用于循环迭代集合</p><ol><li>创建一个user实体类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-133.png" alt="upload successful"></p><ol start="2"><li>配置pagecontroller类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-134.png" alt="upload successful"></p><ol start="3"><li>创建视图层</li></ol><p><img src="/deng123-dev.github.io/images/pasted-138.png" alt="upload successful"></p><p><strong><em>关键在于这里的th:each 迭代了list中的内容来创建表格</em></strong></p><ol start="4"><li>测试结果</li></ol><p><img src="/deng123-dev.github.io/images/pasted-135.png" alt="upload successful"></p><h2 id="th-each状态变量"><a href="#th-each状态变量" class="headerlink" title="th:each状态变量"></a>th:each状态变量</h2><hr><table><thead><tr><th>状态变量</th><th>对应解释</th></tr></thead><tbody><tr><td>index</td><td>当前迭代器的索引，从0开始</td></tr><tr><td>count</td><td>当前迭代对象的计数，从1开始</td></tr><tr><td>size</td><td>迭代对象长度</td></tr><tr><td>odd/even</td><td>布尔值，当前循环是否为偶数/奇数 从0开始</td></tr><tr><td>first</td><td>布尔值，判断当前循环是否是第一条</td></tr><tr><td>last</td><td>布尔值，判断当前循环是否是最后一条</td></tr></tbody></table><ol><li>创建视图层</li></ol><p><img src="/deng123-dev.github.io/images/pasted-139.png" alt="upload successful"></p><p><strong>注意一下状态变量的语法结构（在图中已用红圈划出来）</strong></p><ol start="2"><li>测试结果</li></ol><p><img src="/deng123-dev.github.io/images/pasted-140.png" alt="upload successful"></p><h2 id="th-each迭代Map"><a href="#th-each迭代Map" class="headerlink" title="th:each迭代Map"></a>th:each迭代Map</h2><hr><ol><li>配置PageController类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-141.png" alt="upload successful"></p><ol start="2"><li>创建视图层</li></ol><p><img src="/deng123-dev.github.io/images/pasted-142.png" alt="upload successful"></p><ol start="3"><li>测试结果</li></ol><p><img src="/deng123-dev.github.io/images/pasted-143.png" alt="upload successful"></p><p><strong><em>这里的是以键值对（key-value）出现</em></strong></p><p><strong><em>不过上述是无法访问到user当中的属性，如果需要访问属性，则需要修改视图层的代码</em></strong></p><ol><li>创建视图层</li></ol><p><img src="/deng123-dev.github.io/images/pasted-145.png" alt="upload successful"></p><p><strong><em>请注意map有两个属性，key和value，key取的是上方测试结果中等号左侧部分，value取的是右侧部分，也只有value才能引出user当中的属性</em></strong></p><ol start="2"><li>测试结果</li></ol><p><img src="/deng123-dev.github.io/images/pasted-146.png" alt="upload successful"></p><h2 id="Thymeleaf的URL表达式"><a href="#Thymeleaf的URL表达式" class="headerlink" title="Thymeleaf的URL表达式"></a>Thymeleaf的URL表达式</h2><hr><ol><li>语法格式</li></ol><p>Thymeleaf中URL表达式的语法格式为@{}</p><ol start="2"><li><p>URL类型</p><ul><li><p>绝对路径<br><code>&lt;a th:href=&quot;@{网站的URL}&quot;&gt;网站名称&lt;a/&gt;</code></p></li><li><p>相对路径</p><ul><li>相对于当前项目的根</li></ul><p><code>&lt;a th:href=&quot;@{/项目的根}&quot;&gt;根名称&lt;a/&gt;</code></p><ul><li>相对于服务器路径的根 </li></ul><p><code>&lt;a th:href=&quot;@{~/项目名称/项目下访问的资源}&quot;&gt;相对于服务器的根路径&lt;a/&gt;</code></p></li></ul></li></ol><h2 id="在URL中传递参数"><a href="#在URL中传递参数" class="headerlink" title="在URL中传递参数"></a>在URL中传递参数</h2><hr><ol><li><p>在普通格式的URL中传递参数</p><ul><li>第一种传参方法</li></ul><p><code>&lt;a th:href=&quot;@{/show?id=1&amp;name=admin}&quot;&gt;名称&lt;a/&gt;</code></p><ul><li>第二种传参方法</li></ul><p><code>&lt;a th:href=&quot;@{/show(id=1&amp;name=admin)}&quot;&gt;名称&lt;a/&gt;</code></p><ul><li>第三种传参方式</li></ul><p><code>&lt;a th:href=&quot;@{&#39;/show?id=&#39;${id}+&#39;&amp;name=&#39;+${name})&quot;&gt;名称&lt;a/&gt;</code></p><p><strong><em>这种方式需要在PageController中添加属性,然后将值传给它</em></strong></p><ul><li>第四种传参方式</li></ul><p><code>&lt;a th:href=&quot;@{/show(id=${id}&amp;name=${name}})&quot;&gt;名称&lt;a/&gt;</code></p><p><strong><em>这种方式需要在PageController中添加属性</em></strong></p></li><li><p>restful 格式的URL中传递参数</p><ul><li><p>第一种传参方式</p><p><code>&lt;a th:href=&quot;@{/show/{id}(id=1)}&quot;&gt;名称&lt;a/&gt;</code> </p></li><li><p>第二种传参方式</p><p><code>&lt;a th:href=&quot;@{/show/{id}/{name}(id=1，name=admin)}&quot;&gt;名称&lt;a/&gt;</code> </p></li><li><p>第三种传参方式</p><p><code>&lt;a th:href=&quot;@{/show/{id}(id=1，name=admin)}&quot;&gt;名称&lt;a/&gt;</code> </p></li><li><p>第四种传参方式</p><p><code>&lt;a th:href=&quot;@{/show/{id}(id=${id}，name=${name})}&quot;&gt;名称&lt;a/&gt;</code> </p><p>  <strong><em>这种方式需要在PageController中添加属性,然后将值传给它</em></strong></p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot（3）</title>
      <link href="/deng123-dev.github.io/2020/05/31/springboot%EF%BC%883%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/05/31/springboot%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="springboot访问静态资源"><a href="#springboot访问静态资源" class="headerlink" title="springboot访问静态资源"></a>springboot访问静态资源</h1><hr><p><img src="/deng123-dev.github.io/images/pasted-115.png" alt="upload successful"></p><a id="more"></a><ul><li><p>springboot默认在static下存放静态页面，存放静态资源的目录名称必须是static</p></li><li><p>springboot默认在templates下存放动态页面，springboot中不推荐使用JSP作为视图层技术，默认使用Thymeleaf来做动态页面</p></li></ul><h2 id="创建并访问一个静态资源"><a href="#创建并访问一个静态资源" class="headerlink" title="创建并访问一个静态资源"></a>创建并访问一个静态资源</h2><hr><ol><li>创建一个静态文件</li></ol><p><img src="/deng123-dev.github.io/images/pasted-116.png" alt="upload successful"></p><ol start="2"><li>测试结果</li></ol><p><img src="/deng123-dev.github.io/images/pasted-117.png" alt="upload successful"></p><h2 id="静态资源存放其他位置"><a href="#静态资源存放其他位置" class="headerlink" title="静态资源存放其他位置"></a>静态资源存放其他位置</h2><hr><h3 id="springboot-访问静态资源的位置"><a href="#springboot-访问静态资源的位置" class="headerlink" title="springboot 访问静态资源的位置"></a>springboot 访问静态资源的位置</h3><hr><p>classpath:/META-INF/resources/</p><p>classpath:/resources/</p><p>classpath:/static/</p><p>classpath:/public/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">其中的classpath均是指main目录下的resources目录</span><br><span class="line">不过除开默认访问位置，也可以自定义访问位置</span><br></pre></td></tr></table></figure><h3 id="自定义静态文件访问位置"><a href="#自定义静态文件访问位置" class="headerlink" title="自定义静态文件访问位置"></a>自定义静态文件访问位置</h3><hr><p>步骤：</p><ul><li><p>访问application.properties</p></li><li><p>“spring.resources.static-locations=”后面加上所访问文件的位置，如果需要指定多个位置，则用“，”隔开</p></li></ul><p><img src="/deng123-dev.github.io/images/pasted-118.png" alt="upload successful"></p><p><strong><em>请注意：<br>如果自定义了静态资源的默认访问位置，原有的默认访问位置就会失效</em></strong></p><h1 id="springboot-文件上传"><a href="#springboot-文件上传" class="headerlink" title="springboot 文件上传"></a>springboot 文件上传</h1><hr><h2 id="创建一个文件上传页面"><a href="#创建一个文件上传页面" class="headerlink" title="创建一个文件上传页面"></a>创建一个文件上传页面</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-119.png" alt="upload successful"></p><p>步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">· main目录中的static目录中创建一个html文件</span><br><span class="line">· 用html标记语言攥写网页</span><br></pre></td></tr></table></figure><p>html标记语言</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form  action&#x3D;&quot;&#x2F;fileUploadController&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot;&#x2F;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;OK&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>测试结果</p><p><img src="/deng123-dev.github.io/images/pasted-120.png" alt="upload successful"></p><h2 id="文件上传（编写controller类）"><a href="#文件上传（编写controller类）" class="headerlink" title="文件上传（编写controller类）"></a>文件上传（编写controller类）</h2><hr><h3 id="上传文件的具体方法"><a href="#上传文件的具体方法" class="headerlink" title="上传文件的具体方法"></a>上传文件的具体方法</h3><hr><p><img src="/deng123-dev.github.io/images/pasted-121.png" alt="upload successful"></p><ol><li>controller代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.project1.springboot.demo.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 文件上传</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RestController</span><br><span class="line">public class FileUploadController &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 文件上传</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @PostMapping(&quot;&#x2F;fileUploadController&quot;)</span><br><span class="line">    public String FileUpload(MultipartFile file)throws Exception &#123;</span><br><span class="line">        System.out.println(file.getOriginalFilename());</span><br><span class="line">        file.transferTo(new File(&quot;E:&#x2F;&quot;+file.getOriginalFilename()));</span><br><span class="line">        return &quot;OK&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>测试结果</p><ul><li>上传文件</li></ul><p><img src="/deng123-dev.github.io/images/pasted-122.png" alt="upload successful"></p><ul><li>上传成功</li></ul><p><img src="/deng123-dev.github.io/images/pasted-123.png" alt="upload successful"></p><p><img src="/deng123-dev.github.io/images/pasted-124.png" alt="upload successful"></p><ul><li>请注意！！我这里是直接上传到E盘上面的<br><img src="/deng123-dev.github.io/images/pasted-125.png" alt="upload successful"></li></ul></li></ol><h3 id="修改上传文件大小"><a href="#修改上传文件大小" class="headerlink" title="修改上传文件大小"></a>修改上传文件大小</h3><hr><ul><li><p>配置单个上个上传文件的大小的限制</p><p>spring.servlet.multipart.max-file-size=2MB</p></li><li><p>配置在一次请求中上传文件的总容量的大小</p><p>spring.servlet.multipart.max-request-size=20MB</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot（2）</title>
      <link href="/deng123-dev.github.io/2020/05/14/springboot%EF%BC%882%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/05/14/springboot%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="创建一个HelloWorld项目"><a href="#创建一个HelloWorld项目" class="headerlink" title="创建一个HelloWorld项目"></a>创建一个HelloWorld项目</h1><hr><p>实例代码：<br><img src="/deng123-dev.github.io/images/pasted-89.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">· 添加@RestController注解</span><br><span class="line">· 创建HelloWorld方法</span><br><span class="line">· 返回字符串</span><br></pre></td></tr></table></figure><a id="more"></a><p>测试结果：</p><p><img src="/deng123-dev.github.io/images/pasted-92.png" alt="upload successful"></p><h1 id="springboot在controller中常用注解"><a href="#springboot在controller中常用注解" class="headerlink" title="springboot在controller中常用注解"></a>springboot在controller中常用注解</h1><hr><table><thead><tr><th>注解名称</th><th>注解解释</th></tr></thead><tbody><tr><td>@RestController</td><td>@RestController注解相当于@ResponseBody ＋ @Controller合在起的作用。RestController使用的效果是将方法返回的对象直接在浏览器上展示成json格式。</td></tr><tr><td>@GetMapping</td><td>相当于@ GetMapping (method=RequestMethod.GET)的缩写</td></tr><tr><td>@PostMapping</td><td>相当于@ PostMapping (method=RequestMethod.POST)的缩写</td></tr><tr><td>@PutMapping</td><td>相当于@ PutMapping (method=RequestMethod.PUT)的缩写</td></tr><tr><td>@DeleteMapping</td><td>相当于@ DeleteMapping (method=RequestMethod.DELETE)的缩写</td></tr></tbody></table><h1 id="springboot整合web层技术"><a href="#springboot整合web层技术" class="headerlink" title="springboot整合web层技术"></a>springboot整合web层技术</h1><hr><h2 id="springboot整合Servlet"><a href="#springboot整合Servlet" class="headerlink" title="springboot整合Servlet"></a>springboot整合Servlet</h2><hr><h3 id="什么是servlet"><a href="#什么是servlet" class="headerlink" title="什么是servlet"></a>什么是servlet</h3><hr><p>　简单来说就是处理请求和发送响应的过程是由一种叫做Servlet的程序来完成的，而且   Servlet是为了解决动态页面产生的</p><p><img src="/deng123-dev.github.io/images/pasted-106.png" alt="upload successful"></p><p> springboot整合Servlet技术一共由两种方法，分别是：</p><ol><li><p>通过注解扫描完成Servlet组件的注册</p></li><li><p>通过方法完成Servlet组件的注册</p></li></ol><h3 id="通过注解扫描完成Servlet组件的注册"><a href="#通过注解扫描完成Servlet组件的注册" class="headerlink" title="通过注解扫描完成Servlet组件的注册"></a>通过注解扫描完成Servlet组件的注册</h3><hr><ol><li>对servlet类的创建（如何进行整合，注意划蓝圈的地方）</li></ol><p><img src="/deng123-dev.github.io/images/pasted-91.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">· 创建servlet包</span><br><span class="line">· 创建一个servlet类继承HttpServlet类</span><br><span class="line">· 重写doGet方法（拥有HttpServletRequest和HttpServletResponse两个参数）</span><br><span class="line">· 添加WebServlet注解（给name属性和urlPatterns属性赋值）</span><br></pre></td></tr></table></figure><ol start="2"><li>对启动类的修改 （如何进行整合，注意划蓝圈的地方）</li></ol><p><img src="/deng123-dev.github.io/images/pasted-93.png" alt="upload successful"></p><p>步骤：</p><p>   <code>添加@ServletComponentScan注解（因为它会自动扫描注解）</code></p><ol start="3"><li>测试结果   </li></ol><p><img src="/deng123-dev.github.io/images/pasted-94.png" alt="upload successful"></p><h3 id="通过方法完成Servlet组件的注册"><a href="#通过方法完成Servlet组件的注册" class="headerlink" title="通过方法完成Servlet组件的注册"></a>通过方法完成Servlet组件的注册</h3><hr><ol><li>创建servlet类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-95.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">· 创建servlet包</span><br><span class="line">· 创建一个servlet类继承HttpServlet类</span><br><span class="line">· 重写doGet方法（拥有HttpServletRequest和HttpServletResponse两个参数）</span><br><span class="line">（其实步骤和注解扫描整合Servlet类一致，唯一不同就是不用添加注解）</span><br></pre></td></tr></table></figure><ol start="2"><li>创建servlet配置类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-103.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">· 创建config包</span><br><span class="line">· 添加@Configuration和@Bean注解</span><br><span class="line">· 实例化ServletRegistrationBean通过ServletRegistrationBean创造新对象bean</span><br><span class="line">· 配置bean的url</span><br><span class="line">· 返回bean</span><br></pre></td></tr></table></figure><ol start="3"><li>测试结果</li></ol><p><img src="/deng123-dev.github.io/images/pasted-98.png" alt="upload successful"></p><h2 id="Springboot整合Filter"><a href="#Springboot整合Filter" class="headerlink" title="Springboot整合Filter"></a>Springboot整合Filter</h2><hr><h3 id="什么是Filter"><a href="#什么是Filter" class="headerlink" title="什么是Filter"></a>什么是Filter</h3><hr><p>Fliter过滤器实际上就是对web资源进行拦截，做一些处理后再交给下一个过滤器或servlet处理通常都是用来拦截request进行处理的，也可以对返回的response进行拦截处理<br><img src="/deng123-dev.github.io/images/pasted-107.png" alt="upload successful"></p><p>和整合servlet一样，整合Filter也有两种方法：</p><ol><li><p>通过注解扫描完成Filter组件的注册</p></li><li><p>通过方法完成Filter组件的注册</p></li></ol><h3 id="通过注解扫描完成Filter组件的注册"><a href="#通过注解扫描完成Filter组件的注册" class="headerlink" title="通过注解扫描完成Filter组件的注册"></a>通过注解扫描完成Filter组件的注册</h3><hr><ol><li>创建Filter类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-99.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">· 添加@WebFilter注解</span><br><span class="line">· 创建Filter包</span><br><span class="line">· 创建一个implements了Filter类的类</span><br><span class="line">· 添加doFilter，init和destroy等方法</span><br></pre></td></tr></table></figure><ol start="2"><li>修改启动类</li></ol><p>步骤：<br><code>和WebServlet一样，都是添加@ServletComponentScan注解</code></p><ol start="3"><li>测试结果</li></ol><p><img src="/deng123-dev.github.io/images/pasted-102.png" alt="upload successful"></p><h3 id="通过方法完成Filter组件的注册"><a href="#通过方法完成Filter组件的注册" class="headerlink" title="通过方法完成Filter组件的注册"></a>通过方法完成Filter组件的注册</h3><hr><ol><li>创建Filter类</li></ol><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">· 创建Filter包</span><br><span class="line">· 创建一个implements了Filter类的类</span><br><span class="line">· 添加doFilter，init和destroy等方法</span><br><span class="line">(其实和通过注解扫描完成Fliter的注册步骤一样，唯一的不同是不用添加注解)</span><br></pre></td></tr></table></figure><ol start="2"><li>创建Filter配置类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-108.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">除开FilterRegistrationBean替代ServletRegistrationBean，</span><br><span class="line">其余和用方法配置servlet类的步骤一致，不做过多说明</span><br></pre></td></tr></table></figure><ol start="3"><li>测试结果</li></ol><p><img src="/deng123-dev.github.io/images/pasted-105.png" alt="upload successful"></p><h2 id="Springboot整合Listener的方式"><a href="#Springboot整合Listener的方式" class="headerlink" title="Springboot整合Listener的方式"></a>Springboot整合Listener的方式</h2><hr><h3 id="什么是Listener"><a href="#什么是Listener" class="headerlink" title="什么是Listener"></a>什么是Listener</h3><hr><p>Listener（监听器）就是一个实现特定接口的普通java程序，这个程序专门用于监听另一个java对象的方法调用或属性改变，当被监听对象发生上述事件后，监听器某个方法将立即被执行。</p><h3 id="通过注解扫描完成Listener组件注册"><a href="#通过注解扫描完成Listener组件注册" class="headerlink" title="通过注解扫描完成Listener组件注册"></a>通过注解扫描完成Listener组件注册</h3><hr><ol><li>创建Listener类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-109.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">·添加@WebListener注解</span><br><span class="line">·创建一个继承 ServletContextListener类的类</span><br></pre></td></tr></table></figure><ol start="2"><li>修改启动类</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">和WebServlet和WebFilter类一样，都是添加@ServletComponentScan注解</span><br></pre></td></tr></table></figure><h3 id="通过方法完成Listener组件注册"><a href="#通过方法完成Listener组件注册" class="headerlink" title="通过方法完成Listener组件注册"></a>通过方法完成Listener组件注册</h3><hr><ol><li>创建Listener类</li></ol><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">和第一种用注解扫描创建的listener一致，(其实和通过注解扫描完成Listener的注册步骤一样，唯一的不同是不用添加注解) 不做过多描述</span><br></pre></td></tr></table></figure><ol start="2"><li>创建Listener配置类</li></ol><p><img src="/deng123-dev.github.io/images/pasted-112.png" alt="upload successful"></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">除开ListenerRegistrationBean替代ListenerRegistrationBean和不用配置bean.url</span><br><span class="line">其余和用方法配置servlet类的步骤一致，不做过多说明</span><br></pre></td></tr></table></figure><ol start="3"><li>测试结果 </li></ol><p><img src="/deng123-dev.github.io/images/pasted-114.png" alt="upload successful"></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot（1）</title>
      <link href="/deng123-dev.github.io/2020/05/01/springboot%EF%BC%881%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/05/01/springboot%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="spring-boot入门"><a href="#spring-boot入门" class="headerlink" title="spring boot入门"></a>spring boot入门</h1><hr><h2 id="springboot的特点"><a href="#springboot的特点" class="headerlink" title="springboot的特点"></a>springboot的特点</h2><hr><ul><li><p>springboot来简化spring应用开发</p></li><li><p>整个spring技术栈的大整合</p></li><li><p>J2EE的一站式解决方案</p><p>（我觉得简单来说就是对用户封装了很多细节，不需要用户考虑其是怎样实现的）</p><a id="more"></a></li></ul><p> 优点</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 快速创建独立运行的Spring项目以及主流框架集成</span><br><span class="line">2. 使用嵌入式的Servlet容器，应用无需打成WAR包</span><br><span class="line">3. starters自动依赖与版本控制</span><br><span class="line">4. 大量的自动配置，简化开发，也可以修改默认值</span><br><span class="line">5. 无需配置XML，无代码生成，开箱即用</span><br><span class="line">6. 准生产环境的运行时应用监控</span><br><span class="line">7. 与云计算的天然集成</span><br></pre></td></tr></table></figure><p> 缺点</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 入门容易，精通难</span><br><span class="line">2. 需要了解spring的具体框架，才能知道其具体实现原理（了解其底层API）</span><br></pre></td></tr></table></figure><h2 id="如何创建一个springboot项目"><a href="#如何创建一个springboot项目" class="headerlink" title="如何创建一个springboot项目"></a>如何创建一个springboot项目</h2><hr><ol><li><p>通过官网创建项目</p></li><li><p>通过IDEA脚手架创建项目</p></li><li><p>通过IDEA中的Maven创建项目</p></li></ol><p>（想要了解如何创建的小伙伴自行百度或者google，就不细说了）</p><h1 id="微服务（架构风格）"><a href="#微服务（架构风格）" class="headerlink" title="微服务（架构风格）"></a>微服务（架构风格）</h1><hr><h2 id="单体应用"><a href="#单体应用" class="headerlink" title="单体应用"></a>单体应用</h2><hr><p> 单体应用：将所有应用程序打包在一个独立的单元，可以是JAR包，WAR包,EAR或者其他归档形式</p><p><img src="/deng123-dev.github.io/images/pasted-74.png" alt="upload successful"><br>   虽然具有<strong>易于测试，易于部署</strong>等优点，但是随着项目的加大，会存在<strong>牵一发而动全身，受开发人员技术栈</strong>不同等原因的限制</p><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><hr><p> 微服务：微服务架构是一种架构思想，将每一个功能元素都最终都是一个可独立替换和可独立升级的软件单元，微服务架构强调的重点是业务系统需要彻底的<strong>组件化和服务化</strong>，原有的<strong>单个业务系统会拆分为多个可以独立开发，设计，运行和运维的小应用</strong>，这些小应用之间通过服务完成交互和集成<br><img src="/deng123-dev.github.io/images/pasted-75.png" alt="upload successful"></p><p>微服务优点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">单个服务更易于开发、维护</span><br><span class="line">单个服务启动比较快</span><br><span class="line">局部修改容易部署</span><br><span class="line">技术栈不受限</span><br><span class="line">按需伸缩</span><br></pre></td></tr></table></figure><p>微服务缺点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运维要求高</span><br><span class="line">分布式固有的复杂性</span><br><span class="line">重复劳动</span><br></pre></td></tr></table></figure><p><strong><em>Spring Boot 是 Java 领域微服务架构最优落地技术</em></strong></p><ul><li><p>spring boot： 快速构建一个微服务应用</p></li><li><p>spring cloud：实现每个独立单元的互调，实现微服务的治理</p></li><li><p>spring cloud data flow：进行流式数据的批处理</p></li></ul><h1 id="spring-boot项目结构："><a href="#spring-boot项目结构：" class="headerlink" title="spring boot项目结构："></a>spring boot项目结构：</h1><hr><h2 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h2><hr><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;2.3.1.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br></pre></td></tr></table></figure><ul><li><p>springboot的父级依赖，只有继承它才是真正的springboot项目</p></li><li><p>spring-boot-starter-parent,用来提供相应的Maven依赖</p></li></ul><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>启动器依赖</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br><span class="line">&lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure><p><strong>spring-boot-maven-plugin插件时将springboot的应用程序打包成jar包的插件</strong></p><h2 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h2><hr><p>基于main方法来启动springboot项目；</p><p>启动类在启动时会做注解扫描位置，扫描为同包或者子包下的注解，所以启动类的位置应放在包的根下</p><ul><li><p>启动类和启动器的区别</p><ul><li><p>启动类表示项目的启动入口</p></li><li><p>启动器表示jar包的坐标</p></li></ul></li></ul><h3 id="创建启动类"><a href="#创建启动类" class="headerlink" title="创建启动类"></a>创建启动类</h3><hr><p>启动类代码：<br><img src="/deng123-dev.github.io/images/pasted-81.png" alt="upload successful"></p><p>测试结果<br><img src="/deng123-dev.github.io/images/pasted-83.png" alt="upload successful"></p><p>注意：</p><ul><li>加上@SpringBootApplication注解</li><li>运用SpringApplication中的run方法</li></ul><h2 id="启动器"><a href="#启动器" class="headerlink" title="启动器"></a>启动器</h2><hr><p>springboot将所有的场景做成一个个的启动器，只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。</p><p> spring-boot-starter提供多达44个启动器</p><ul><li><p>spring-boot-starter</p><p>这是springboot的核心启动器，包括自动配置，日志，YAML</p></li><li><p>spring-boot-actuator</p><p>帮助监控和管理应用</p></li><li><p>spring-boot-starter-web</p><p>支持全栈式的web开发</p></li></ul><h2 id="配置文件格式"><a href="#配置文件格式" class="headerlink" title="配置文件格式"></a>配置文件格式</h2><hr><p>springboot提供一个名称为application的全局配置文件，支持properties和YAML格式</p><h3 id="properties格式"><a href="#properties格式" class="headerlink" title="properties格式"></a>properties格式</h3><hr><p><img src="/deng123-dev.github.io/images/pasted-84.png" alt="upload successful"></p><ul><li>使用键值对进行书写  key=value</li></ul><p><img src="/deng123-dev.github.io/images/pasted-88.png" alt="upload successful"></p><h3 id="YAML格式"><a href="#YAML格式" class="headerlink" title="YAML格式"></a>YAML格式</h3><hr><ul><li>大小写敏感</li><li>使用缩进代表层次关系</li><li>使用的部分只能出现一次</li></ul><p>错误写法：</p><p><img src="/deng123-dev.github.io/images/pasted-87.png" alt="upload successful"></p><p>正确写法：</p><p><img src="/deng123-dev.github.io/images/pasted-86.png" alt="upload successful"></p><h2 id="配置文件存放位置及加载顺序"><a href="#配置文件存放位置及加载顺序" class="headerlink" title="配置文件存放位置及加载顺序"></a>配置文件存放位置及加载顺序</h2><hr><h3 id="配置文件存放位置"><a href="#配置文件存放位置" class="headerlink" title="配置文件存放位置"></a>配置文件存放位置</h3><hr><ul><li><p>当前项目的根目录下</p></li><li><p>当前项目根目录下的一个config子目录中</p></li><li><p>项目的resource即classpath根目录下</p></li><li><p>项目的resource即classpath根目录下的config子目录下</p></li></ul><h3 id="配置文件不同格式的加载顺序"><a href="#配置文件不同格式的加载顺序" class="headerlink" title="配置文件不同格式的加载顺序"></a>配置文件不同格式的加载顺序</h3><hr><ul><li><p>优先读取application.properties。</p></li><li><p>如果同一个配置属性，默认读取第一个，默认使用第一个读取到的，后面读取的不会覆盖第一个</p></li></ul><h3 id="配置文件不同位置的加载顺序"><a href="#配置文件不同位置的加载顺序" class="headerlink" title="配置文件不同位置的加载顺序"></a>配置文件不同位置的加载顺序</h3><hr><p> 优先级（从高到低）</p><pre><code>根目录中的config子录-&gt;当前项目根目录-&gt;resource的config子目录-&gt;resource根目录</code></pre><h2 id="配置文件中的占位符"><a href="#配置文件中的占位符" class="headerlink" title="配置文件中的占位符"></a>配置文件中的占位符</h2><hr><ol><li><p>语法：<br>${}</p></li><li><p>作用</p><ul><li><p>${}中可以获取框架提供方法的值</p></li><li><p>可以获取配置文件中的键的值赋给另一个键作为值</p></li></ul></li></ol><h2 id="bootstrap配置文件"><a href="#bootstrap配置文件" class="headerlink" title="bootstrap配置文件"></a>bootstrap配置文件</h2><hr><h3 id="bootstrap配置文件介绍"><a href="#bootstrap配置文件介绍" class="headerlink" title="bootstrap配置文件介绍"></a>bootstrap配置文件介绍</h3><hr><p> springboot中的两种上下文对象，分为bootstrap和application，bootstrap是应用程序的父上下文，也就是说bootstrap加载优先于application，bootstrap主要从额外的资源加载配置信息，<strong>它是任何spring应用程序外部属性的来源</strong>，bootstrap里面的属性会优先加载，它们默认也不能被本地相同配置覆盖</p><h3 id="bootstrap配置文件特征"><a href="#bootstrap配置文件特征" class="headerlink" title="bootstrap配置文件特征"></a>bootstrap配置文件特征</h3><hr><ul><li><p>bootstrap由父ApplicationContext加载，比application优先加载</p></li><li><p>bootstrap的属性不能被覆盖</p></li></ul><h3 id="bootstrap和-application的应用场景"><a href="#bootstrap和-application的应用场景" class="headerlink" title="bootstrap和 application的应用场景"></a>bootstrap和 application的应用场景</h3><hr><ol><li><p>application主要用于springboot项目的自动化配置</p></li><li><p>bootstrap主要应用于：</p><ul><li><p>使用spring cloud config 配置中心时，需要bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息</p></li><li><p>一些固定不能被覆盖的属性</p></li><li><p>加密/解密的场景</p></li></ul></li></ol><h2 id="springboot核心注解"><a href="#springboot核心注解" class="headerlink" title="springboot核心注解"></a>springboot核心注解</h2><hr><ol><li><p>@SpringBootApplication</p><p>springboot的启动类</p></li><li><p>@SpringBootConfiguration</p><p>此注解是@Configuration注解的派生注解，和@Configuration注解的功能一致</p></li><li><p>@Configuration</p><p>通过对bean对象的操作替代spring中的xml文件</p></li><li><p>@EnableAutoConfiguration</p><p>springboot自动配置，尝试根据你添加的jar包依赖自动配置你的spring应用</p></li><li><p>@AutoConfigurationPackage</p><p>自动注入主类下所在包下所有的加了注解的类</p></li><li><p>@Import</p><ul><li><p>直接导入普通类</p></li><li><p>导入实现了ImportSelector接口的类</p></li><li><p>导入实现了ImportBeanDefinitionRegister接口的类</p></li></ul></li><li><p>@ComponentScan</p><p>组件扫描，可自动发现和装配一些bean</p></li><li><p>@ConfigurationProperties</p><p>扫描配置属性</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统概要（3）:存储和文件管理</title>
      <link href="/deng123-dev.github.io/2020/04/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%A6%81%EF%BC%883%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/04/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%A6%81%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h1><hr><h2 id="存储层次"><a href="#存储层次" class="headerlink" title="存储层次"></a>存储层次</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-165.png" alt="upload successful"><br> <a id="more"></a></p><h2 id="地址映射（地址重定位，地址变换）"><a href="#地址映射（地址重定位，地址变换）" class="headerlink" title="地址映射（地址重定位，地址变换）"></a>地址映射（地址重定位，地址变换）</h2><hr><ul><li><p>逻辑地址（相对地址，虚地址）</p><p>用户的程序经过汇编或编译后形成目标代码，目标代码通常采用相对地址的形式，其首地址为0，其余指令中的地址都相对于首地址而编址，一个用户作业的目标程序的逻辑地址集合成为该作业的<strong>逻辑地址空间</strong></p><p>不能用逻辑地址空间在内存中读取信息</p></li><li><p>物理地址（绝对地址，实地址）</p><p>内存中的存储单元的实际内容，可直接寻址，<br>物理地址的总体构成了用户程序实际运行对的物理地址空间</p><p>物理地址空间是由存储器地址总线扫描出来的<br>空间，其大小决定于实际安装的主存容量</p></li><li><p>地址映射（地址重定位，地址变换）</p><p>为了保证CPU执行指令时可正确访问存储单元，<br>需将用户程序中的逻辑地址转换为运行时由机器<br>直接寻址的物理地址，这一过程称为<strong>地址映射</strong></p><p>由于程序的<strong>逻辑地址与分配到的<br>内存物理地址不一致</strong>, 而CPU执行指令时，是按物理地址进行的，所以要进行地址转换</p></li></ul><h2 id="重定位（地址映射方法）"><a href="#重定位（地址映射方法）" class="headerlink" title="重定位（地址映射方法）"></a>重定位（地址映射方法）</h2><hr><p>   重定位：在<strong>可执行文件装入时</strong>需要解决可执行<br>   文件中地址（指令和数据）和内存地址的对应。由操作系统中的装入程序loader来完成。</p><p>   重定位方法：</p><ul><li><p>绝对装入</p><p>在可执行文件中记录内存地址，装入时<strong>直接定<br>位</strong>在上述(即文件中记录的地址)内存地址</p></li><li><p>可重定位装入</p><p>列出各个需要重定位的地址单元和<br>相对地址值。当用户程序被装入内存时，一次性实现<br>逻辑地址到物理地址的转换</p></li><li><p>动态装入</p><p>在可执行文件中记录虚拟内存地址，<strong>装入和执行时</strong> 通过硬件地址变换机构，完成虚拟地址到实际内存地址的变换。</p></li></ul><h2 id="分区存储管理方案"><a href="#分区存储管理方案" class="headerlink" title="分区存储管理方案"></a>分区存储管理方案</h2><hr><p>   系统把内存用户区划分为若干分区，一个进程占据一个分区</p><p><img src="/deng123-dev.github.io/images/pasted-167.png" alt="upload successful">   </p><ul><li><p>固定分区</p><p> 预先把可分配的内存空间分割成若干个连<br> 续区域，每一区域称为分区，分区大小固定不变，每个分区装一个且只能装一个作业</p></li><li><p>可变分区</p><ul><li><p>内存不是预先划分好的</p></li><li><p>作业装入时，根据作业的需求和内存空间的<br>使用情况来决定是否分配</p></li><li><p>若有足够的空间，则按需要分割一部分分区<br>给该进程；否则令其等待内存空间</p></li></ul></li><li><p>碎片问题</p><p> 经过一段时间的分配回收后，内存中存<br> 在很多很小的空闲块。它们每一个都很<br> 小，不足以满足分配要求；但其总和满<br> 足分配要求。这些空闲块被称为碎片</p><p> <strong>造成存储资源的浪费</strong></p></li></ul><h2 id="页式存储管理方案"><a href="#页式存储管理方案" class="headerlink" title="页式存储管理方案"></a>页式存储管理方案</h2><hr><ul><li>基本思想</li></ul><p>  <strong>把用户程序按逻辑页划分成大小相等</strong>的部分，称为页。从0开始编制页号，页内地址是相对于0编址</p><ul><li>逻辑地址</li></ul><p><img src="/deng123-dev.github.io/images/pasted-168.png" alt="upload successful"></p><ul><li>如何管理</li></ul><p><img src="/deng123-dev.github.io/images/pasted-169.png" alt="upload successful"><br>  <strong>页表：系统为每个进程建立一个页表，页表给出逻辑页号和具体内存块号相应的关系，页表放在内存，属于进程的现场信息，逻辑上相邻的页，物理上不一定相邻</strong></p><ul><li><p>硬件支持</p><ul><li><p>页表始址寄存器</p></li><li><p>页表长度寄存器</p></li><li><p>TLB(相联存储器，俗称快表)</p><ul><li><p>引入快表的目的：<strong>为了提高地址映射速度</strong></p></li><li><p>用途：保存正在运行进程的页表的子集（部分表项）</p></li><li><p>特点：按内容并行查找    </p><p><img src="/deng123-dev.github.io/images/pasted-172.png" alt="upload successful"></p></li></ul></li></ul></li></ul><h2 id="段式存储管理方案"><a href="#段式存储管理方案" class="headerlink" title="段式存储管理方案"></a>段式存储管理方案</h2><hr><ul><li><p>基本思想 </p><p>   <strong>按程序自身的逻辑关系</strong>划分为若干个程序段，每个程序段都有一个段名，且有一个段号</p></li><li><p>逻辑地址   </p><p><img src="/deng123-dev.github.io/images/pasted-170.png" alt="upload successful"></p></li></ul><ul><li><p>如何管理</p><p><img src="/deng123-dev.github.io/images/pasted-171.png" alt="upload successful"></p></li></ul><p> <strong>段表：记录了段号，段的首（地）址和长度之间的关系每一个程序设置一个段表，放在内存属于进程的现场信息</strong></p><p> <strong>注意：页式存储被划分到的内存空间是相等的，而段式存储是不相等的，而且内存随机分割，需要多少放多少</strong></p><ul><li><p>硬件支持</p><ul><li><p>页表始址寄存器</p></li><li><p>页表长度寄存器</p></li><li><p>TLB(相联存储器，俗称快表)</p><p><img src="/deng123-dev.github.io/images/pasted-173.png" alt="upload successful"></p></li></ul></li></ul><h2 id="交换技术和覆盖技术"><a href="#交换技术和覆盖技术" class="headerlink" title="交换技术和覆盖技术"></a>交换技术和覆盖技术</h2><hr><ul><li><p>为什么引入</p><p>在多道环境下扩充内存的方法，用以解决在较小的存储空间中运行较大程序时遇到     的矛盾</p></li><li><p>交换技术和覆盖技术的共同点 </p><p>进程的程序和数据主要放在外存，当前<br>需要执行的部分放在内存，内外存之间<br>进行信息交换</p></li></ul><h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><hr><p>  基本思想：<strong>把程序划分为若干个功能上相对独立的程序段，按照其自身的逻辑结构将那些不会同时执行的程序段共享同一块内存区域</strong><br>   <img src="/deng123-dev.github.io/images/pasted-175.png" alt="upload successful"></p><h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><hr><ol><li><p>为什么引入</p><p>当内存空间紧张时，系统将内存中某些进程暂时移到外存，把外存中某些进程换进内存，占据前者所占用的区域，这种技术是<strong>进程在内存与外存之间的动态调度</strong></p></li><li><p>交换技术和覆盖技术的不同点 </p><p>与覆盖技术相比，交换技术不要求用户给出程<br>序段之间的逻辑覆盖结构；而且，交换发生在<br> 进程或作业之间，而覆盖发生在同一进程或作<br> 业内。此外，覆盖只能覆盖那些与覆盖段无关<br> 的程序段   </p></li></ol><h2 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h2><hr><p>   以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的<strong>资源转换技术</strong></p><ul><li><p>基本思想</p><p>操作系统把程序当前使用的部分保留在内存，而把其它部分保存在磁盘上，并在需要时在内存和磁盘之间动态交换</p></li><li><p>目的</p><p>提高内存利用率</p></li></ul><h2 id="程序局部性原理"><a href="#程序局部性原理" class="headerlink" title="程序局部性原理"></a>程序局部性原理</h2><hr><ul><li><p>时间局部性</p><p>  一条指令被执行了，在不久的将来它可能再被执行</p></li><li><p>空间局部性</p><p>  若某一存储单元被使用，则在一定时间内，与<br>  该存储单元相邻的单元可能被使用</p></li></ul><h2 id="缺页中断（Page-Fault）处理"><a href="#缺页中断（Page-Fault）处理" class="headerlink" title="缺页中断（Page Fault）处理"></a>缺页中断（Page Fault）处理</h2><hr><p>在地址映射过程中，在页表中发现所要访问的 页不在内存，则产生缺页中断。操作系统接到 此中断信号后，就调出缺页中断处理程序，根据页表中给出的外存地址，将该页调入内存，使作业继续运行下去</p><h2 id="页面淘汰算法"><a href="#页面淘汰算法" class="headerlink" title="页面淘汰算法"></a>页面淘汰算法</h2><hr><ul><li>最近未使用页面淘汰算法（NRU——Not Recently Used）</li></ul><p>选择在最近一段时间内未使用过的一页并淘汰之</p><ul><li>先进先出页面淘汰算法（FIFO）</li></ul><p>选择在内存中驻留时间最长的页并淘汰之</p><ul><li>最近最少使用页面淘汰算法（LRU——Least Recently Used）</li></ul><p>选择最后一次访问时间距离当前时间最长的一页并淘汰之</p><h2 id="影响缺页次数的因素"><a href="#影响缺页次数的因素" class="headerlink" title="影响缺页次数的因素"></a>影响缺页次数的因素</h2><hr><ul><li>进程的物理页面数</li><li>页面本身的大小</li><li>程序的编制方法</li><li>页面淘汰算法</li></ul><h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><ol><li>文件的逻辑结构</li></ol><ul><li><p>有结构文件指的是一个以及以上的记录构成的文件，故又把它称为<strong>记录式文件</strong></p></li><li><p>无结构文件是指字符流构成的文件，故又称为<strong>流式文件</strong></p></li></ul><ol start="2"><li>文件存取</li></ol><p>通常由三种文件存取方法：<code>顺序存取法</code>、<code>直接存取法</code>和<code>按键存取法（索引存取法）</code>。文件存取法与文件的物理结构有关。</p><ol start="3"><li>文件控制块</li></ol><p>为了能对一个文件进行正确的存取，操作系统必须为文件设置用于描述和控制文件的数据结构，称之为“文件控制块（FCB）</p><ol start="4"><li>文件目录</li></ol><p>文件目录是指：为实现“按名存取”，必须建立文件名与辅存空间中物理地址的对应关系</p><ol start="5"><li><p>文件的物理结构</p><ul><li><p>顺序结构</p></li><li><p>连接结构</p></li><li><p>索引结构</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统概要（2）：进程与线程</title>
      <link href="/deng123-dev.github.io/2020/04/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%A6%81%EF%BC%882%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/04/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%A6%81%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="进程线程模型"><a href="#进程线程模型" class="headerlink" title="进程线程模型"></a>进程线程模型</h1><hr><h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><hr><ul><li><p>进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的独立单位</p></li><li><p>为了描述程序在并发执行时对系统资源的共享，所需的一个描述程序执行时动态特征的概念</p><a id="more"></a> </li></ul><h2 id="程序与进程的区别"><a href="#程序与进程的区别" class="headerlink" title="程序与进程的区别"></a>程序与进程的区别</h2><hr><table><thead><tr><th>进程</th><th>程序</th></tr></thead><tbody><tr><td>进程更能真实地描述并发</td><td>程序不能</td></tr><tr><td>进程是动态的</td><td>程序是静态的</td></tr><tr><td>进程有生长周期</td><td>程序是相对长久的</td></tr><tr><td>进程具有创建其他进程的功能</td><td>一个程序可对应多个进程</td></tr><tr><td>进程由程序和数据两部分组成</td><td></td></tr></tbody></table><h2 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h2><hr><ul><li><p>进程切换的是什么</p><p>进程切换的是上下文，上下文是由程序正确运行所需的状态组成的，这个状态包括存放在存储器中的程序的代码和数据，他的栈，通用目的寄存器的内容，程序计数器，环境变量以及打开文件描述符的集合。</p></li><li><p>进程如何进行切换</p><p>从正在运行的进程中收回处理器，然后再使带运行进程来占用处理器，实质上就是把进程存放在处理器的寄存器中的数据找个地方存起来，从而把处理器的起存其腾出来给其他进程使用</p></li><li><p>何时进行进程切换</p><p>当有能力挂起正在cpu上运行的进程，并恢复以前挂起的进程的执行时</p></li></ul><h2 id="进程的不同状态和转换"><a href="#进程的不同状态和转换" class="headerlink" title="进程的不同状态和转换"></a>进程的不同状态和转换</h2><hr><ul><li><p>进程的3种状态</p><ul><li><p>运行态</p><p>进程占有CPU，并在CPU上运行</p></li><li><p>就绪态</p><p>一个进程已经具备运行条件，但由于无CPU暂时不能运行的状态（当调度给其CPU时，立即可以运行）</p></li><li><p>等待态</p><p> 阻塞态、封锁态、睡眠态<br>  指进程因等待某种事件的发生而暂时不能运行的状态（即使CPU空闲，该进程也不可运行）</p></li></ul></li><li><p>状态转换</p></li></ul><p><img src="/deng123-dev.github.io/images/pasted-160.png" alt="upload successful"></p><table><thead><tr><th>状态转换</th><th>进程状态转换的原因</th></tr></thead><tbody><tr><td>就绪 –&gt; 运行</td><td>调度程序选择一个新的进程运行</td></tr><tr><td>运行 –&gt; 就绪</td><td>(1)运行进程用完了时间片 (2) 一个高优先级进程处于就绪状态，中断正在运行的进程</td></tr><tr><td>运行 –&gt; 等待</td><td>(1)当一个进程必须等待时  (2) OS尚未完成服务  (3)对一资源的访问尚不能进行初始化I/O且必须等待结果 (4) 等待某一进程提供输入 (IPC)</td></tr><tr><td>等待 –&gt; 就绪</td><td>当所等待的事件发生时</td></tr></tbody></table><h2 id="PCB（进程控制块）"><a href="#PCB（进程控制块）" class="headerlink" title="PCB（进程控制块）"></a>PCB（进程控制块）</h2><hr><ol><li>概念</li></ol><p>系统为了管理进程设置的一个专门的数据结构，用它来记录进程的外部特征，描述进程的运动变化过程，PCB是感知进程存在的唯一标志</p><ol start="2"><li><p>PCB的内容</p><ul><li><p>进程描述信息</p><p>进程标识符，进程名，用户标识符</p></li><li><p>进程控制信息</p><p>当前状态，优先级，代码执行入口地址，<br>程序的外存地址，运行统计信息，进程的队列指针，进程的消息队列指针</p></li><li><p>所拥有的资源和使用情况<br> 虚拟地址空间的现状，打开文件列表</p></li><li><p>CPU现场保护信息<br>寄存器值，指向赋予该进程的段/页表的指针</p></li></ul></li></ol><ol start="3"><li><p>PCB的组织方式</p><p> PCB的大小决定了系统中最多可同时存在的进程个数，称为系统的并发度</p><ul><li><p>链接结构</p></li><li><p>索引结构<br> 对具有相同状态的进程，分别设置各自的PCB索引表，表明PCB在PCB表中的地址</p></li></ul></li></ol><h2 id="进程调度的各种算法"><a href="#进程调度的各种算法" class="headerlink" title="进程调度的各种算法"></a>进程调度的各种算法</h2><hr><ul><li><p>先来先服务调度算法</p><p>选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列</p></li></ul><ul><li><p>短作业(进程)优先调度算法</p><p>  短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行</p></li></ul><ul><li><p>时间片轮转法</p><p> 当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾</p></li></ul><ul><li><p>多级反馈队列调度法</p><p>  目前被公认的一种较好的进程调度算法</p></li></ul><ul><li><p>优先权调度算法</p><p>  该算法是把处理机分配给就绪队列中优先权最高的进程</p></li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><hr><ol><li><p>概念</p><p> 它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，</p></li><li><p>线程和进程的区别和联系</p><ul><li><p>联系</p><p>一个进程至少拥有一个线程–主线程，也可以有多个线程，一个线程必须有一个父进程。多个进程可以并发执行。一个进程可以创建和撤销另一个进程，同一个进程的多个线程可以并发执行</p></li><li><p>区别</p><ul><li><p>进程的系统开销大于线程</p></li><li><p>多进程的程序比多线程的程序更加健壮，但在切换时，耗费资源大，效率较差</p></li></ul></li></ul></li></ol><h1 id="进程的同步与通信"><a href="#进程的同步与通信" class="headerlink" title="进程的同步与通信"></a>进程的同步与通信</h1><hr><h2 id="进程在并发环境下的特点"><a href="#进程在并发环境下的特点" class="headerlink" title="进程在并发环境下的特点"></a>进程在并发环境下的特点</h2><hr><ul><li><p>程序结果的不可再现性</p><p>并发程序执行的结果与其执行的相对速度有关，是不确定的</p></li><li><p>程序的执行是间断性的</p><p>一个程序可能走到中途停下来，失去原有的时序关系</p></li><li><p>资源共享（失去封闭性）</p><h2 id="进程间的交互关系"><a href="#进程间的交互关系" class="headerlink" title="进程间的交互关系"></a>进程间的交互关系</h2><hr></li></ul><ul><li><p>互斥</p><p> 指多个进程不能同时使用同一个资源</p></li><li><p>死锁</p><p> 指多个进程互不想让，都得不到足够的资源</p></li><li><p>饥饿</p><p> 指一个进程一直得不到资源</p></li></ul><h2 id="互斥与同步"><a href="#互斥与同步" class="headerlink" title="互斥与同步"></a>互斥与同步</h2><p>  进程竞争带来的问题： </p><ul><li><p>死锁问题：一组进程如果都获得部分资源，还想要其他进程所占有的资源，最终所有的进程将陷入死锁</p></li><li><p>饥饿问题：一个进程由于其他进程总是优于它而被无限期拖延</p></li></ul><ul><li>进程的互斥：解决进程间竞争关系的手段</li></ul><p>   <strong>直接制约关系，源于进程合作</strong></p><p>   <strong><em>指若干个进程要使用同意共享资源时，任何时刻最多允许一个进程去使用，其他进程要使用必须等待占有资源的进程释放该资源</em></strong></p><ul><li><p>进程的同步：解决进程间协作关系的手段</p><p><strong>间接制约关系，源于资源共享</strong></p></li></ul><p>   <strong><em>一个进程依赖另一个进程的消息或信号，当一个进程没有得到来自于另一个进程的消息或信号时则需要等待，直到消息或信号到达才能被唤醒</em></strong></p><ul><li><p>临界资源</p><p>定义：系统中某些资源一次只允许一个进程使用</p></li><li><p>临界区</p><p>定义：进程中涉及到临界资源的程序段</p></li></ul><h2 id="实现互斥的几种解决方案"><a href="#实现互斥的几种解决方案" class="headerlink" title="实现互斥的几种解决方案"></a>实现互斥的几种解决方案</h2><hr><ul><li>硬件层面：禁用中断、特殊机器指令</li><li>软件层面：应用层面、操作系统层面</li></ul><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><hr><p>操作系统可从进程管理者的角度来处理互斥的问题，信号量就是操作系统提供的管理公有资源的有效手段</p><ol><li><p>信号量以及P,V操作</p><ul><li><p>P操作</p><p>该进程状态置为等待状态；<br>将该进程的PCB插入相应的等待队列末尾</p></li><li><p>V操作</p><p>唤醒相应等待队列s.queue中等待的一个进程<br>改变其状态为就绪态，并将其插入就绪队列</p><p><strong>P,V操作都是原语操作</strong></p></li></ul><p><strong>原语：是完成某种特定功能的一段程序，具有不可分割性或不可中断性</strong></p></li></ol><ol start="2"><li>生产者-消费者问题</li></ol><p><img src="/deng123-dev.github.io/images/pasted-162.png" alt="upload successful"></p><p><img src="/deng123-dev.github.io/images/pasted-163.png" alt="upload successful"></p><h2 id="进程的通信方式"><a href="#进程的通信方式" class="headerlink" title="进程的通信方式"></a>进程的通信方式</h2><p>实现进程间的低级通信，它只能传递简单的信号，不能传递交换大量信息，P.V操作称为低级通信原语</p><p>如果要在进程间传递大量信息则要用高级通信原语，称为进程间通信</p><ol><li>共享内存</li></ol><p>相互通信的进程间设置公共内存，一组进程向该公共内存中写入，另一组进程从公共内存中读出</p><p>  →实现两组进程间的信息交换</p><ol start="2"><li>消息传递</li></ol><p>系统提供了两个高级通信原语：send和receive</p><p>send：当要进行消息传递时执行send</p><p>receive：当接收者要接收消息时执行receive</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统概要（1）：系统机制</title>
      <link href="/deng123-dev.github.io/2020/04/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%A6%81/"/>
      <url>/deng123-dev.github.io/2020/04/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h1><hr><ol><li><p>操作系统的定义：</p><p>是一组主管并控制计算机操作，运行和管理硬件，软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序</p><a id="more"></a> </li><li><p>操作系统在计算机系统中的位置：</p><p>  <strong>内核和基石</strong></p></li></ol><ol start="3"><li><p>操作系统的特征</p><ul><li><p>并发：而并发性是指两个或者多个事件在同一时间的间隔内发生</p></li><li><p>共享：系统中的资源可供内存中多个并发执行的进程共同使用</p></li><li><p>虚拟：把物理实体变成逻辑上的对应物</p></li><li><p>异步：在多道程序运行环境，由于资源有限，程序的运行并不是一气呵成的，下多个进程并发执行是以“走走停停”的方式进行的，以不可知的速度运行下去的</p></li></ul></li></ol><ol start="4"><li><p>理解操作系统的不同角度</p><ul><li><p>作为软件来看</p></li><li><p>资源管理的观点</p></li><li><p>进程的观点</p></li><li><p>虚拟机观点</p></li><li><p>服务提供者观点</p></li></ul></li><li><p>操作系统向不同用户提供的不同接口</p><ul><li><p>系统命令：供用户用于组织和控制自己的作业运行。命令行，菜单式，GUI命令脚本</p></li><li><p>编程接口：供用户程序和系统程序调用操作系统的功能。系统调用和高基语言库函数</p></li></ul></li></ol><h1 id="系统机制"><a href="#系统机制" class="headerlink" title="系统机制"></a>系统机制</h1><hr><h2 id="cpu的工作模式和工作状态"><a href="#cpu的工作模式和工作状态" class="headerlink" title="cpu的工作模式和工作状态"></a>cpu的工作模式和工作状态</h2><hr><ol><li><p>cpu不同的工作模式</p><ul><li><p>实模式</p></li><li><p>保护模式 </p></li><li><p>系统管理模式</p></li></ul></li><li><p>管态：操作系统管理程序运行的状态，能执行指令全集，改变cpu状态的能力</p></li><li><p>目态：用户程序运行的状态，如果在目态下用户执行管态指令就会被中断</p></li></ol><h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><hr><h3 id="中断概念："><a href="#中断概念：" class="headerlink" title="中断概念："></a>中断概念：</h3><hr><p> cpu对于系统发生的某个事件做出的一些反应</p><p>  cpu暂停正在执行的程序，保留现场后自动转取执行相应事件的处理程序，处理完<br>成后返回断点，继续执行被打断的程序 </p><ul><li><p>事件：异步/同步事件</p></li><li><p>特点：随即发生的，可恢复的，自动处理的</p></li></ul><p>中断和异常的类型：</p><table><thead><tr><th>中断</th><th>异常</th></tr></thead><tbody><tr><td>I/O中断</td><td>系统调用</td></tr><tr><td>时钟中断</td><td>缺页异常</td></tr><tr><td>硬件故障</td><td>断点指令</td></tr><tr><td>程序性中断</td><td>其他程序性异常</td></tr></tbody></table><p>中断和异常的区别：      </p><p> 中断：和正执行指令无关，可以屏蔽</p><p> 异常：与正执行指令有关，不可屏蔽</p><h3 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h3><hr><ol><li><p>中断系统的两大组成部分</p><ul><li><p>硬件中断装置</p></li><li><p>软件中断处理程序</p></li></ul></li><li><p>相关概念</p><ul><li><p>中断源：引起中断发生的事件</p></li><li><p>中断寄存器： 记录中断</p></li><li><p>中断字：中断寄存器中的内容</p></li><li><p>系统堆栈：在内存开辟的一块用于临时保存现场</p></li></ul></li></ol><h3 id="中断优先级和中断屏蔽"><a href="#中断优先级和中断屏蔽" class="headerlink" title="中断优先级和中断屏蔽"></a>中断优先级和中断屏蔽</h3><hr><p> 处理机优先级：</p><p> 指出处理机正运行程序的中断响应级别。只允许处理机去响应比该优先级高的中断,而屏蔽低于或等于该优先级的中断</p><p> 中断屏蔽：</p><p> 指禁止CPU响应中断或禁止中断出现</p><h3 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h3><hr><p> 中断响应：发现中断，接收中断的过程，由中断装置完成</p><p> 中断响应的处理过程：<br><img src="/deng123-dev.github.io/images/pasted-156.png" alt="upload successful"></p><p>  （1） 在每条指令执行周期的最后时刻扫描中断寄存器，询问是否有中断信号</p><p>  （2） 若无中断信号，继续执行下一条指令</p><p>  （3） 若有中断，中断硬件将该中断触发器内容按规定编码送入PSW的相应位，称为中断码，通过交换中断向量引出中断处理程序</p><h3 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h3><hr><p><img src="/deng123-dev.github.io/images/pasted-176.png" alt="upload successful"></p><p> （1）设备给处理器发一个中断信号</p><p> （2）处理器处理完当前指令后响应中断</p><p> （3）处理器处理完当前指令后检测到中断，判断出中断来源并向发送中断的设备发送了确认中断信号</p><p> （4）处理器开始为软件处理中断做准备</p><p> （5）处理器根据中断源查询中断向量表，获得与该中断相联系的处理程序入口地址。</p><p> （6）中断处理程序开始工作</p><p> （7）中断处理结束时，处理器检测到中断返回指令</p><p> （8）PSW和PC恢复成中断前的值</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><hr><ol><li><p>系统调用概述 </p><p>系统调用：用户在程序中调用操作系统提供的一些子功能</p><ul><li><p>一种特殊的过程调用，由特殊的机器指令实现</p></li><li><p>系统调用时操作系统提供给编程人员的唯一接口</p></li><li><p>系统从目态转入管态</p></li><li><p>系统调用是一个低级过程，只能由汇编语言访问</p></li><li><p>利用系统调用，动态请求和释放系统资源</p></li></ul></li></ol><ol start="2"><li>系统调用的处理过程</li></ol><p><img src="/deng123-dev.github.io/images/pasted-159.png" alt="upload successful"><br><img src="/deng123-dev.github.io/images/pasted-158.png" alt="upload successful"></p><ol start="3"><li><p>系统调用参数传递</p><ul><li><p>由陷入指令自带参数</p></li><li><p>通过通用寄存器传递参数</p></li><li><p>在内存中开辟专用堆栈区传递参数</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web基础（2）</title>
      <link href="/deng123-dev.github.io/2020/04/04/web%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/04/04/web%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-超文本传输协议"><a href="#HTTP-超文本传输协议" class="headerlink" title="HTTP(超文本传输协议)"></a>HTTP(超文本传输协议)</h1><hr><p> HTTP是基于<strong>C/S架构</strong>的<strong>应用层</strong>协议，请求通常是由 浏览器这样的客户端发起的，有web 服务器进行处理<br> 客户端和服务器通过交换各自的信息进行交互。<br> <a id="more"></a></p><ul><li>默认端口为<strong>80</strong></li><li>由像浏览器这样的客户端发出的消息叫做request </li><li>被服务器响应的消息叫做responses</li><li>无状态性：每次请求都是相互独立的</li></ul><h2 id="HTTP-request"><a href="#HTTP-request" class="headerlink" title="HTTP:request"></a>HTTP:request</h2><hr><p>对于browser请求页面的流程：</p><ul><li>与服务器建立TCP连接；</li><li>发送HTTP请求；</li><li>收取HTTP响应，然后把网页在浏览器中显示出来。</li></ul><h3 id="请求格式"><a href="#请求格式" class="headerlink" title="请求格式"></a>请求格式</h3><hr><p><img src="/deng123-dev.github.io/images/pasted-68.png" alt="upload successful"></p><h4 id="请求行和请求头部"><a href="#请求行和请求头部" class="headerlink" title="请求行和请求头部"></a>请求行和请求头部</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: www.sina.com.cn</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 xxx</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,en-US;q&#x3D;0.8</span><br></pre></td></tr></table></figure><ul><li>请求行解释</li></ul><table><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>GET</td><td>表示使用获取路径为/的资源</td></tr><tr><td>HTTP/1.1</td><td>表示使用的是HTTP  1.1的协议</td></tr></tbody></table><ul><li>请求头解释</li></ul><table><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>HOST</td><td>表示请求的主机名,表示浏览器正在请求的域名</td></tr><tr><td>User-Agent</td><td>表示客户端本身，例如浏览器的表示</td></tr><tr><td>Accept</td><td>表示浏览器能接收的数据类型，如text/<em>，images/</em></td></tr><tr><td>Accept-Language</td><td>表示浏览器偏好的语言</td></tr><tr><td>Accept-Encoding</td><td>表示浏览器可以支持的压缩类型，例如gzip, deflate, br</td></tr></tbody></table><h4 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h4><hr><p>因为<strong>get通过URL传送数据</strong>，而<strong>post通过请求数据体传送数据</strong>，所以一般情况下get方法中不体现请求数据（<strong>当然也可以将请求数据放在get中的请求数据体中使其体现</strong>）</p><h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><hr><p>请求参数的两种方式：</p><ol><li>URL（GET请求）：</li></ol><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浏览器？参数名&#x3D;参数值&amp;参数二&#x3D;参数值</span><br></pre></td></tr></table></figure><ol start="2"><li>request body（POST请求）</li></ol><p>通过request body传递参数</p><ol start="3"><li><p>参数格式：</p><ul><li><p>多个参数用&amp;隔开</p></li><li><p>参数以键值对的方式出现</p></li></ul></li></ol><h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><hr><p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载</p><p> 好处：</p><ul><li>缓解服务器端压力</li><li>提升性能(获取资源的耗时更短了)</li></ul><p>（关于缓存的内容确实少的可怜，其中一个重要原因在于我对缓存的了解太少，望各位大佬指教）</p><h3 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h3><hr><table><thead><tr><th>动词名称</th><th>解释</th></tr></thead><tbody><tr><td>GET</td><td>从服务器取出资源（单个或多个）。</td></tr><tr><td>POST</td><td>在服务器新建资源。</td></tr><tr><td>PUT</td><td>在服务器更新资源（客户端提供改变后的完整资源）。</td></tr><tr><td>PATCH</td><td>在服务器更新(属性)资源（客户端提供改变的属性，比如说某个字段+1）。</td></tr><tr><td>DELETE</td><td>从服务器删除资源。</td></tr></tbody></table><p>还有两个不常用的HTTP动词：</p><table><thead><tr><th>动词名称</th><th>解释</th></tr></thead><tbody><tr><td>HEAD</td><td>获取资源的元数据。</td></tr><tr><td>OPTIONS</td><td>获取信息，关于资源的哪些属性是客户端可以改变的。</td></tr></tbody></table><h3 id="Get和Post的区别"><a href="#Get和Post的区别" class="headerlink" title="Get和Post的区别"></a>Get和Post的区别</h3><hr><ul><li>Get：从服务器上面获取数据</li><li>post: 向服务器传输数据</li></ul><table><thead><tr><th>分类</th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>后退按钮/刷新</td><td>无害</td><td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td></tr><tr><td>书签</td><td>可收藏为书签</td><td>不可收藏为书签</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能缓存</td></tr><tr><td>传参数方式</td><td>用URL传参数</td><td>用body传参数</td></tr><tr><td>历史</td><td>参数保留在浏览器历史中。</td><td>参数不会保存在浏览器历史中。</td></tr><tr><td>对数据长度的限制</td><td>是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td><td>无限制。</td></tr><tr><td>对数据类型的限制</td><td>只允许 ASCII 字符。</td><td>没有限制。也允许二进制数据。</td></tr><tr><td>安全性</td><td>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td><td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr><tr><td>可见性</td><td>数据在 URL 中对所有人都是可见的。</td><td>数据不会显示在 URL 中。</td></tr></tbody></table><h3 id="发送post请求"><a href="#发送post请求" class="headerlink" title="发送post请求"></a>发送post请求</h3><hr><p>三种发送post请求的方法：</p><ul><li><p>浏览器默认使用get请求</p></li><li><p>线上的默认工具发送 post请求</p></li><li><p>HTML from中可以指定get或post请求</p></li></ul><p><em>form中的post请求</em>：</p><pre><code>&lt;form action=&quot;https://www.baidu.com&quot; method=&quot;post&quot;&gt;          &lt;p&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;/p&gt;          &lt;p&gt;密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;/&gt;&lt;/p&gt;          &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;      &lt;/form&gt;    </code></pre><p> <em>展示的效果</em>：</p> <form action="https://www.baidu.com" method="post">            <p>用户名：<input type="text" name="name"/></p>            <p>密码：<input type="password" name="pwd"/></p>            <input type="submit" value="登录">        </form><h2 id="HTTP-response"><a href="#HTTP-response" class="headerlink" title="HTTP:response"></a>HTTP:response</h2><hr><h3 id="reponse格式"><a href="#reponse格式" class="headerlink" title="reponse格式"></a>reponse格式</h3><hr><p>HTTP响应也由三个部分组成，分别是：<strong>状态行、消息报头、响应正文</strong>。</p><ul><li><p>格式：</p><p> ＜status-line＞</p><p> ＜headers＞</p><p> ＜blank line＞</p><p> [＜response-body＞]</p></li><li><p>response和request的区别：</p></li></ul><p><strong><em>response用状态字段代替了request请求信息</em></strong></p><h3 id="reponse状态代码"><a href="#reponse状态代码" class="headerlink" title="reponse状态代码"></a>reponse状态代码</h3><hr><ul><li>首数字的状态响应码以及对应情况 </li></ul><table><thead><tr><th>相应类别</th><th>代表情况</th></tr></thead><tbody><tr><td>1xx</td><td>指示信息–表示请求已接收，继续处理</td></tr><tr><td>2xx</td><td>成功–表示请求已被成功接收、理解、接受</td></tr><tr><td>3xx</td><td>重定向–要完成请求必须进行更进一步的操作</td></tr><tr><td>4xx</td><td>客户端错误–请求有语法错误或请求无法实现</td></tr><tr><td>5xx</td><td>服务器端错误–服务器未能实现合法的请求</td></tr></tbody></table><ul><li>常见状态码以及对应情况</li></ul><table><thead><tr><th>常见的状态代码</th><th>表示的情况</th></tr></thead><tbody><tr><td>200 OK：</td><td>客户端请求成功。</td></tr><tr><td>301 Moved Permanently</td><td>被请求的资源已永久移动到新位置</td></tr><tr><td>302 Found</td><td>要求客户端执行临时重定向</td></tr><tr><td>400 Bad Request：</td><td>客户端请求有语法错误，不能被服务器所理解。</td></tr><tr><td>403 Forbidden：</td><td>服务器收到请求，但是拒绝提供服务。</td></tr><tr><td>404 Not Found：</td><td>请求资源不存在，举个例子：输入了错误的URL。</td></tr><tr><td>500 Internal Server Error：</td><td>服务器发生不可预期的错误。</td></tr><tr><td>503 Server Unavailable：</td><td>服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。</td></tr></tbody></table><h1 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h1><hr><h2 id="web服务器概览"><a href="#web服务器概览" class="headerlink" title="web服务器概览"></a>web服务器概览</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-69.png" alt="upload successful"></p><ul><li><p>web服务器：</p><ul><li>web服务器软件是一个服务端软件 </li><li>可以把静态网页部署到web服务器</li><li>web服务器主要运行静态页面 </li></ul></li><li><p>应用服务器：</p><ul><li>应用服务器可以运行动态页面</li></ul></li><li><p>web服务器和应用服务器通常一起使用</p></li><li><p>Web服务器主要 是处理向浏览器发送HTML以供浏览，而应用程序服务器提供访问商业逻辑的途径以供客户端应用程序使用。</p></li></ul><h2 id="常见的web服务器"><a href="#常见的web服务器" class="headerlink" title="常见的web服务器"></a>常见的web服务器</h2><hr><ol><li><p>Apache服务器<br><img src="/deng123-dev.github.io/images/pasted-70.png" alt="upload successful"><br>Apache仍然是世界上用得最多的Web服务器，优势主要在于源代码开放，可以运行在几乎所有的Unix, Windows. Linux系统平台上</p></li><li><p>Nginx服务器</p></li></ol><p><img src="/deng123-dev.github.io/images/pasted-71.png" alt="upload successful"><br>只能运行在Linux/Unix，其特点是占有内存少，并发能力强</p><ol start="3"><li>ISS服务器</li></ol><p><img src="/deng123-dev.github.io/images/pasted-72.png" alt="upload successful"><br>Microsoft的W eb服务器产品为Internet Information Server C IIS ) .  IIS是允许在公共Intranet或Internet上发布信息的Web服务器。IIS只能运行在Microsoft Windows平台</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web基础（1）</title>
      <link href="/deng123-dev.github.io/2020/03/21/web%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/"/>
      <url>/deng123-dev.github.io/2020/03/21/web%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="网络概览"><a href="#网络概览" class="headerlink" title="网络概览"></a>网络概览</h1><hr><p>终端：用户与计算机进行交互的设备</p><p>网络：是由若干节点和连接这些节点的链路构成，表示诸多对象及其相互联系。</p><h2 id="按拓扑结构分类："><a href="#按拓扑结构分类：" class="headerlink" title="按拓扑结构分类："></a>按拓扑结构分类：</h2><hr><ol><li>总线型</li></ol><p><img src="/deng123-dev.github.io/images/pasted-53.png" alt="upload successful"></p><a id="more"></a><ol start="2"><li>环型</li></ol><p><img src="/deng123-dev.github.io/images/pasted-54.png" alt="upload successful"><br>3. 星型</p><p><img src="/deng123-dev.github.io/images/pasted-55.png" alt="upload successful"><br>4. 树型</p><p><img src="/deng123-dev.github.io/images/pasted-56.png" alt="upload successful"><br>5. 网型</p><p><img src="/deng123-dev.github.io/images/pasted-57.png" alt="upload successful"></p><h2 id="按覆盖范围分"><a href="#按覆盖范围分" class="headerlink" title="按覆盖范围分"></a>按覆盖范围分</h2><hr><ul><li>局域网 LAN</li><li>城域网 MAN</li><li>广域网 WAN<h2 id="网络主要功能"><a href="#网络主要功能" class="headerlink" title="网络主要功能"></a>网络主要功能</h2></li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 资源共享</span><br><span class="line">2. 快速传输信息</span><br><span class="line">3. 提高系统可靠性</span><br><span class="line">4. 易于进行分布式处理</span><br><span class="line">5. 综合信息服务</span><br></pre></td></tr></table></figure><h1 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h1><hr><h2 id="OSI（开放式系统互联模型）层次"><a href="#OSI（开放式系统互联模型）层次" class="headerlink" title="OSI（开放式系统互联模型）层次"></a>OSI（开放式系统互联模型）层次</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-58.png" alt="upload successful"></p><p><img src="/deng123-dev.github.io/images/pasted-59.png" alt="upload successful"></p><h2 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h2><hr><p> TCP/IP协议族是一个四层协议系统：<br><img src="/deng123-dev.github.io/images/pasted-60.png" alt="upload successful"></p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><hr><ol><li><p>实现网卡驱动，以处理数据在以太网等物理媒介的传输</p></li><li><p>为上层协议提供一个统一的接口</p></li><li><p>协议应用：</p><ul><li>以太网协议：<br>规定一组电信号就是一个数据包，一个数据包为<strong>一帧</strong>。数据包是从一个网卡发到另一个网卡，<strong>网卡地址</strong>，也就是帧首部所包含的<strong>MAC地址</strong>，具有全球唯一性。<strong>对电信号进行分组并形成具有特定意义的数据帧，然后以广播的形式通过物理介质发送给接收方。</strong></li></ul></li></ol><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><hr><ol><li><p>网络层的任务之一使选择这些中间节点，以确定两台主机间的通讯路径</p></li><li><p>其次网络层对上层协议隐藏了网络拓扑联结的细节，在使得传输层看来通讯双方是直接连接的</p></li><li><p>协议应用：</p><ul><li>IP协议：判断两台主机是否处于同一个网络，IP地址目前有两个版本，分别是IPV4，IPV6,IPV4是一个32位地址，常采用4个十进制数字表示。IP协议将这个32位的地址分为两部分，前面部分表示网络地址，后面部分表示该主机在局域网中的地址。由于各类地址的分发不尽相同，以c类地址为例，其中前24位就是网络地址，后8位就是主机地址。因此，<strong>如果两个IP地址在同一子网内，则网络地址一定相同。</strong>为了判断IP地址中的网络地址，IP协议还引入了子网掩码，IP地址和子网掩码通过<strong>按位与</strong>运算后就可以得到网络地址。</li><li>ARP(地址转换协议):根据IP地址获取物理地址的一个TCP/IP协议。</li><li>RARP(逆地址转换协议):允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址。</li><li>路由协议：ARP的MAC寻址还是局限在同一个子网中，因此网络层引入了路由协议，首先通过IP来判断主机是否在同一子网，如果在同一子网，通过ARP协议查询对应的MAC地址，然后以广播形式向子网内的主机发送数据包；如果不在同一子网，以太网会将数据包转发给本子网的网关进行路由。网关是互联网网上子网与子网之间的桥梁，网关进行多次转发，最终将数据包转发到目标IP所在的子网中，然后通过ARP获取目标及MAC,最终发送。</li></ul></li><li><p>IPV4数据包结构：<br><img src="/deng123-dev.github.io/images/pasted-61.png" alt="upload successful"></p></li><li><p>总结:<br>总而言之，网络层的主要工作是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.定义网络地址</span><br><span class="line">2.区分网络</span><br><span class="line">3.子网内MAC寻址</span><br><span class="line">4.对于不同子网数据包进行路由</span><br></pre></td></tr></table></figure><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3></li></ol><hr><p>协议为网络端点主机上提供可靠、可靠、有效的报文传送服务。其功能紧密以来于网络层的虚拟电路或数据报服务，传输层定义了主机应用程序之间的连通性。传输层的服务要经历<strong><em>连接建立，数据传输,传输连接释放</em></strong>3个阶段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口</span><br></pre></td></tr></table></figure><h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><hr><p>面向连接的，可靠传输的，有流量控制的，拥塞控制，面向字节流传输等很多优点，在端和端之间通信</p><h5 id="三次握手（面向连接）"><a href="#三次握手（面向连接）" class="headerlink" title="三次握手（面向连接）"></a>三次握手（面向连接）</h5><hr><p>在通信之前，会通过三次握手机制来判断连接是否可用，UDP则不需要，直接传</p><p><img src="/deng123-dev.github.io/images/pasted-62.png" alt="upload successful"></p><ul><li>第一次握手：<br>客户端想与服务器连接了，所以状态变为主动打开，同时发送一个连接请求给服务器端SYN=1，并且会携带x个字节过去。发送完请求连接报文后，客户端的状态变为了SYN_SENT，可以说这个状态是等待发送确认(为了发送第三次握手时的确认包)</li></ul><p>(<em>其实就是客户端和服务器谈恋爱，主动给服务器发一个消息，然后等待服务器的回应</em>)</p><ul><li>第二次握手：<br>服务器端收到连接请求报文后，从LSTTEN变为被动打开状态，然后给客户端返回两层报文。一是确认报文，而可以到达告诉客户端，我也打开连接了。发完后，变为SYN_RCVD状态（等待确认状态，等待接收客户端发过来的确认包）</li></ul><p>(<em>服务器这边收到了客户机想谈恋爱的消息，从被动状态变成主动，开始也给客户机发一个暗示客户机服务器想谈恋爱的消息</em>)</p><ul><li>第三次握手：<br>客户得到服务器端的确认知道服务器端也已经准备好了连接后，还会发一个确认报文到服务器端，告诉它，我收到你发送的报文了，接下来我们两个进行连接。客户端发送完确认报文后，进入ESTABLISHED，服务器接到了，也变成了 ESTABLISHED，连接完成。</li></ul><p>(<em>客户机收到了服务器发的消息，明白了服务器的意思，再给服务器发送一个表白的消息，正式的和服务器在一起，客户机和服务器的连接就建立了</em>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以划一波重点：</span><br><span class="line">三次握手的作用：确认双方对对方的收发能力是否正常</span><br></pre></td></tr></table></figure><h5 id="四次握手，关闭连接"><a href="#四次握手，关闭连接" class="headerlink" title="四次握手，关闭连接"></a>四次握手，关闭连接</h5><hr><p><img src="/deng123-dev.github.io/images/pasted-63.png" alt="upload successful"><br>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭<br>(<em>相当一对情侣分手</em>)</p><ul><li><p>客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。<br>(<em>客户端要和服务端分手，就发了一个分手消息给服务端</em>)</p></li><li><p>服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。<br>(<em>服务器收到了这个消息，有点伤心而且不敢相信，发消息给客户端，这时客户端确认服务器收到了要分手的消息</em>)</p></li><li><p>服务器B关闭与客户端A的连接，发送一个FIN给客户端A。</p></li></ul><p>(<em>服务器确认了客户端执意与自己分手，直接与客户端分手并且中断了他们的连接</em>)</p><ul><li>客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。<br>(<em>客户端这时收到服务器发的分手消息，为她送上最后的祝福，同时也让服务器知道客户机收到了她的消息</em>)</li></ul><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><hr><p>UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法<br>其有以下特点：</p><ul><li><p>面向无连接</p></li><li><p>有单播，多播和广播的功能</p></li><li><p>UDP 是面向报文的</p></li><li><p>不可靠性</p></li></ul><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><hr><h4 id="DNS-域名解析系统"><a href="#DNS-域名解析系统" class="headerlink" title="DNS(域名解析系统)"></a>DNS(域名解析系统)</h4><hr><p>在internet上域名与IP地址一一对应，域名便于人们记忆，但机器之间只认IP地址，他们之间的转换称为<strong><em>域名解析</em></strong>,DNS就是专门用来解析域名解析的服务器</p><h4 id="DHCP-动态主机配置协议"><a href="#DHCP-动态主机配置协议" class="headerlink" title="DHCP(动态主机配置协议)"></a>DHCP(动态主机配置协议)</h4><hr><p>DHCP（动态主机配置协议）是一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。能够动态分配IP地址</p><h4 id="FTP-文件传输协议"><a href="#FTP-文件传输协议" class="headerlink" title="FTP(文件传输协议)"></a>FTP(文件传输协议)</h4><hr><p>用于Internet上的文件控制的双向传输，同时，它也是一个应用程序，TCP协议</p><p>FTP允许用户以文件操作的方式（如文件的增、删、改、查、传送等）与另一主机相互通信。然而， 用户并不真正登录到自己想要存取的计算机上面而成为完全用户， 可用FTP程序访问远程资源， 实现用户往返传输文件、目录管理以及访问电子邮件等等， 即使双方计算机可能配有不同的操作系统和文件存储方式</p><p><strong>ftp默认端口21</strong></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：线性表，栈和队列</title>
      <link href="/deng123-dev.github.io/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%8C%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/deng123-dev.github.io/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%8C%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><hr><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><hr><ul><li>数据结构是相互之间存在一种或多种特定关系的数据元素的集合 <a id="more"></a></li></ul><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><hr><p><strong>从逻辑关系上描述数据，与数据的存储无关</strong></p><ul><li>集合结构</li></ul><p>元素属于同一集合，非线性结构</p><ul><li>线性结构</li></ul><p>除元素属于同一集合，元素之间存在一对一的关系</p><ul><li>树结构</li></ul><p>元素之间存在一对多的关系，非线性结构</p><ul><li>图结构或网状结构</li></ul><p>元素之间存在多对多的关系，非线性结构</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><hr><ul><li>顺序存储结构</li></ul><p>存储器的相对位置来表示数据元素的逻辑关系</p><ul><li>链式存储结构</li></ul><p>数据元素的存放地址是否连续没有要求</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><hr><h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><hr><ul><li>有穷性 </li><li>确定性</li><li>可行性</li><li>输入</li><li>输出<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3></li></ul><hr><ul><li>时间复杂度</li></ul><p>算法计算量的大小</p><ul><li>算法空间复杂度</li></ul><p>算法所需存储空间大小</p><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><hr><ul><li>由n个数据特性相同构成的有限序列称为线性表 </li><li>特点：除第一个和最后一个数据元素，其他元素都有一个直接前驱和一个直接后继</li></ul><h2 id="线性表的顺序存储表示"><a href="#线性表的顺序存储表示" class="headerlink" title="线性表的顺序存储表示"></a>线性表的顺序存储表示</h2><hr><ol><li><p>由一组地址连续的存储单元存储线性表的数据元素</p></li><li><p>数组长度和线性表的长度区别：数组长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的，线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。</p></li><li><p>ASL（平均查找长度）：ASL=∑PiCi (i=1,2,3,…,n),</p></li><li><p>顺序表操作</p><ul><li><p>查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> int findElem (Sqlist L,int e)&#123;    int i;    for (i&#x3D;0,i&lt;L.length,++i)   &#x2F;&#x2F;遍历L长度中的每个位置        </span><br><span class="line"> if(e &#x3D;&#x3D; L.data[i])          &#x2F;&#x2F;获取每个位置对应的值和e值进行判断，这里的等于可以是大于、小于</span><br><span class="line"> return i;                    &#x2F;&#x2F;如果找到与e值相等的值，则返回该值对应的位置</span><br><span class="line">return -1;                        &#x2F;&#x2F;如果找不到，则返回-1&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> int insertElem(Sqlist &amp;L,int p,int e) &#x2F;&#x2F;L是顺序表的长度，要发生变化，所以用引用型&#123;    int i    if (p&lt;0 || p&gt;L.length || L.length&#x3D;&#x3D;maxsize) &#x2F;&#x2F;如果插入e的位置p小于0，或者是大于L的长度，或者是L的长度已经等于了顺序表最大存储空间  </span><br><span class="line"> return 0;</span><br><span class="line"> for (i&#x3D;L.length-1; i&gt;&#x3D;p;--i)    &#x2F;&#x2F;从L中的最后一个元素开始遍历L中位置大于p的每个位置  </span><br><span class="line"> L.data[i+1]&#x3D;L.data[i];    &#x2F;&#x2F;依次将第i个位置的值赋值给i+1    </span><br><span class="line"> L.data[p]&#x3D;e;                  &#x2F;&#x2F;将p位置插入e</span><br><span class="line"></span><br><span class="line">++(L.length);                 &#x2F;&#x2F;L的长度加1  </span><br><span class="line">return 1;                     &#x2F;&#x2F;插入成功，返回1&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int deleteElem (Sqlist &amp;L,int p,int &amp;e)    &#x2F;&#x2F;需要改变的变量用引用型&#123;    int i;    if(p&lt;0 || p&gt;L.length-1)    &#x2F;&#x2F;对位置p进行判断，如果位置不对，则返回0，表示删除失败      </span><br><span class="line">return 0;    </span><br><span class="line">e&#x3D;L.data[p];               &#x2F;&#x2F;将要删除的值赋值给e  </span><br><span class="line">for(i&#x3D;p;i&lt;L.length-1;++i)  &#x2F;&#x2F;从位置p开始，将其后边的元素逐个向前覆盖       </span><br><span class="line">L.data[i]&#x3D;L.data[i+1];</span><br><span class="line">--(L.length)               &#x2F;&#x2F;将表的长度减1</span><br><span class="line">return 1;                  &#x2F;&#x2F;删除成功，返回1&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="线性表的链式存储表示"><a href="#线性表的链式存储表示" class="headerlink" title="线性表的链式存储表示"></a>线性表的链式存储表示</h2><hr><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><hr><ol><li><p>链式线性表定义：由一组任意地址的存储单元存储线性表的数据元素</p></li><li><p>链表的存储密度=单链表数据项所占空间/节点所占空间</p></li><li><p>链表增加头结点作用：</p><ul><li>便于首元节点的处理</li><li>便于空表和非空表的统一处理</li></ul><p><img src="/deng123-dev.github.io/images/pasted-40.png" alt="upload successful"></p></li><li><p>单链表操作</p><ul><li>插入<br>将s插在p后<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;next&#x3D;p-&gt;next;p-&gt;next&#x3D;s;</span><br></pre></td></tr></table></figure></li><li>删除<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next&#x3D;p-&gt;next-&gt;next;</span><br></pre></td></tr></table></figure><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3></li></ul><hr><p>双向链表的结点有两个指针域，一个指向直接前驱，一个指向直接后继</p><ul><li>查找</li></ul><p>在双链表中查找值为x的结点，如果找到，则返回该结点的指针，否则返回NULL值。</p><figure class="highlight plain"><figcaption><span>findNode(DLNode *C,int x)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;    DLNode *p &#x3D; C -&gt; next;   </span><br><span class="line">while(p !&#x3D; NULL)</span><br><span class="line">&#123;  if(p -&gt; data &#x3D;&#x3D; x)</span><br><span class="line">          break;     </span><br><span class="line">p &#x3D; p -&gt; next;    &#125;  </span><br><span class="line">return p;&#125;</span><br></pre></td></tr></table></figure><ul><li>插入</li></ul><p>在双链表中p所指的结点之后插入一个结点s,核心思想就是将p的指向赋值给s,即让s指向p所指,s的前结点就是p,p的后结点就是s,具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s -&gt; next &#x3D; p -&gt; next;</span><br><span class="line">s -&gt; prior &#x3D; p;</span><br><span class="line">p -&gt; next &#x3D; s;</span><br><span class="line">s -&gt; next -&gt; prior &#x3D; s;</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><p>要删除双链表中p结点的后继结点，核心思想就是先将p的后继结点给到q,然后让p指向q的后继结点，q的后继结点的前结点就是p，然后把q释放掉，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  q &#x3D; p -&gt; next;</span><br><span class="line">p -&gt; &#x3D; q -&gt; next;</span><br><span class="line">q -&gt; next -&gt; prior &#x3D; p;</span><br><span class="line">free(q);</span><br></pre></td></tr></table></figure><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1></li></ol><hr><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><hr><ul><li><p><strong>栈是限定仅在表尾进行插入和删除操作的线性表</strong>，我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈，栈又称后进后出的线性表，简称LIFO结构。</p></li><li><p>栈首先是一个线性表，也就是说，栈元素具有线性关系，即前驱后继关系，只不过它是一种特殊的线性表而已。</p></li><li><p>栈的特殊之处在于<strong>限制了这个线性表的插入和删除位置，它始终只在栈顶进行。</strong>这也就使得：栈底是固定的，最先进栈的只能在栈底。</p></li><li><p>栈的插入操作，叫做进栈；栈的删除操作叫做出栈。</p><h3 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h3></li></ul><hr><p><img src="/deng123-dev.github.io/images/pasted-41.png" alt="upload successful"></p><ol><li><p>顺序栈的基本操作</p><ul><li>初始化栈<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int stack[maxsize];int top &#x3D; -1;</span><br></pre></td></tr></table></figure></li><li>元素x进栈<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack[++top] &#x3D; x</span><br></pre></td></tr></table></figure></li><li>元素x出栈<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; stack[top--]</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h3><hr><p><strong>把栈顶放在单链表的头部</strong>，用链表来存储栈的的数据结构称为链栈。<br><img src="/deng123-dev.github.io/images/pasted-42.png" alt="upload successful"></p><ul><li>链栈的插入操作：<br><img src="/deng123-dev.github.io/images/pasted-43.png" alt="upload successful"></li><li>链栈的删除操作</li></ul><p><img src="/deng123-dev.github.io/images/pasted-44.png" alt="upload successful"></p><ol><li>链栈的基本操作：</li></ol><ul><li>元素（指针p所指）进栈操作<br>/<em>类似于头插法建立链表</em>/</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void PushStack(LinkStack top, DataType data)</span><br><span class="line">&#123;</span><br><span class="line">    LStackNode*  p;</span><br><span class="line">    p &#x3D; (LStackNode*)(malloc(sizeof(LStackNode))); </span><br><span class="line">    if (p &#x3D;&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;内存分配失败！\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;data &#x3D; data;</span><br><span class="line">        p-&gt;next &#x3D; top-&gt;next;</span><br><span class="line">        top-&gt;next &#x3D; p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>出栈操作（出栈元素保存在x中）<br>/<em>类似于单链表的删除操作</em>/</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void PopStack(LinkStack top,DataType* data)</span><br><span class="line">&#123;</span><br><span class="line">    LStackNode* p;</span><br><span class="line">    p &#x3D; top-&gt;next;</span><br><span class="line">    if (p&#x3D;&#x3D;NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;栈为空！\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        top-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">        *data &#x3D; p-&gt;data;</span><br><span class="line">        free(p);   &#x2F;&#x2F;释放p指向的结点</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：排序</title>
      <link href="/deng123-dev.github.io/2020/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%8E%92%E5%BA%8F/"/>
      <url>/deng123-dev.github.io/2020/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概叙"><a href="#概叙" class="headerlink" title="概叙"></a>概叙</h2><hr><p><img src="/deng123-dev.github.io/images/pasted-49.png" alt=" "></p><a id="more"></a><p> 相关知识点：</p><ul><li><p>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</p></li><li><p>不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</p></li><li><p>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</p></li><li><p>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数</p></li></ul><p>2.它们之间的性能比较：<br><img src="/deng123-dev.github.io/images/pasted-10.png" alt="upload successful"><br>当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：<code>快速排序``堆排序</code> <code>归并排序</code></p><p>排序有<code>内部排序</code>和<code>外部排序</code>,内部排序是数据记录在<code>内存</code>中进行排序，而外部排序是排序的数据很大，一次不能容纳全部的排序记录，而排序过程中需要访问<code>外存</code></p><p><code>八大排序就是内部排序。</code></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><hr><h3 id="简单插入排序"><a href="#简单插入排序" class="headerlink" title="简单插入排序"></a>简单插入排序</h3><hr><h4 id="算法描述："><a href="#算法描述：" class="headerlink" title="算法描述："></a>算法描述：</h4><hr><ul><li>从第一个元素开始划分出一个有序的序列</li><li>依次取出下一个元素,在已经排序的元素序列中从后向前扫描</li><li>如果已排序元素大于新元素，该元素移到下一个我位置</li><li>重复步骤3，直到找到新元素所在位置</li><li>重复2，5步骤<br><img src="/deng123-dev.github.io/images/pasted-33.png" alt="upload successful"><!-- more --><h4 id="c语言实现："><a href="#c语言实现：" class="headerlink" title="c语言实现："></a>c语言实现：</h4></li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> #直接插入排序</span><br><span class="line"> </span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">void InsertionSort(int* arr,int len)</span><br><span class="line">&#123;</span><br><span class="line">int i ,j;</span><br><span class="line">for (i &#x3D; 1;i &lt;&#x3D; len;i++)</span><br><span class="line">&#123;</span><br><span class="line">j &#x3D; i;</span><br><span class="line">while (j--)</span><br><span class="line">&#123;</span><br><span class="line">if (arr[j - 1] &gt; arr[j])</span><br><span class="line">&#123;</span><br><span class="line">int temp &#x3D; arr[j - 1];</span><br><span class="line">arr[j - 1] &#x3D; arr[j];</span><br><span class="line">arr[j] &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">break;&#x2F;&#x2F;小于退出while循环提高效率</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int arr[] &#x3D; &#123;8,3,9,5,6,7,1,4,0,2&#125;;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">int len &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);</span><br><span class="line">InsertionSort(arr,len);</span><br><span class="line">for (i &#x3D; 0;i &lt; (sizeof(arr) &#x2F; sizeof(arr[0]));i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><hr><h4 id="算法描述：-1"><a href="#算法描述：-1" class="headerlink" title="算法描述："></a>算法描述：</h4><hr><p>又称<strong>缩小增量排序</strong></p><ul><li>选择一个增量序列</li><li>每趟排序，根据对应的增量t，进行两两数据比较，将小的放在前，大的放在后</li><li>重复第二步，直到增量已用尽</li></ul><p><img src="/deng123-dev.github.io/images/pasted-35.png" alt="upload successful"><br>简单选择排序的基本思想：<code>比较+交换</code></p><h4 id="c语言实现：-1"><a href="#c语言实现：-1" class="headerlink" title="c语言实现："></a>c语言实现：</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">void swap(int* L, int* R)</span><br><span class="line">&#123;</span><br><span class="line">int temp &#x3D; *L;</span><br><span class="line">*L &#x3D; *R;</span><br><span class="line">*R &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">void ShellSort(int* arr, int len)</span><br><span class="line">&#123;</span><br><span class="line">for (int gap &#x3D; (len &#x2F; 2); gap &gt; 0;gap &#x2F;&#x3D; 2)&#x2F;&#x2F;设置gap起始间距为长度的一半</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;以gap为间距组从一个组，每次对这个组进行直接插入排序</span><br><span class="line">for (int i &#x3D; gap; i &lt; len;i++)</span><br><span class="line">&#x2F;&#x2F;以gap位置为起始，找到每一个元素以gap间隔为组向前进行直接插入排序</span><br><span class="line">&#123;</span><br><span class="line">int j &#x3D; i;</span><br><span class="line">while ((arr[j]&lt; arr[j - gap]) &amp;&amp; j - gap &gt;&#x3D; 0)</span><br><span class="line">&#123;</span><br><span class="line">swap(&amp;arr[j],&amp;arr[j -gap]);</span><br><span class="line">j -&#x3D; gap;&#x2F;&#x2F;找到之前所有的成员比较并排序</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int arr[] &#x3D; &#123; 8,3,9,5,6,7,1,4,0,2 &#125;;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">int len &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);</span><br><span class="line">ShellSort(arr, len);</span><br><span class="line">for (i &#x3D; 0;i &lt; len;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><hr><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><hr><h4 id="算法描述：-2"><a href="#算法描述：-2" class="headerlink" title="算法描述："></a>算法描述：</h4><hr><ul><li>第一轮从头到尾对n个元素进行两两比较，进行调换位置</li><li>需要对余下的n-1个数据进行从头到尾两两比较直到数据有序为止</li></ul><p><img src="/deng123-dev.github.io/images/pasted-36.png" alt="upload successful"></p><h4 id="c语言实现：-2"><a href="#c语言实现：-2" class="headerlink" title="c语言实现："></a>c语言实现：</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">void bubbleSort(int* arr,int len)</span><br><span class="line">&#123;</span><br><span class="line">int i, j;</span><br><span class="line">for (i &#x3D; 0;i &lt; len - 1;i++)</span><br><span class="line">&#123;</span><br><span class="line">for (j &#x3D; 0;j &lt; len - 1 - i;j++)</span><br><span class="line">&#123;</span><br><span class="line">if (arr[j] &gt; arr[j + 1])</span><br><span class="line">&#123;</span><br><span class="line">int temp &#x3D; arr[j];</span><br><span class="line">arr[j] &#x3D; arr[j + 1];</span><br><span class="line">arr[j + 1] &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int arr[] &#x3D; &#123;6,3,8,7,5,4,1,2,0&#125;;</span><br><span class="line">int len &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);</span><br><span class="line">bubbleSort(arr,len);</span><br><span class="line">for (i &#x3D; 0;i &lt; (sizeof(arr) &#x2F; sizeof(arr[0]));i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><hr><h4 id="算法描述：-3"><a href="#算法描述：-3" class="headerlink" title="算法描述："></a>算法描述：</h4><hr><p><strong>实例排序：</strong></p><p><strong><em>一趟排序结果：{49 38 65 97 76 13 27 49’}</em></strong></p><p><strong><em>二趟排序结果：{27 38 13} 49 {76 97 65 49’}</em></strong></p><p><strong><em>三趟排序结果：{13} 27 {38} 49 {76 97 65 49’}</em></strong></p><p><strong><em>四趟排序结果：13 27 38 49 {49’ 65} 76 {97}</em></strong></p><ul><li>定义left和right指向头尾两个关键数据，定义一个基准值mid</li></ul><ul><li><p>将left指向元素大于基准值mid时和right指向元素小于基准值mid时，交换left和right所指元素</p></li><li><p>当low和high指针所指数据重叠时，将数据分为两组，重新设置头尾数据为low和high，重复上述操作，直至数据有序</p></li></ul><p><img src="/deng123-dev.github.io/images/pasted-37.png" alt="upload successful"></p><h4 id="c语言实现：-3"><a href="#c语言实现：-3" class="headerlink" title="c语言实现："></a>c语言实现：</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;assert.h&gt;</span><br><span class="line"> </span><br><span class="line">void QuickSort(int* arr,int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">int i &#x3D; left; </span><br><span class="line">int j &#x3D; right;</span><br><span class="line">int temp &#x3D; arr[i];</span><br><span class="line"> </span><br><span class="line">if (i &gt;&#x3D; j)</span><br><span class="line">return;</span><br><span class="line"> </span><br><span class="line">while (i !&#x3D; j)</span><br><span class="line">&#123;</span><br><span class="line">while (arr[j] &gt;&#x3D; temp &amp;&amp; i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">if (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] &#x3D; arr[j];</span><br><span class="line">&#125;</span><br><span class="line">while (arr[i] &lt;&#x3D; temp &amp;&amp; i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">if ( i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">arr[j] &#x3D; arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[i] &#x3D; temp;</span><br><span class="line">QuickSort(arr,left,i - 1);</span><br><span class="line">QuickSort(arr, i + 1, right);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int arr[] &#x3D; &#123;8,3,9,5,6,7,1,4,0,2&#125;;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">int len &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);</span><br><span class="line">QuickSort(arr,0,len - 1);</span><br><span class="line">for (i &#x3D; 0;i &lt; len ;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><hr><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><hr><h4 id="算法描述：-4"><a href="#算法描述：-4" class="headerlink" title="算法描述："></a>算法描述：</h4><hr><ul><li>在第一个位置开始从数组找到最小的数据</li></ul><ul><li>往下一个位置开始找到数组中最小的数据 </li></ul><ul><li>重复第二步，直到数组有序为止</li></ul><p><img src="/deng123-dev.github.io/images/pasted-38.png" alt="upload successful"></p><h4 id="c语言实现：-4"><a href="#c语言实现：-4" class="headerlink" title="c语言实现："></a>c语言实现：</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">void SelectionSort(int* arr, int len)</span><br><span class="line">&#123;</span><br><span class="line">int min;&#x2F;&#x2F;保存当前最小数字下标</span><br><span class="line">for (int i &#x3D; 0;i &lt; len - 1;i++)</span><br><span class="line">&#123;</span><br><span class="line">min &#x3D; i;</span><br><span class="line">for (int j &#x3D; i + 1;j &lt; len; j++)</span><br><span class="line">&#123;</span><br><span class="line">if (arr[min] &gt; arr[j])</span><br><span class="line">&#123;</span><br><span class="line">min &#x3D; j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int temp &#x3D; arr[min];</span><br><span class="line">arr[min] &#x3D; arr[i];</span><br><span class="line">arr[i] &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int arr[] &#x3D; &#123;8,3,9,5,6,7,1,4,0,2&#125;;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">int len &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);</span><br><span class="line">SelectionSort(arr,len);</span><br><span class="line">for (i &#x3D; 0;i &lt; len ;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><hr><h4 id="算法描述：-5"><a href="#算法描述：-5" class="headerlink" title="算法描述："></a>算法描述：</h4><hr><p>堆就是用数组实现的二叉树，所以没有父指针或字指针</p><p>堆分为两种：<strong>最大堆</strong> 和<strong>最小堆</strong></p><p>两者区别：</p><p>节点的值比每一个子节点的值都要大</p><p>节点的值比每一个子节点的值都要小</p><p>鉴于最大堆和最小堆是对称关系，理解其中一种即可。所以接下来我们为你们说明一下最大堆的排序</p><p>最大堆进行升序排序的思想：<br>1.<br>初始化堆：将数列a[1..n]构成最大堆</p><p>2.<br>交换数据：将a[1]和a[n] 交换，使a[n]是a[1…n]中的最大值；然后将a[1…n-1]重新调整为最大堆。 接着，将a[1]和a[n-1]交换，使a[n-1]是a[1…n-1]中的最大值；然后将a[1…n-2]重新调整为最大值。 依次类推，直到整个数列都是有序的。</p><h4 id="c语言实现：-5"><a href="#c语言实现：-5" class="headerlink" title="c语言实现："></a>c语言实现：</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;assert.h&gt;</span><br><span class="line">void AdjustHead(int *arr, int parent, int len)</span><br><span class="line">&#123;&#x2F;&#x2F;大堆</span><br><span class="line">assert(arr);</span><br><span class="line">int child &#x3D; parent * 2 + 1;</span><br><span class="line">while (child &lt; len)</span><br><span class="line">&#123;</span><br><span class="line">if (arr[child] &lt; arr[child + 1] &amp;&amp; child + 1 &lt; len)</span><br><span class="line">&#123;</span><br><span class="line">child +&#x3D; 1;&#x2F;&#x2F;左子树小于右子树交且合法时交换</span><br><span class="line">&#125;</span><br><span class="line">if (arr[child] &gt; arr[parent])</span><br><span class="line">&#123;&#x2F;&#x2F;将大值交给父亲节点</span><br><span class="line">int temp &#x3D; arr[child];</span><br><span class="line">arr[child] &#x3D; arr[parent];</span><br><span class="line">arr[parent] &#x3D; temp;</span><br><span class="line">&#x2F;&#x2F;复位，再次判断，防止左右孩子都大于双亲</span><br><span class="line">parent &#x3D; child;</span><br><span class="line">child &#x3D; parent * 2 + 1;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">return;&#x2F;&#x2F;不满足退出</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void HeapSort(int* arr, int len)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;建堆</span><br><span class="line">int root &#x3D; (len - 2) &gt;&gt; 1;&#x2F;&#x2F;找到最后一个非叶子节点</span><br><span class="line">for (root;root &gt;&#x3D; 0;--root)</span><br><span class="line">&#123;</span><br><span class="line">AdjustHead(arr, root, len);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;排序</span><br><span class="line">int end &#x3D; len - 1;</span><br><span class="line">while (end)</span><br><span class="line">&#123;</span><br><span class="line">int temp &#x3D; arr[0];</span><br><span class="line">arr[0] &#x3D; arr[end];</span><br><span class="line">arr[end] &#x3D; temp;</span><br><span class="line">&#x2F;&#x2F;循环排序每一个元素</span><br><span class="line">AdjustHead(arr,0,end);</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int arr[] &#x3D; &#123;8,3,9,5,6,7,1,4,0,2&#125;;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">int len &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);</span><br><span class="line">HeapSort(arr,len);</span><br><span class="line">for (i &#x3D; 0;i &lt; len ;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><hr><h3 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h3><hr><h4 id="算法描述：-6"><a href="#算法描述：-6" class="headerlink" title="算法描述："></a>算法描述：</h4><hr><ul><li>将长度为n的输入序列分为长度为n/2的子序列</li><li>对两个子序列分别采用归并排序</li><li>将两个排序号的子序列合并成一个最终的排序序列</li></ul><p><img src="/deng123-dev.github.io/images/pasted-39.png" alt="upload successful"></p><h4 id="c语言实现：-6"><a href="#c语言实现：-6" class="headerlink" title="c语言实现："></a>c语言实现：</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;assert.h&gt;</span><br><span class="line">&#x2F;&#x2F;合并</span><br><span class="line">void Merge(int* arr, int low, int mid, int high)</span><br><span class="line">&#123;</span><br><span class="line">int i &#x3D; low;&#x2F;&#x2F;第一组下标</span><br><span class="line">int j &#x3D; mid + 1;&#x2F;&#x2F;第二组下标</span><br><span class="line">int k &#x3D; 0;</span><br><span class="line">int arr2[100] &#x3D; &#123;0&#125;;&#x2F;&#x2F;临时排序存放序列</span><br><span class="line">&#x2F;&#x2F;循环判断arr[i]和arr[j]的值，谁小谁放在arr2中</span><br><span class="line">while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; high)</span><br><span class="line">&#123;</span><br><span class="line">if (arr[i] &lt;&#x3D; arr[j])</span><br><span class="line">&#123;</span><br><span class="line">arr2[k] &#x3D; arr[i];</span><br><span class="line">i++;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">arr2[k] &#x3D; arr[j];</span><br><span class="line">j++;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;当至少一组放完后，剩下的全部按顺序放入arr2（已经有序的数组）</span><br><span class="line">&#x2F;&#x2F;最后一组元素可能不过正常数量</span><br><span class="line">    while (i &lt;&#x3D; mid)</span><br><span class="line">&#123;</span><br><span class="line">arr2[k] &#x3D; arr[i];</span><br><span class="line">i++;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">while (j &lt;&#x3D; high)</span><br><span class="line">&#123;</span><br><span class="line">arr2[k] &#x3D; arr[j];</span><br><span class="line">j++;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;将arr2中的序列复制到arr中</span><br><span class="line">for (k &#x3D; 0, i &#x3D; low;i &lt;&#x3D; high;i++, k++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] &#x3D; arr2[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void MergeSort(int *arr, int len)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;间隔增加（gap就是一组几个元素）</span><br><span class="line">for( int gap &#x3D; 1;gap &lt; len;gap &#x3D; (gap * 2) )</span><br><span class="line">&#123;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;从间隔gap开始排序</span><br><span class="line">for (i &#x3D; 0;i + 2*gap - 1 &lt; len;i &#x3D; i + 2*gap)</span><br><span class="line">&#123;</span><br><span class="line">Merge(arr, i , i + gap - 1 , i + 2*gap - 1 );</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;当gap大于len的一半时，排序for无法排序的两个子组</span><br><span class="line">if (i + gap - 1 &lt; len) </span><br><span class="line">&#123;</span><br><span class="line">Merge(arr, i, i + gap - 1, len - 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int arr[] &#x3D; &#123;8,3,9,5,6,7,1,4,0,2&#125;;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">int len &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);</span><br><span class="line">MergeSort(arr,len );</span><br><span class="line">for (i &#x3D; 0;i &lt; len;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
